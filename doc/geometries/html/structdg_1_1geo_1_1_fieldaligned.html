<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Geometries: dg::geo::Fieldaligned&lt; ProductGeometry, IMatrix, container &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="tablist"> 
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dG</a></li>
    <li><a href="../../geometries/html/modules.html">geometries</a></li>
    <li><a href="../../file/html/namespacefile.html">file</a></li>
    <li><a href="../../exblas/html/namespaceexblas.html">exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Geometries
   </div>
   <div id="projectbrief">Extension with magnetic flux functions, grids and grid generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structdg_1_1geo_1_1_fieldaligned.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1geo_1_1_fieldaligned-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::geo::Fieldaligned&lt; ProductGeometry, IMatrix, container &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__fieldaligned.html">4. Fieldaligned derivatives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Create and manage interpolation matrices from fieldline integration.  
 <a href="structdg_1_1geo_1_1_fieldaligned.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fieldaligned_8h_source.html">fieldaligned.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8dbf31402248f22eb8ed54eadf5152a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#ab8dbf31402248f22eb8ed54eadf5152a">Fieldaligned</a> ()</td></tr>
<tr class="memdesc:ab8dbf31402248f22eb8ed54eadf5152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not allocate memory; no member call except construct is valid  <a href="#ab8dbf31402248f22eb8ed54eadf5152a">More...</a><br /></td></tr>
<tr class="separator:ab8dbf31402248f22eb8ed54eadf5152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753759cfcc2110718046b413d584dce5"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:a753759cfcc2110718046b413d584dce5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a753759cfcc2110718046b413d584dce5">Fieldaligned</a> (const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;vec, const ProductGeometry &amp;<a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a6db5e0c604847f0766de52a6fe64ca1d">grid</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), double eps=1e-5, unsigned multiplyX=10, unsigned multiplyY=10, bool dependsOnX=true, bool dependsOnY=true, bool integrateAll=true, double deltaPhi=-1)</td></tr>
<tr class="memdesc:a753759cfcc2110718046b413d584dce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a magnetic field and a grid.  <a href="#a753759cfcc2110718046b413d584dce5">More...</a><br /></td></tr>
<tr class="separator:a753759cfcc2110718046b413d584dce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf86a08ce44a275a4ed184be89bde10"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:abbf86a08ce44a275a4ed184be89bde10"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#abbf86a08ce44a275a4ed184be89bde10">Fieldaligned</a> (const <a class="el" href="structdg_1_1geo_1_1_binary_vector_lvl0.html">dg::geo::BinaryVectorLvl0</a> &amp;vec, const ProductGeometry &amp;<a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a6db5e0c604847f0766de52a6fe64ca1d">grid</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), double eps=1e-5, unsigned multiplyX=10, unsigned multiplyY=10, bool dependsOnX=true, bool dependsOnY=true, bool integrateAll=true, double deltaPhi=-1)</td></tr>
<tr class="memdesc:abbf86a08ce44a275a4ed184be89bde10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a vector field and a grid.  <a href="#abbf86a08ce44a275a4ed184be89bde10">More...</a><br /></td></tr>
<tr class="separator:abbf86a08ce44a275a4ed184be89bde10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fa70e7466201ab62cd68c55a5d822d"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:a88fa70e7466201ab62cd68c55a5d822d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a88fa70e7466201ab62cd68c55a5d822d">construct</a> (const <a class="el" href="structdg_1_1geo_1_1_binary_vector_lvl0.html">dg::geo::BinaryVectorLvl0</a> &amp;vec, const ProductGeometry &amp;<a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a6db5e0c604847f0766de52a6fe64ca1d">grid</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), double eps=1e-5, unsigned multiplyX=10, unsigned multiplyY=10, bool dependsOnX=true, bool dependsOnY=true, bool integrateAll=true, double deltaPhi=-1)</td></tr>
<tr class="memdesc:a88fa70e7466201ab62cd68c55a5d822d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a field and a grid.  <a href="#a88fa70e7466201ab62cd68c55a5d822d">More...</a><br /></td></tr>
<tr class="separator:a88fa70e7466201ab62cd68c55a5d822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61bc87ebb44033113209fe4d333ffa9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#ad61bc87ebb44033113209fe4d333ffa9">dependsOnX</a> () const </td></tr>
<tr class="separator:ad61bc87ebb44033113209fe4d333ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cfadd891afb0d7b3e3a1478ec68ee4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a21cfadd891afb0d7b3e3a1478ec68ee4">dependsOnY</a> () const </td></tr>
<tr class="separator:a21cfadd891afb0d7b3e3a1478ec68ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b8f74725ee49e103d4d9eb9f23bafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a75b8f74725ee49e103d4d9eb9f23bafa">set_boundaries</a> (<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, double left, double right)</td></tr>
<tr class="memdesc:a75b8f74725ee49e103d4d9eb9f23bafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="#a75b8f74725ee49e103d4d9eb9f23bafa">More...</a><br /></td></tr>
<tr class="separator:a75b8f74725ee49e103d4d9eb9f23bafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbbe5f97222f049d0526ef6d6ff3279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#afdbbe5f97222f049d0526ef6d6ff3279">set_boundaries</a> (<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;left, const container &amp;right)</td></tr>
<tr class="memdesc:afdbbe5f97222f049d0526ef6d6ff3279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="#afdbbe5f97222f049d0526ef6d6ff3279">More...</a><br /></td></tr>
<tr class="separator:afdbbe5f97222f049d0526ef6d6ff3279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caf11ed3c059894ec530a24c2233d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a9caf11ed3c059894ec530a24c2233d17">set_boundaries</a> (<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;global, double scal_left, double scal_right)</td></tr>
<tr class="memdesc:a9caf11ed3c059894ec530a24c2233d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="#a9caf11ed3c059894ec530a24c2233d17">More...</a><br /></td></tr>
<tr class="separator:a9caf11ed3c059894ec530a24c2233d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee88dfa3dec3908526fd7ea06a67f54a"><td class="memTemplParams" colspan="2">template&lt;class BinaryOp &gt; </td></tr>
<tr class="memitem:aee88dfa3dec3908526fd7ea06a67f54a"><td class="memTemplItemLeft" align="right" valign="top">container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#aee88dfa3dec3908526fd7ea06a67f54a">evaluate</a> (const BinaryOp &amp;binary, unsigned p0=0) const </td></tr>
<tr class="memdesc:aee88dfa3dec3908526fd7ea06a67f54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a 2d functor and transform to all planes along the fieldlines.  <a href="#aee88dfa3dec3908526fd7ea06a67f54a">More...</a><br /></td></tr>
<tr class="separator:aee88dfa3dec3908526fd7ea06a67f54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47601074730f4e33d28d712b35f9d71"><td class="memTemplParams" colspan="2">template&lt;class BinaryOp , class UnaryOp &gt; </td></tr>
<tr class="memitem:af47601074730f4e33d28d712b35f9d71"><td class="memTemplItemLeft" align="right" valign="top">container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#af47601074730f4e33d28d712b35f9d71">evaluate</a> (const BinaryOp &amp;binary, const UnaryOp &amp;unary, unsigned p0, unsigned rounds) const </td></tr>
<tr class="memdesc:af47601074730f4e33d28d712b35f9d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a 2d functor and transform to all planes along the fieldlines.  <a href="#af47601074730f4e33d28d712b35f9d71">More...</a><br /></td></tr>
<tr class="separator:af47601074730f4e33d28d712b35f9d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea42e6ede96ce97bc9d7abcceb2c48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a6ea42e6ede96ce97bc9d7abcceb2c48f">operator()</a> (enum <a class="el" href="group__fieldaligned.html#ga10e4ac4f15fe73a4ff10569985224101">whichMatrix</a> which, const container &amp;in, container &amp;out)</td></tr>
<tr class="memdesc:a6ea42e6ede96ce97bc9d7abcceb2c48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the interpolation.  <a href="#a6ea42e6ede96ce97bc9d7abcceb2c48f">More...</a><br /></td></tr>
<tr class="separator:a6ea42e6ede96ce97bc9d7abcceb2c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb657acd30f8f8dd056c65f778f2bd57"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#adb657acd30f8f8dd056c65f778f2bd57">hz_inv</a> () const </td></tr>
<tr class="memdesc:adb657acd30f8f8dd056c65f778f2bd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">hz is the distance between the plus and minus planes  <a href="#adb657acd30f8f8dd056c65f778f2bd57">More...</a><br /></td></tr>
<tr class="separator:adb657acd30f8f8dd056c65f778f2bd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62e4d36d2f4c76c1ab5c2066e8c7be0"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#ac62e4d36d2f4c76c1ab5c2066e8c7be0">hp_inv</a> () const </td></tr>
<tr class="memdesc:ac62e4d36d2f4c76c1ab5c2066e8c7be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">hp is the distance between the plus and current planes  <a href="#ac62e4d36d2f4c76c1ab5c2066e8c7be0">More...</a><br /></td></tr>
<tr class="separator:ac62e4d36d2f4c76c1ab5c2066e8c7be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ff76e1eb213daa0fc2c57cf530ee86"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a91ff76e1eb213daa0fc2c57cf530ee86">hm_inv</a> () const </td></tr>
<tr class="memdesc:a91ff76e1eb213daa0fc2c57cf530ee86"><td class="mdescLeft">&#160;</td><td class="mdescRight">hm is the distance between the current and minus planes  <a href="#a91ff76e1eb213daa0fc2c57cf530ee86">More...</a><br /></td></tr>
<tr class="separator:a91ff76e1eb213daa0fc2c57cf530ee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db5e0c604847f0766de52a6fe64ca1d"><td class="memItemLeft" align="right" valign="top">const ProductGeometry &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a6db5e0c604847f0766de52a6fe64ca1d">grid</a> () const </td></tr>
<tr class="separator:a6db5e0c604847f0766de52a6fe64ca1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ProductGeometry, class IMatrix, class container&gt;<br />
struct dg::geo::Fieldaligned&lt; ProductGeometry, IMatrix, container &gt;</h3>

<p>Create and manage interpolation matrices from fieldline integration. </p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/structdg_1_1_cylindrical_grid3d.html">dg::CylindricalGrid3d</a> g3d( R_0 - a, R_0+a, -a, a, 0, 2.*M_PI, n, Nx, Ny, Nz, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>);</div><div class="line">    <span class="comment">//create magnetic field</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> mag = <a class="code" href="group__geom.html#gaa6d78afe4f306e34d509934f8f79421a">dg::geo::createCircularField</a>( R_0, I_0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structdg_1_1geo_1_1_binary_vector_lvl0.html">dg::geo::BinaryVectorLvl0</a> bhat( (<a class="code" href="structdg_1_1geo_1_1_b_hat_r.html">dg::geo::BHatR</a>)(mag), (<a class="code" href="structdg_1_1geo_1_1_b_hat_z.html">dg::geo::BHatZ</a>)(mag), (<a class="code" href="structdg_1_1geo_1_1_b_hat_p.html">dg::geo::BHatP</a>)(mag));</div><div class="line">    <span class="comment">//create Fieldaligned object and construct DS from it</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned&lt;dg::aProductGeometry3d,dg::IDMatrix,dg::DVec&gt;</a>  dsFA( bhat, g3d, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/structdg_1_1_z_e_r_o.html">dg::geo::NoLimiter</a>(), 1e-8, mx, my, <span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>);</div><div class="line">    <a class="code" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS&lt;dg::aProductGeometry3d, dg::IDMatrix, dg::DMatrix, dg::DVec&gt;</a> ds( dsFA, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066">dg::not_normed</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>);</div><div class="line">    <span class="comment">//apply to function</span></div><div class="line">    <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> <span class="keyword">function</span> = <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__evaluation.html#ga7521f4acb4edaf2d7896d99f97e1ed9d">dg::evaluate</a>( func, g3d), derivative(<span class="keyword">function</span>);</div><div class="line">    ds( <span class="keyword">function</span>, derivative);</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ProductGeometry</td><td>must be either <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/structdg_1_1a_product_geometry3d.html">dg::aProductGeometry3d</a></code> or <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/structdg_1_1a_product_m_p_i_geometry3d.html">dg::aProductMPIGeometry3d</a></code> or any derivative </td></tr>
    <tr><td class="paramname">IMatrix</td><td>The type of the interpolation matrix<ul>
<li><code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga0af8204731ee6327dc4616a5980af2d5">dg::IHMatrix</a></code>, or <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga0d122f4172a3e60105754f9419c0831f">dg::IDMatrix</a></code>, <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a></code>, or <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga2fdf95d30a7a404b03e2e5ed4e88b603">dg::MIDMatrix</a></code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">container</td><td>The container-class on which the interpolation matrix operates on<ul>
<li><code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gab99e8227ed890885a7b9915806865a7a">dg::HVec</a></code>, or <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a></code>, <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f">dg::MHVec</a></code>, or <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga25cae493b710b17992387cce395ad7ae">dg::MDVec</a></code> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The pdf <a href="./parallel.pdf" target="_blank">parallel derivative</a> writeup </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab8dbf31402248f22eb8ed54eadf5152a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">Fieldaligned</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>do not allocate memory; no member call except construct is valid </p>

</div>
</div>
<a class="anchor" id="a753759cfcc2110718046b413d584dce5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">Fieldaligned</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyX</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyY</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnX</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnY</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>integrateAll</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a magnetic field and a grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to operate defines the parallel boundary condition in case there is a limiter. </td></tr>
    <tr><td class="paramname">bcx</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">bcy</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Default is a limiter everywhere, note that if <code>grid.bcz()</code> is periodic it doesn't matter if there is a limiter or not)</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">multiplyX</td><td>defines the resolution in X of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">multiplyY</td><td>defines the resolution in Y of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">dependsOnX</td><td>indicates, whether the given vector field vec depends on the first coordinate </td></tr>
    <tr><td class="paramname">dependsOnY</td><td>indicates, whether the given vector field vec depends on the second coordinate </td></tr>
    <tr><td class="paramname">integrateAll</td><td>indicates, that all fieldlines of the fine grid should be integrated instead of interpolating it from the coarse grid. Should be true if the streamlines of the vector field cross the domain boudary. </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>Is either &lt;0 (then it's ignored), or may differ from <code>grid.hz()</code> if <code>grid.Nz()</code> == 1, then <code>deltaPhi</code> is taken instead of <code>grid.hz()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>

</div>
</div>
<a class="anchor" id="abbf86a08ce44a275a4ed184be89bde10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">Fieldaligned</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_binary_vector_lvl0.html">dg::geo::BinaryVectorLvl0</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyX</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyY</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnX</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnY</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>integrateAll</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a vector field and a grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to operate defines the parallel boundary condition in case there is a limiter. </td></tr>
    <tr><td class="paramname">bcx</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">bcy</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Default is a limiter everywhere, note that if <code>grid.bcz()</code> is periodic it doesn't matter if there is a limiter or not)</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">multiplyX</td><td>defines the resolution in X of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">multiplyY</td><td>defines the resolution in Y of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">dependsOnX</td><td>indicates, whether the given vector field vec depends on the first coordinate </td></tr>
    <tr><td class="paramname">dependsOnY</td><td>indicates, whether the given vector field vec depends on the second coordinate </td></tr>
    <tr><td class="paramname">integrateAll</td><td>indicates, that all fieldlines of the fine grid should be integrated instead of interpolating it from the coarse grid. Should be true if the streamlines of the vector field cross the domain boudary. </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>Is either &lt;0 (then it's ignored), or may differ from <code>grid.hz()</code> if <code>grid.Nz()</code> == 1, then <code>deltaPhi</code> is taken instead of <code>grid.hz()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a88fa70e7466201ab62cd68c55a5d822d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_binary_vector_lvl0.html">dg::geo::BinaryVectorLvl0</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyX</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyY</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnX</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnY</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>integrateAll</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a field and a grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to operate defines the parallel boundary condition in case there is a limiter. </td></tr>
    <tr><td class="paramname">bcx</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">bcy</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Default is a limiter everywhere, note that if <code>grid.bcz()</code> is periodic it doesn't matter if there is a limiter or not)</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">multiplyX</td><td>defines the resolution in X of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">multiplyY</td><td>defines the resolution in Y of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">dependsOnX</td><td>indicates, whether the given vector field vec depends on the first coordinate </td></tr>
    <tr><td class="paramname">dependsOnY</td><td>indicates, whether the given vector field vec depends on the second coordinate </td></tr>
    <tr><td class="paramname">integrateAll</td><td>indicates, that all fieldlines of the fine grid should be integrated instead of interpolating it from the coarse grid. Should be true if the streamlines of the vector field cross the domain boudary. </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>Is either &lt;0 (then it's ignored), or may differ from <code>grid.hz()</code> if <code>grid.Nz()</code> == 1, then <code>deltaPhi</code> is taken instead of <code>grid.hz()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>

</div>
</div>
<a class="anchor" id="ad61bc87ebb44033113209fe4d333ffa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::dependsOnX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a21cfadd891afb0d7b3e3a1478ec68ee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::dependsOnY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aee88dfa3dec3908526fd7ea06a67f54a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<div class="memtemplate">
template&lt;class BinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">container <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const BinaryOp &amp;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>p0</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate a 2d functor and transform to all planes along the fieldlines. </p>
<p>Evaluates the given functor on a 2d plane and then follows fieldlines to get the values in the 3rd dimension. Uses the grid given in the constructor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>Binary Functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary</td><td>Functor to evaluate </td></tr>
    <tr><td class="paramname">p0</td><td>The index of the plane to start</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of container </dd></dl>

</div>
</div>
<a class="anchor" id="af47601074730f4e33d28d712b35f9d71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<div class="memtemplate">
template&lt;class BinaryOp , class UnaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">container <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const BinaryOp &amp;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryOp &amp;&#160;</td>
          <td class="paramname"><em>unary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a 2d functor and transform to all planes along the fieldlines. </p>
<p>The algorithm does the equivalent of the following:</p><ul>
<li>Evaluate the given <code>BinaryOp</code> on a 2d plane</li>
<li>Apply the plus and minus transformation each \( r N_z\) times where \( N_z\) is the number of planes in the global 3d grid and \( r\) is the number of rounds.</li>
<li>Scale the transformations with \( u ( \pm (iN_z + j)h_z) \), where <code>u</code> is the given <code>UnarayOp</code>, <code>i</code> is the round index and <code>j</code> is the plane index.</li>
<li>Sum all transformations with the same plane index <code>j</code> , where the minus transformations get the inverted index \( N_z - j\).</li>
<li>Shift the index by \( p_0\)</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>Binary Functor </td></tr>
    <tr><td class="paramname">UnaryOp</td><td>Unary Functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary</td><td>Functor to evaluate in x-y </td></tr>
    <tr><td class="paramname">unary</td><td>Functor to evaluate in z </td></tr>
    <tr><td class="paramname">p0</td><td>The index of the plane to start </td></tr>
    <tr><td class="paramname">rounds</td><td>The number of rounds <code>r</code> to follow a fieldline; can be zero, then the fieldlines are only followed within the current box ( no periodicity) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>g is evaluated such that p0 corresponds to z=0, p0+1 corresponds to z=hz, p0-1 to z=-hz, ...</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of container </dd></dl>

</div>
</div>
<a class="anchor" id="a6db5e0c604847f0766de52a6fe64ca1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ProductGeometry&amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::grid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a91ff76e1eb213daa0fc2c57cf530ee86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container&amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::hm_inv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hm is the distance between the current and minus planes </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a class="anchor" id="ac62e4d36d2f4c76c1ab5c2066e8c7be0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container&amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::hp_inv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hp is the distance between the plus and current planes </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a class="anchor" id="adb657acd30f8f8dd056c65f778f2bd57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container&amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::hz_inv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hz is the distance between the plus and minus planes </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a class="anchor" id="a6ea42e6ede96ce97bc9d7abcceb2c48f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__fieldaligned.html#ga10e4ac4f15fe73a4ff10569985224101">whichMatrix</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specify what interpolation should be applied </td></tr>
    <tr><td class="paramname">in</td><td>input </td></tr>
    <tr><td class="paramname">out</td><td>output may not equal input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75b8f74725ee49e103d4d9eb9f23bafa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>constant left boundary value </td></tr>
    <tr><td class="paramname">right</td><td>constant right boundary value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdbbe5f97222f049d0526ef6d6ff3279"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>spatially variable left boundary value (2d size) </td></tr>
    <tr><td class="paramname">right</td><td>spatially variable right boundary value (2d size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9caf11ed3c059894ec530a24c2233d17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">global</td><td>3D vector containing boundary values </td></tr>
    <tr><td class="paramname">scal_left</td><td>left scaling factor </td></tr>
    <tr><td class="paramname">scal_right</td><td>right scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="fieldaligned_8h_source.html">fieldaligned.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="namespacedg_1_1geo.html">geo</a></li><li class="navelem"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">Fieldaligned</a></li>
    <li class="footer">Generated on Thu Apr 26 2018 16:28:25 for Geometries by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
