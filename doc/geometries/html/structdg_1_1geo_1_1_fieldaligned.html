<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extension: Geometries: dg::geo::Fieldaligned&lt; ProductGeometry, IMatrix, container &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extension: Geometries
   </div>
   <div id="projectbrief">#include &quot;dg/geometries/geometries.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structdg_1_1geo_1_1_fieldaligned.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1geo_1_1_fieldaligned-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::geo::Fieldaligned&lt; ProductGeometry, IMatrix, container &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__fieldaligned.html">4. Fieldaligned derivatives</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Create and manage interpolation matrices from fieldline integration.  
 <a href="structdg_1_1geo_1_1_fieldaligned.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8dbf31402248f22eb8ed54eadf5152a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#ab8dbf31402248f22eb8ed54eadf5152a">Fieldaligned</a> ()</td></tr>
<tr class="memdesc:ab8dbf31402248f22eb8ed54eadf5152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not allocate memory; no member call except construct is valid  <a href="structdg_1_1geo_1_1_fieldaligned.html#ab8dbf31402248f22eb8ed54eadf5152a">More...</a><br /></td></tr>
<tr class="separator:ab8dbf31402248f22eb8ed54eadf5152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20751293b2f43fc0821a8efbf2e0d2e"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:ab20751293b2f43fc0821a8efbf2e0d2e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#ab20751293b2f43fc0821a8efbf2e0d2e">Fieldaligned</a> (const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;vec, const ProductGeometry &amp;<a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#af44d06d4f39a0aa51184c1a75cb3d899">grid</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a0467cd614bca4ebbe231155453d647cd">bcx</a>=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#aa5add7df8d14903c8adff9243a128237">bcy</a>=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), double eps=1e-5, unsigned mx=10, unsigned my=10, double <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#aaea82cc54bcadb13b9d55ded7f70015a">deltaPhi</a>=-1, std::string interpolation_method=&quot;dg&quot;, bool benchmark=true)</td></tr>
<tr class="memdesc:ab20751293b2f43fc0821a8efbf2e0d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a magnetic field and a grid.  <a href="structdg_1_1geo_1_1_fieldaligned.html#ab20751293b2f43fc0821a8efbf2e0d2e">More...</a><br /></td></tr>
<tr class="separator:ab20751293b2f43fc0821a8efbf2e0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af507ab26311f23b41c47b66d0fa9be70"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:af507ab26311f23b41c47b66d0fa9be70"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#af507ab26311f23b41c47b66d0fa9be70">Fieldaligned</a> (const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl1.html">dg::geo::CylindricalVectorLvl1</a> &amp;vec, const ProductGeometry &amp;<a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#af44d06d4f39a0aa51184c1a75cb3d899">grid</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a0467cd614bca4ebbe231155453d647cd">bcx</a>=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#aa5add7df8d14903c8adff9243a128237">bcy</a>=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), double eps=1e-5, unsigned mx=10, unsigned my=10, double <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#aaea82cc54bcadb13b9d55ded7f70015a">deltaPhi</a>=-1, std::string interpolation_method=&quot;dg&quot;, bool benchmark=true)</td></tr>
<tr class="memdesc:af507ab26311f23b41c47b66d0fa9be70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a vector field and a grid.  <a href="structdg_1_1geo_1_1_fieldaligned.html#af507ab26311f23b41c47b66d0fa9be70">More...</a><br /></td></tr>
<tr class="separator:af507ab26311f23b41c47b66d0fa9be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90913a78a7c6bd680f3ad55f071b58a"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:ab90913a78a7c6bd680f3ad55f071b58a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#ab90913a78a7c6bd680f3ad55f071b58a">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:ab90913a78a7c6bd680f3ad55f071b58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.  <a href="structdg_1_1geo_1_1_fieldaligned.html#ab90913a78a7c6bd680f3ad55f071b58a">More...</a><br /></td></tr>
<tr class="separator:ab90913a78a7c6bd680f3ad55f071b58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0467cd614bca4ebbe231155453d647cd"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a0467cd614bca4ebbe231155453d647cd">bcx</a> () const</td></tr>
<tr class="separator:a0467cd614bca4ebbe231155453d647cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5add7df8d14903c8adff9243a128237"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#aa5add7df8d14903c8adff9243a128237">bcy</a> () const</td></tr>
<tr class="separator:aa5add7df8d14903c8adff9243a128237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b8f74725ee49e103d4d9eb9f23bafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a75b8f74725ee49e103d4d9eb9f23bafa">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, double left, double right)</td></tr>
<tr class="memdesc:a75b8f74725ee49e103d4d9eb9f23bafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="structdg_1_1geo_1_1_fieldaligned.html#a75b8f74725ee49e103d4d9eb9f23bafa">More...</a><br /></td></tr>
<tr class="separator:a75b8f74725ee49e103d4d9eb9f23bafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbbe5f97222f049d0526ef6d6ff3279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#afdbbe5f97222f049d0526ef6d6ff3279">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;left, const container &amp;right)</td></tr>
<tr class="memdesc:afdbbe5f97222f049d0526ef6d6ff3279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="structdg_1_1geo_1_1_fieldaligned.html#afdbbe5f97222f049d0526ef6d6ff3279">More...</a><br /></td></tr>
<tr class="separator:afdbbe5f97222f049d0526ef6d6ff3279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caf11ed3c059894ec530a24c2233d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a9caf11ed3c059894ec530a24c2233d17">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;global, double scal_left, double scal_right)</td></tr>
<tr class="memdesc:a9caf11ed3c059894ec530a24c2233d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="structdg_1_1geo_1_1_fieldaligned.html#a9caf11ed3c059894ec530a24c2233d17">More...</a><br /></td></tr>
<tr class="separator:a9caf11ed3c059894ec530a24c2233d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea42e6ede96ce97bc9d7abcceb2c48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a6ea42e6ede96ce97bc9d7abcceb2c48f">operator()</a> (enum <a class="el" href="group__fieldaligned.html#ga10e4ac4f15fe73a4ff10569985224101">whichMatrix</a> which, const container &amp;in, container &amp;out)</td></tr>
<tr class="memdesc:a6ea42e6ede96ce97bc9d7abcceb2c48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the interpolation to three-dimensional vectors.  <a href="structdg_1_1geo_1_1_fieldaligned.html#a6ea42e6ede96ce97bc9d7abcceb2c48f">More...</a><br /></td></tr>
<tr class="separator:a6ea42e6ede96ce97bc9d7abcceb2c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea82cc54bcadb13b9d55ded7f70015a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#aaea82cc54bcadb13b9d55ded7f70015a">deltaPhi</a> () const</td></tr>
<tr class="separator:aaea82cc54bcadb13b9d55ded7f70015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892fc4ea2ea56bca5dee3537a1ed42a7"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a892fc4ea2ea56bca5dee3537a1ed42a7">hbm</a> () const</td></tr>
<tr class="memdesc:a892fc4ea2ea56bca5dee3537a1ed42a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="elRef" href="../../dg/html/structdg_1_1_distance.html">Distance</a> between the planes and the boundary \( (s_{k}-s_{b}^-) \).  <a href="structdg_1_1geo_1_1_fieldaligned.html#a892fc4ea2ea56bca5dee3537a1ed42a7">More...</a><br /></td></tr>
<tr class="separator:a892fc4ea2ea56bca5dee3537a1ed42a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7a7092df5e25d414337216588a73de"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a0f7a7092df5e25d414337216588a73de">hbp</a> () const</td></tr>
<tr class="memdesc:a0f7a7092df5e25d414337216588a73de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="elRef" href="../../dg/html/structdg_1_1_distance.html">Distance</a> between the planes \( (s_b^+-s_{k}) \).  <a href="structdg_1_1geo_1_1_fieldaligned.html#a0f7a7092df5e25d414337216588a73de">More...</a><br /></td></tr>
<tr class="separator:a0f7a7092df5e25d414337216588a73de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65433ae8e8bda1e1651a9e3c5d47ece0"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a65433ae8e8bda1e1651a9e3c5d47ece0">sqrtG</a> () const</td></tr>
<tr class="memdesc:a65433ae8e8bda1e1651a9e3c5d47ece0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume form (including weights) \( \sqrt{G}_{k} \).  <a href="structdg_1_1geo_1_1_fieldaligned.html#a65433ae8e8bda1e1651a9e3c5d47ece0">More...</a><br /></td></tr>
<tr class="separator:a65433ae8e8bda1e1651a9e3c5d47ece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71673fd97b743d39945b227cbce595b0"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a71673fd97b743d39945b227cbce595b0">sqrtGm</a> () const</td></tr>
<tr class="memdesc:a71673fd97b743d39945b227cbce595b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume form on minus plane (including weights) \( \sqrt{G}_{k-1} \).  <a href="structdg_1_1geo_1_1_fieldaligned.html#a71673fd97b743d39945b227cbce595b0">More...</a><br /></td></tr>
<tr class="separator:a71673fd97b743d39945b227cbce595b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a928fd89bcde1864f78dc1a093d59f"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#ae1a928fd89bcde1864f78dc1a093d59f">sqrtGp</a> () const</td></tr>
<tr class="memdesc:ae1a928fd89bcde1864f78dc1a093d59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume form on plus plane (including weights) \( \sqrt{G}_{k+1} \).  <a href="structdg_1_1geo_1_1_fieldaligned.html#ae1a928fd89bcde1864f78dc1a093d59f">More...</a><br /></td></tr>
<tr class="separator:ae1a928fd89bcde1864f78dc1a093d59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2711b5e0ba62960915915b016af5581a"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a2711b5e0ba62960915915b016af5581a">bphi</a> () const</td></tr>
<tr class="memdesc:a2711b5e0ba62960915915b016af5581a"><td class="mdescLeft">&#160;</td><td class="mdescRight">bphi  <a href="structdg_1_1geo_1_1_fieldaligned.html#a2711b5e0ba62960915915b016af5581a">More...</a><br /></td></tr>
<tr class="separator:a2711b5e0ba62960915915b016af5581a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b7f11cedf6d236ca58a85b98c3f90a"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#aa4b7f11cedf6d236ca58a85b98c3f90a">bphiM</a> () const</td></tr>
<tr class="memdesc:aa4b7f11cedf6d236ca58a85b98c3f90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">bphi on minus plane  <a href="structdg_1_1geo_1_1_fieldaligned.html#aa4b7f11cedf6d236ca58a85b98c3f90a">More...</a><br /></td></tr>
<tr class="separator:aa4b7f11cedf6d236ca58a85b98c3f90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bfa03ea2797271a10406d242708793"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#ae6bfa03ea2797271a10406d242708793">bphiP</a> () const</td></tr>
<tr class="memdesc:ae6bfa03ea2797271a10406d242708793"><td class="mdescLeft">&#160;</td><td class="mdescRight">bphi on plus plane  <a href="structdg_1_1geo_1_1_fieldaligned.html#ae6bfa03ea2797271a10406d242708793">More...</a><br /></td></tr>
<tr class="separator:ae6bfa03ea2797271a10406d242708793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddf46de10d03df41e6914c21c7083f0"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#adddf46de10d03df41e6914c21c7083f0">bbm</a> () const</td></tr>
<tr class="memdesc:adddf46de10d03df41e6914c21c7083f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask minus, 1 if fieldline intersects wall in minus direction but not in plus direction, 0 else.  <a href="structdg_1_1geo_1_1_fieldaligned.html#adddf46de10d03df41e6914c21c7083f0">More...</a><br /></td></tr>
<tr class="separator:adddf46de10d03df41e6914c21c7083f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbdec0bfe9bc3584b976d3fa034161f"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#abfbdec0bfe9bc3584b976d3fa034161f">bbo</a> () const</td></tr>
<tr class="memdesc:abfbdec0bfe9bc3584b976d3fa034161f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask both, 1 if fieldline intersects wall in plus direction and in minus direction, 0 else.  <a href="structdg_1_1geo_1_1_fieldaligned.html#abfbdec0bfe9bc3584b976d3fa034161f">More...</a><br /></td></tr>
<tr class="separator:abfbdec0bfe9bc3584b976d3fa034161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3665adaa5b8b3a4a674f78e7ea7a7d"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a5f3665adaa5b8b3a4a674f78e7ea7a7d">bbp</a> () const</td></tr>
<tr class="memdesc:a5f3665adaa5b8b3a4a674f78e7ea7a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask plus, 1 if fieldline intersects wall in plus direction but not in minus direction, 0 else.  <a href="structdg_1_1geo_1_1_fieldaligned.html#a5f3665adaa5b8b3a4a674f78e7ea7a7d">More...</a><br /></td></tr>
<tr class="separator:a5f3665adaa5b8b3a4a674f78e7ea7a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44d06d4f39a0aa51184c1a75cb3d899"><td class="memItemLeft" align="right" valign="top">const ProductGeometry &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#af44d06d4f39a0aa51184c1a75cb3d899">grid</a> () const</td></tr>
<tr class="memdesc:af44d06d4f39a0aa51184c1a75cb3d899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid used for construction.  <a href="structdg_1_1geo_1_1_fieldaligned.html#af44d06d4f39a0aa51184c1a75cb3d899">More...</a><br /></td></tr>
<tr class="separator:af44d06d4f39a0aa51184c1a75cb3d899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41494a71690b278c03c5c55f9fe8ece9"><td class="memItemLeft" align="right" valign="top">container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a41494a71690b278c03c5c55f9fe8ece9">interpolate_from_coarse_grid</a> (const ProductGeometry &amp;grid_coarse, const container &amp;coarse)</td></tr>
<tr class="memdesc:a41494a71690b278c03c5c55f9fe8ece9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate along fieldlines from a coarse to a fine grid in phi.  <a href="structdg_1_1geo_1_1_fieldaligned.html#a41494a71690b278c03c5c55f9fe8ece9">More...</a><br /></td></tr>
<tr class="separator:a41494a71690b278c03c5c55f9fe8ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d031e50eb1b9f152e658378e04bf401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a4d031e50eb1b9f152e658378e04bf401">integrate_between_coarse_grid</a> (const ProductGeometry &amp;grid_coarse, const container &amp;coarse, container &amp;out)</td></tr>
<tr class="memdesc:a4d031e50eb1b9f152e658378e04bf401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a 2d function on the fine grid.  <a href="structdg_1_1geo_1_1_fieldaligned.html#a4d031e50eb1b9f152e658378e04bf401">More...</a><br /></td></tr>
<tr class="separator:a4d031e50eb1b9f152e658378e04bf401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62998cfeca17015be3d094c090a9f295"><td class="memTemplParams" colspan="2">template&lt;class BinaryOp , class UnaryOp &gt; </td></tr>
<tr class="memitem:a62998cfeca17015be3d094c090a9f295"><td class="memTemplItemLeft" align="right" valign="top">container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a62998cfeca17015be3d094c090a9f295">evaluate</a> (BinaryOp binary, UnaryOp unary, unsigned p0, unsigned rounds) const</td></tr>
<tr class="memdesc:a62998cfeca17015be3d094c090a9f295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a 2d functor and transform to all planes along the fieldline  <a href="structdg_1_1geo_1_1_fieldaligned.html#a62998cfeca17015be3d094c090a9f295">More...</a><br /></td></tr>
<tr class="separator:a62998cfeca17015be3d094c090a9f295"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ProductGeometry, class IMatrix, class container&gt;<br />
struct dg::geo::Fieldaligned&lt; ProductGeometry, IMatrix, container &gt;</div><p >Create and manage interpolation matrices from fieldline integration. </p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code hl_structRef" href="../../dg/html/structdg_1_1_real_cylindrical_grid3d.html">dg::CylindricalGrid3d</a> g3d( R_0-a, R_0+a, -a, a, 0, 2.*M_PI, n, Nx, Ny, Nz, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>);</div>
<div class="line">    <span class="comment">//create magnetic field</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> mag = <a class="code hl_function" href="group__circular.html#ga16471692288263e2076b897dae16799f">dg::geo::createCircularField</a>( R_0, I_0);</div>
<div class="line">    <span class="keyword">auto</span> bhat = <a class="code hl_function" href="group__magnetic.html#gac7f646da25a618a26e3f6ff9ba3ff09e">dg::geo::createBHat</a>(mag);</div>
<div class="line">    <span class="comment">//create Fieldaligned object and construct DS from it</span></div>
<div class="line">    <a class="code hl_struct" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned&lt;dg::aProductGeometry3d,dg::IDMatrix,dg::DVec&gt;</a>  dsFA(</div>
<div class="line">            bhat, g3d, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_structRef" href="../../dg/html/structdg_1_1_z_e_r_o.html">dg::geo::NoLimiter</a>(), 1e-8, mx[0], mx[1],</div>
<div class="line">            -1, method);</div>
<div class="line">    <a class="code hl_struct" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS&lt;dg::aProductGeometry3d, dg::IDMatrix, dg::DMatrix, dg::DVec&gt;</a></div>
<div class="line">        ds( dsFA );</div>
<div class="ttc" id="agroup__circular_html_ga16471692288263e2076b897dae16799f"><div class="ttname"><a href="group__circular.html#ga16471692288263e2076b897dae16799f">dg::geo::createCircularField</a></div><div class="ttdeci">static dg::geo::TokamakMagneticField createCircularField(double R0, double I0)</div><div class="ttdoc">Create a Magnetic field with circular flux surfaces and constant current.</div><div class="ttdef"><b>Definition:</b> toroidal.h:125</div></div>
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3"><div class="ttname"><a href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></div><div class="ttdeci">PER</div></div>
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10"><div class="ttname"><a href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></div><div class="ttdeci">NEU</div></div>
<div class="ttc" id="agroup__magnetic_html_gac7f646da25a618a26e3f6ff9ba3ff09e"><div class="ttname"><a href="group__magnetic.html#gac7f646da25a618a26e3f6ff9ba3ff09e">dg::geo::createBHat</a></div><div class="ttdeci">CylindricalVectorLvl1 createBHat(const TokamakMagneticField &amp;mag)</div><div class="ttdoc">Contravariant components of the magnetic unit vector field and its Divergence and derivative in cylin...</div><div class="ttdef"><b>Definition:</b> magnetic_field.h:931</div></div>
<div class="ttc" id="astructdg_1_1_real_cylindrical_grid3d_html"><div class="ttname"><a href="../../dg/html/structdg_1_1_real_cylindrical_grid3d.html">dg::RealCylindricalGrid3d</a></div></div>
<div class="ttc" id="astructdg_1_1_z_e_r_o_html"><div class="ttname"><a href="../../dg/html/structdg_1_1_z_e_r_o.html">dg::ZERO</a></div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_d_s_html"><div class="ttname"><a href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a></div><div class="ttdoc">Class for the evaluation of parallel derivatives.</div><div class="ttdef"><b>Definition:</b> ds.h:349</div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_fieldaligned_html"><div class="ttname"><a href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a></div><div class="ttdoc">Create and manage interpolation matrices from fieldline integration.</div><div class="ttdef"><b>Definition:</b> fieldaligned.h:376</div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_tokamak_magnetic_field_html"><div class="ttname"><a href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a></div><div class="ttdoc">A tokamak field as given by R0, Psi and Ipol plus Meta-data like shape and equilibrium.</div><div class="ttdef"><b>Definition:</b> magnetic_field.h:162</div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ProductGeometry</td><td>must be either <code><a class="elRef" href="../../dg/html/group__gridtypes.html#gad3d6bea9081a22d2133ce8c42bd5ca46">dg::aProductGeometry3d</a></code> or <code><a class="elRef" href="../../dg/html/group__gridtypes.html#ga4f8e4aa131946e62c3a8b0325956c73e">dg::aProductMPIGeometry3d</a></code> or any derivative </td></tr>
    <tr><td class="paramname">IMatrix</td><td>The type of the interpolation matrix<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#ga3d74638bbcf620f19e3728a07ef1706d">dg::IHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gaec4df2a8ab65260aed0efeb6f5d115e4">dg::IDMatrix</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga6f954391920cbd9b9ec4c7b68fdb7682">dg::MIHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gabed94dc9f33454571b7a124fb3851091">dg::MIDMatrix</a></code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">container</td><td>The container-class on which the interpolation matrix operates on<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0">dg::MHVec</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55">dg::MDVec</a></code> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The pdf <a href="https://www.overleaf.com/read/jjvstccqzcjv" target="_blank">parallel derivative</a> writeup </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab8dbf31402248f22eb8ed54eadf5152a" name="ab8dbf31402248f22eb8ed54eadf5152a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dbf31402248f22eb8ed54eadf5152a">&#9670;&nbsp;</a></span>Fieldaligned() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::Fieldaligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>do not allocate memory; no member call except construct is valid </p>

</div>
</div>
<a id="ab20751293b2f43fc0821a8efbf2e0d2e" name="ab20751293b2f43fc0821a8efbf2e0d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20751293b2f43fc0821a8efbf2e0d2e">&#9670;&nbsp;</a></span>Fieldaligned() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::Fieldaligned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mx</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>my</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>interpolation_method</em> = <code>&quot;dg&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>benchmark</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a magnetic field and a grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">bcx</td><td>This parameter is passed on to <code><a class="elRef" href="../../dg/html/group__interpolation.html#gabccfc4cf8551380841951e9e3d4ea6eb">dg::create::interpolation(const thrust::host_vector&lt;real_type&gt;&amp;,const thrust::host_vector&lt;real_type&gt;&amp;,const aRealTopology2d&lt;real_type&gt;&amp;,dg::bc,dg::bc,std::string)</a></code> (see there for more details) function and deterimens what happens when the endpoint of the fieldline integration leaves the domain boundaries of <code>grid</code>. Note that <code>bcx</code> and <code>grid.bcx()</code> have to be either both periodic or both not periodic. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Note that if <code>grid.bcz()==<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code> this parameter is ignored, Default is a limiter everywhere)</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">mx</td><td>refinement factor in X of the fine grid relative to grid (Set to 1, if the x-component of <code>vec</code> vanishes, else as high as possible, 10 is a good start) </td></tr>
    <tr><td class="paramname">my</td><td>analogous to <code>mx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>The angular distance that the fieldline-integrator will integrate. Per default this is the distance between planes, which is chosen automatically if you set it &lt;=0, i.e. if deltaPhi &lt;=0 then it will be overwritten to deltaPhi = grid.hz(). Sometimes however, you may want to set it to a different value from <code>grid.hz()</code> for example for 2d problems or for a staggered grid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>deltaPhi influences the interpolation matrices and the parallel modulation in the <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a62998cfeca17015be3d094c090a9f295" title="Evaluate a 2d functor and transform to all planes along the fieldline">evaluate()</a> member function. </dd>
<dd>
If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpolation_method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial </td></tr>
    <tr><td class="paramname">benchmark</td><td>If true write construction timings to std::cout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af507ab26311f23b41c47b66d0fa9be70" name="af507ab26311f23b41c47b66d0fa9be70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af507ab26311f23b41c47b66d0fa9be70">&#9670;&nbsp;</a></span>Fieldaligned() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::Fieldaligned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl1.html">dg::geo::CylindricalVectorLvl1</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mx</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>my</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>interpolation_method</em> = <code>&quot;dg&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>benchmark</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a vector field and a grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">bcx</td><td>This parameter is passed on to <code><a class="elRef" href="../../dg/html/group__interpolation.html#gabccfc4cf8551380841951e9e3d4ea6eb">dg::create::interpolation(const thrust::host_vector&lt;real_type&gt;&amp;,const thrust::host_vector&lt;real_type&gt;&amp;,const aRealTopology2d&lt;real_type&gt;&amp;,dg::bc,dg::bc,std::string)</a></code> (see there for more details) function and deterimens what happens when the endpoint of the fieldline integration leaves the domain boundaries of <code>grid</code>. Note that <code>bcx</code> and <code>grid.bcx()</code> have to be either both periodic or both not periodic. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Note that if <code>grid.bcz()==<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code> this parameter is ignored, Default is a limiter everywhere)</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">mx</td><td>refinement factor in X of the fine grid relative to grid (Set to 1, if the x-component of <code>vec</code> vanishes, else as high as possible, 10 is a good start) </td></tr>
    <tr><td class="paramname">my</td><td>analogous to <code>mx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>The angular distance that the fieldline-integrator will integrate. Per default this is the distance between planes, which is chosen automatically if you set it &lt;=0, i.e. if deltaPhi &lt;=0 then it will be overwritten to deltaPhi = grid.hz(). Sometimes however, you may want to set it to a different value from <code>grid.hz()</code> for example for 2d problems or for a staggered grid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>deltaPhi influences the interpolation matrices and the parallel modulation in the <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html#a62998cfeca17015be3d094c090a9f295" title="Evaluate a 2d functor and transform to all planes along the fieldline">evaluate()</a> member function. </dd>
<dd>
If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpolation_method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial </td></tr>
    <tr><td class="paramname">benchmark</td><td>If true write construction timings to std::cout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adddf46de10d03df41e6914c21c7083f0" name="adddf46de10d03df41e6914c21c7083f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddf46de10d03df41e6914c21c7083f0">&#9670;&nbsp;</a></span>bbm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::bbm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask minus, 1 if fieldline intersects wall in minus direction but not in plus direction, 0 else. </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="abfbdec0bfe9bc3584b976d3fa034161f" name="abfbdec0bfe9bc3584b976d3fa034161f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbdec0bfe9bc3584b976d3fa034161f">&#9670;&nbsp;</a></span>bbo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::bbo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask both, 1 if fieldline intersects wall in plus direction and in minus direction, 0 else. </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="a5f3665adaa5b8b3a4a674f78e7ea7a7d" name="a5f3665adaa5b8b3a4a674f78e7ea7a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3665adaa5b8b3a4a674f78e7ea7a7d">&#9670;&nbsp;</a></span>bbp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::bbp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask plus, 1 if fieldline intersects wall in plus direction but not in minus direction, 0 else. </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="a0467cd614bca4ebbe231155453d647cd" name="a0467cd614bca4ebbe231155453d647cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0467cd614bca4ebbe231155453d647cd">&#9670;&nbsp;</a></span>bcx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::bcx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5add7df8d14903c8adff9243a128237" name="aa5add7df8d14903c8adff9243a128237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5add7df8d14903c8adff9243a128237">&#9670;&nbsp;</a></span>bcy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::bcy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2711b5e0ba62960915915b016af5581a" name="a2711b5e0ba62960915915b016af5581a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2711b5e0ba62960915915b016af5581a">&#9670;&nbsp;</a></span>bphi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::bphi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bphi </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="aa4b7f11cedf6d236ca58a85b98c3f90a" name="aa4b7f11cedf6d236ca58a85b98c3f90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b7f11cedf6d236ca58a85b98c3f90a">&#9670;&nbsp;</a></span>bphiM()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::bphiM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bphi on minus plane </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="ae6bfa03ea2797271a10406d242708793" name="ae6bfa03ea2797271a10406d242708793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bfa03ea2797271a10406d242708793">&#9670;&nbsp;</a></span>bphiP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::bphiP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bphi on plus plane </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="ab90913a78a7c6bd680f3ad55f071b58a" name="ab90913a78a7c6bd680f3ad55f071b58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90913a78a7c6bd680f3ad55f071b58a">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaea82cc54bcadb13b9d55ded7f70015a" name="aaea82cc54bcadb13b9d55ded7f70015a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea82cc54bcadb13b9d55ded7f70015a">&#9670;&nbsp;</a></span>deltaPhi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::deltaPhi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62998cfeca17015be3d094c090a9f295" name="a62998cfeca17015be3d094c090a9f295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62998cfeca17015be3d094c090a9f295">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class BinaryOp , class UnaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">container <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>unary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a 2d functor and transform to all planes along the fieldline </p>
<p >The algorithm does the equivalent of the following:</p><ul>
<li>Evaluate the given <code>BinaryOp</code> on a 2d plane</li>
<li>Apply the plus and minus transformation each \( r N_z\) times where \( N_z\) is the number of planes in the global 3d grid and \( r\) is the number of rounds.</li>
<li>Scale the transformations with \( u ( \pm (iN_z + j)\Delta\varphi) \), where <code>u</code> is the given <code>UnarayOp</code>, <code>i</code> in [0..r] is the round index and <code>j</code> in [0. Nz] is the plane index and \(\Delta\varphi\) is the angular distance given in the constructor (can be different from the actual grid distance hz!).</li>
<li>Sum all transformations with the same plane index <code>j</code> , where the minus transformations get the inverted index \( N_z - j\).</li>
<li>Shift the index by \( p_0\)</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>This version of the algorithm is less exact but much faster than <a class="el" href="group__fieldaligned.html#ga973b9db1e92a2deb0187730252082f3b" title="Evaluate a 2d functor and transform to all planes along the fieldlines">dg::geo::fieldaligned_evaluate</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>Binary Functor </td></tr>
    <tr><td class="paramname">UnaryOp</td><td>Unary Functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary</td><td>Functor to evaluate in x-y </td></tr>
    <tr><td class="paramname">unary</td><td>Functor to evaluate in z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>unary</code> is evaluated such that <code>p0</code> corresponds to z=0, p0+1 corresponds to z=hz, p0-1 to z=-hz, ... </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td>The index of the plane to start </td></tr>
    <tr><td class="paramname">rounds</td><td>The number of rounds <code>r</code> to follow a fieldline; can be zero, then the fieldlines are only followed within the current box ( no periodicity) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>It is recommended to use <code>mx&gt;1</code> and <code>my&gt;1</code> when this function is used, else there might occur some unfavourable summation effects due to the repeated use of transformations especially for low perpendicular resolution.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>3d vector </dd></dl>

</div>
</div>
<a id="af44d06d4f39a0aa51184c1a75cb3d899" name="af44d06d4f39a0aa51184c1a75cb3d899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44d06d4f39a0aa51184c1a75cb3d899">&#9670;&nbsp;</a></span>grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ProductGeometry &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::grid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grid used for construction. </p>

</div>
</div>
<a id="a892fc4ea2ea56bca5dee3537a1ed42a7" name="a892fc4ea2ea56bca5dee3537a1ed42a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892fc4ea2ea56bca5dee3537a1ed42a7">&#9670;&nbsp;</a></span>hbm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::hbm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="elRef" href="../../dg/html/structdg_1_1_distance.html">Distance</a> between the planes and the boundary \( (s_{k}-s_{b}^-) \). </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="a0f7a7092df5e25d414337216588a73de" name="a0f7a7092df5e25d414337216588a73de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7a7092df5e25d414337216588a73de">&#9670;&nbsp;</a></span>hbp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::hbp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="elRef" href="../../dg/html/structdg_1_1_distance.html">Distance</a> between the planes \( (s_b^+-s_{k}) \). </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="a4d031e50eb1b9f152e658378e04bf401" name="a4d031e50eb1b9f152e658378e04bf401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d031e50eb1b9f152e658378e04bf401">&#9670;&nbsp;</a></span>integrate_between_coarse_grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::integrate_between_coarse_grid </td>
          <td>(</td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate a 2d function on the fine grid. </p>
<p class="formulaDsp">
\[ \frac{1}{\Delta\varphi} \int_{-\Delta\varphi}^{\Delta\varphi}d \varphi w(\varphi) f(R(\varphi), Z(\varphi) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_coarse</td><td>The coarse grid (<code>coarse_grid.Nz()</code> must integer divide <code>Nz</code> from input grid). The x and y dimensions must be equal to the input grid. </td></tr>
    <tr><td class="paramname">coarse</td><td>the 2d input vector </td></tr>
    <tr><td class="paramname">out</td><td>the integral (2d vector) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41494a71690b278c03c5c55f9fe8ece9" name="a41494a71690b278c03c5c55f9fe8ece9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41494a71690b278c03c5c55f9fe8ece9">&#9670;&nbsp;</a></span>interpolate_from_coarse_grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">container <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::interpolate_from_coarse_grid </td>
          <td>(</td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>coarse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate along fieldlines from a coarse to a fine grid in phi. </p>
<p >In this function we assume that the <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object lives on the fine grid and we now want to interpolate values from a vector living on a coarse grid along the fieldlines onto the fine grid. Here, coarse and fine are with respect to the phi direction. The perpendicular directions need to have the same resolution in both input and output, i.e. there is no interpolation in those directions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_coarse</td><td>The coarse grid (<code>coarse_grid.Nz()</code> must integer divide <code>Nz</code> from input grid) The x and y dimensions must be equal </td></tr>
    <tr><td class="paramname">coarse</td><td>the coarse input vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input interpolated onto the grid given in the constructor </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the interpolation weights are taken in the phi distance not the s-distance, which makes the interpolation linear in phi </dd></dl>

</div>
</div>
<a id="a6ea42e6ede96ce97bc9d7abcceb2c48f" name="a6ea42e6ede96ce97bc9d7abcceb2c48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea42e6ede96ce97bc9d7abcceb2c48f">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__fieldaligned.html#ga10e4ac4f15fe73a4ff10569985224101">whichMatrix</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the interpolation to three-dimensional vectors. </p>
<p >computes \( y = 1^\pm \otimes \mathcal T x\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specify what interpolation should be applied </td></tr>
    <tr><td class="paramname">in</td><td>input </td></tr>
    <tr><td class="paramname">out</td><td>output may not equal input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9caf11ed3c059894ec530a24c2233d17" name="a9caf11ed3c059894ec530a24c2233d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9caf11ed3c059894ec530a24c2233d17">&#9670;&nbsp;</a></span>set_boundaries() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p >if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">global</td><td>3D vector containing boundary values </td></tr>
    <tr><td class="paramname">scal_left</td><td>left scaling factor </td></tr>
    <tr><td class="paramname">scal_right</td><td>right scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdbbe5f97222f049d0526ef6d6ff3279" name="afdbbe5f97222f049d0526ef6d6ff3279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbbe5f97222f049d0526ef6d6ff3279">&#9670;&nbsp;</a></span>set_boundaries() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p >if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>spatially variable left boundary value (2d size) </td></tr>
    <tr><td class="paramname">right</td><td>spatially variable right boundary value (2d size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75b8f74725ee49e103d4d9eb9f23bafa" name="a75b8f74725ee49e103d4d9eb9f23bafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b8f74725ee49e103d4d9eb9f23bafa">&#9670;&nbsp;</a></span>set_boundaries() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p >if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>constant left boundary value </td></tr>
    <tr><td class="paramname">right</td><td>constant right boundary value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65433ae8e8bda1e1651a9e3c5d47ece0" name="a65433ae8e8bda1e1651a9e3c5d47ece0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65433ae8e8bda1e1651a9e3c5d47ece0">&#9670;&nbsp;</a></span>sqrtG()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::sqrtG </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volume form (including weights) \( \sqrt{G}_{k} \). </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="a71673fd97b743d39945b227cbce595b0" name="a71673fd97b743d39945b227cbce595b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71673fd97b743d39945b227cbce595b0">&#9670;&nbsp;</a></span>sqrtGm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::sqrtGm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volume form on minus plane (including weights) \( \sqrt{G}_{k-1} \). </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<a id="ae1a928fd89bcde1864f78dc1a093d59f" name="ae1a928fd89bcde1864f78dc1a093d59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a928fd89bcde1864f78dc1a093d59f">&#9670;&nbsp;</a></span>sqrtGp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;::sqrtGp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volume form on plus plane (including weights) \( \sqrt{G}_{k+1} \). </p>
<dl class="section return"><dt>Returns</dt><dd>three-dimensional vector </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="fieldaligned_8h_source.html">fieldaligned.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="namespacedg_1_1geo.html">geo</a></li><li class="navelem"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">Fieldaligned</a></li>
    <li class="footer">Generated on Fri Jan 28 2022 17:46:33 for Extension: Geometries by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
