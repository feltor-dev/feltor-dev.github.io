<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extension: Geometries: dg::geo::DS&lt; ProductGeometry, IMatrix, Matrix, container &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extension: Geometries
   </div>
   <div id="projectbrief">#include &quot;dg/geometries/geometries.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structdg_1_1geo_1_1_d_s.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1geo_1_1_d_s-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::geo::DS&lt; ProductGeometry, IMatrix, Matrix, container &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__fieldaligned.html">4. Fieldaligned derivatives</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Class for the evaluation of parallel derivatives.  
 <a href="structdg_1_1geo_1_1_d_s.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac83f7ebb7593a8739c9ea0585cd7d0de"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a></td></tr>
<tr class="separator:ac83f7ebb7593a8739c9ea0585cd7d0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea274cabb48d6b0b2808951fcd845e99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#aea274cabb48d6b0b2808951fcd845e99">DS</a> ()</td></tr>
<tr class="memdesc:aea274cabb48d6b0b2808951fcd845e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">No memory allocation; all member calls except construct are invalid.  <a href="structdg_1_1geo_1_1_d_s.html#aea274cabb48d6b0b2808951fcd845e99">More...</a><br /></td></tr>
<tr class="separator:aea274cabb48d6b0b2808951fcd845e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00c107ed4443bf45d3b3cc8b4ce17a6"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:ae00c107ed4443bf45d3b3cc8b4ce17a6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ae00c107ed4443bf45d3b3cc8b4ce17a6">DS</a> (const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;vec, const ProductGeometry &amp;grid, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), double eps=1e-5, unsigned mx=10, unsigned my=10, double deltaPhi=-1, std::string interpolation_method=&quot;dg&quot;, bool benchmark=true)</td></tr>
<tr class="memdesc:ae00c107ed4443bf45d3b3cc8b4ce17a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the magnetic unit vector field and construct.  <a href="structdg_1_1geo_1_1_d_s.html#ae00c107ed4443bf45d3b3cc8b4ce17a6">More...</a><br /></td></tr>
<tr class="separator:ae00c107ed4443bf45d3b3cc8b4ce17a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a733ea78279e2967933004994b7155"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:a86a733ea78279e2967933004994b7155"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a86a733ea78279e2967933004994b7155">DS</a> (const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl1.html">dg::geo::CylindricalVectorLvl1</a> &amp;vec, const ProductGeometry &amp;grid, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), double eps=1e-5, unsigned mx=10, unsigned my=10, double deltaPhi=-1, std::string interpolation_method=&quot;dg&quot;, bool benchmark=true)</td></tr>
<tr class="memdesc:a86a733ea78279e2967933004994b7155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the given vector field to construct.  <a href="structdg_1_1geo_1_1_d_s.html#a86a733ea78279e2967933004994b7155">More...</a><br /></td></tr>
<tr class="separator:a86a733ea78279e2967933004994b7155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c538d2a53b86c401c3cb1f40819e1f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a3c538d2a53b86c401c3cb1f40819e1f9">DS</a> (<a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> <a class="el" href="structdg_1_1geo_1_1_d_s.html#a62c34ffb67ec8f2f20b60a75109b110a">fieldaligned</a>)</td></tr>
<tr class="memdesc:a3c538d2a53b86c401c3cb1f40819e1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> object.  <a href="structdg_1_1geo_1_1_d_s.html#a3c538d2a53b86c401c3cb1f40819e1f9">More...</a><br /></td></tr>
<tr class="separator:a3c538d2a53b86c401c3cb1f40819e1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0dac9a94313bf6d006c1e398d1e56c"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:aff0dac9a94313bf6d006c1e398d1e56c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#aff0dac9a94313bf6d006c1e398d1e56c">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:aff0dac9a94313bf6d006c1e398d1e56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.  <a href="structdg_1_1geo_1_1_d_s.html#aff0dac9a94313bf6d006c1e398d1e56c">More...</a><br /></td></tr>
<tr class="separator:aff0dac9a94313bf6d006c1e398d1e56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100b598ea427067b6e24885965e2a118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a100b598ea427067b6e24885965e2a118">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, double left, double right)</td></tr>
<tr class="memdesc:a100b598ea427067b6e24885965e2a118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="structdg_1_1geo_1_1_d_s.html#a100b598ea427067b6e24885965e2a118">More...</a><br /></td></tr>
<tr class="separator:a100b598ea427067b6e24885965e2a118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0897218b8eeb3bfdc70a1e2e3e912d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0897218b8eeb3bfdc70a1e2e3e912d76">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;left, const container &amp;right)</td></tr>
<tr class="memdesc:a0897218b8eeb3bfdc70a1e2e3e912d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="structdg_1_1geo_1_1_d_s.html#a0897218b8eeb3bfdc70a1e2e3e912d76">More...</a><br /></td></tr>
<tr class="separator:a0897218b8eeb3bfdc70a1e2e3e912d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f14efeac450de2c7d109e20e1f1382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a02f14efeac450de2c7d109e20e1f1382">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;global, double scal_left, double scal_right)</td></tr>
<tr class="memdesc:a02f14efeac450de2c7d109e20e1f1382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="structdg_1_1geo_1_1_d_s.html#a02f14efeac450de2c7d109e20e1f1382">More...</a><br /></td></tr>
<tr class="separator:a02f14efeac450de2c7d109e20e1f1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181d80e0ee9c46b0f17f4737b01c7347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347">forward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a181d80e0ee9c46b0f17f4737b01c7347"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347">More...</a><br /></td></tr>
<tr class="separator:a181d80e0ee9c46b0f17f4737b01c7347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907c91fbf7f59dd085d55c3e0dca7e6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a907c91fbf7f59dd085d55c3e0dca7e6b">forward2</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a907c91fbf7f59dd085d55c3e0dca7e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2nd order forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#a907c91fbf7f59dd085d55c3e0dca7e6b">More...</a><br /></td></tr>
<tr class="separator:a907c91fbf7f59dd085d55c3e0dca7e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515d0bfa7ff3e56ddd7073f94e00d821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821">backward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a515d0bfa7ff3e56ddd7073f94e00d821"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821">More...</a><br /></td></tr>
<tr class="separator:a515d0bfa7ff3e56ddd7073f94e00d821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03b2ab5e4d2c4a52583906f137bf39f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ad03b2ab5e4d2c4a52583906f137bf39f">backward2</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ad03b2ab5e4d2c4a52583906f137bf39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">2nd order backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#ad03b2ab5e4d2c4a52583906f137bf39f">More...</a><br /></td></tr>
<tr class="separator:ad03b2ab5e4d2c4a52583906f137bf39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb890f75e68957fdbc0f30953438e431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431">centered</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:acb890f75e68957fdbc0f30953438e431"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431">More...</a><br /></td></tr>
<tr class="separator:acb890f75e68957fdbc0f30953438e431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234ed5a5981b91f40472151824dc4985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a234ed5a5981b91f40472151824dc4985">centered_bc_along_field</a> (double alpha, const container &amp;f, double beta, container &amp;g, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bound, std::array&lt; double, 2 &gt; boundary_value={0, 0})</td></tr>
<tr class="memdesc:a234ed5a5981b91f40472151824dc4985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code><a class="el" href="group__fieldaligned.html#ga70d98ba526a42601f26374d4aacddec5" title="centered derivative">dg::geo::ds_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>.  <a href="structdg_1_1geo_1_1_d_s.html#a234ed5a5981b91f40472151824dc4985">More...</a><br /></td></tr>
<tr class="separator:a234ed5a5981b91f40472151824dc4985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec3cea560d6cbbafd6a229deeef6036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0ec3cea560d6cbbafd6a229deeef6036">backward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a0ec3cea560d6cbbafd6a229deeef6036"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \vec v \cdot \nabla f \)  <a href="structdg_1_1geo_1_1_d_s.html#a0ec3cea560d6cbbafd6a229deeef6036">More...</a><br /></td></tr>
<tr class="separator:a0ec3cea560d6cbbafd6a229deeef6036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae763e441ade3578a617e9df6aa97244b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ae763e441ade3578a617e9df6aa97244b">forward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ae763e441ade3578a617e9df6aa97244b"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \vec v \cdot \nabla f \)  <a href="structdg_1_1geo_1_1_d_s.html#ae763e441ade3578a617e9df6aa97244b">More...</a><br /></td></tr>
<tr class="separator:ae763e441ade3578a617e9df6aa97244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd64e4aa948e9f6ff13a1f5970ddb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ab9dd64e4aa948e9f6ff13a1f5970ddb4">centered</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ab9dd64e4aa948e9f6ff13a1f5970ddb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \vec v \cdot \nabla f \)  <a href="structdg_1_1geo_1_1_d_s.html#ab9dd64e4aa948e9f6ff13a1f5970ddb4">More...</a><br /></td></tr>
<tr class="separator:ab9dd64e4aa948e9f6ff13a1f5970ddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f5b90b635b69bb0c5eacde3e3647a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a76f5b90b635b69bb0c5eacde3e3647a7">divForward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a76f5b90b635b69bb0c5eacde3e3647a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#a76f5b90b635b69bb0c5eacde3e3647a7">More...</a><br /></td></tr>
<tr class="separator:a76f5b90b635b69bb0c5eacde3e3647a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af397aba8d43c37b88e1d85272d662d4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#af397aba8d43c37b88e1d85272d662d4d">divBackward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:af397aba8d43c37b88e1d85272d662d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#af397aba8d43c37b88e1d85272d662d4d">More...</a><br /></td></tr>
<tr class="separator:af397aba8d43c37b88e1d85272d662d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d5b30389cb32f6b624de430483ea54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a64d5b30389cb32f6b624de430483ea54">divCentered</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a64d5b30389cb32f6b624de430483ea54"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#a64d5b30389cb32f6b624de430483ea54">More...</a><br /></td></tr>
<tr class="separator:a64d5b30389cb32f6b624de430483ea54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa2b1fe16de8ec27c88ab6522367352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a6fa2b1fe16de8ec27c88ab6522367352">divForward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a6fa2b1fe16de8ec27c88ab6522367352"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward divergence \( g = \nabla\cdot(\vec v f)\)  <a href="structdg_1_1geo_1_1_d_s.html#a6fa2b1fe16de8ec27c88ab6522367352">More...</a><br /></td></tr>
<tr class="separator:a6fa2b1fe16de8ec27c88ab6522367352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a489bdafca25538c65ceba000a1fef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a2a489bdafca25538c65ceba000a1fef8">divBackward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a2a489bdafca25538c65ceba000a1fef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward divergence \( g = \nabla\cdot(\vec v f)\)  <a href="structdg_1_1geo_1_1_d_s.html#a2a489bdafca25538c65ceba000a1fef8">More...</a><br /></td></tr>
<tr class="separator:a2a489bdafca25538c65ceba000a1fef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad464d8ddfe153648575abf6e6ca0d91d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ad464d8ddfe153648575abf6e6ca0d91d">divCentered</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ad464d8ddfe153648575abf6e6ca0d91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered divergence \( g = \nabla\cdot(\vec v f)\)  <a href="structdg_1_1geo_1_1_d_s.html#ad464d8ddfe153648575abf6e6ca0d91d">More...</a><br /></td></tr>
<tr class="separator:ad464d8ddfe153648575abf6e6ca0d91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a97e094e84673f71297df22a9bba4c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0a97e094e84673f71297df22a9bba4c5">ds</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a0a97e094e84673f71297df22a9bba4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \vec v\cdot \nabla f \).  <a href="structdg_1_1geo_1_1_d_s.html#a0a97e094e84673f71297df22a9bba4c5">More...</a><br /></td></tr>
<tr class="separator:a0a97e094e84673f71297df22a9bba4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de32d878848eebdea7aee2d41b87a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a3de32d878848eebdea7aee2d41b87a27">ds</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a3de32d878848eebdea7aee2d41b87a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \).  <a href="structdg_1_1geo_1_1_d_s.html#a3de32d878848eebdea7aee2d41b87a27">More...</a><br /></td></tr>
<tr class="separator:a3de32d878848eebdea7aee2d41b87a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397b9c50490e4c721c488c3568e6a5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a397b9c50490e4c721c488c3568e6a5c2">div</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a397b9c50490e4c721c488c3568e6a5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \nabla \cdot ( \vec v f) \).  <a href="structdg_1_1geo_1_1_d_s.html#a397b9c50490e4c721c488c3568e6a5c2">More...</a><br /></td></tr>
<tr class="separator:a397b9c50490e4c721c488c3568e6a5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b4f28a8012eb265343f2fecb88a2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac5b4f28a8012eb265343f2fecb88a2f4">div</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ac5b4f28a8012eb265343f2fecb88a2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \nabla \cdot( \vec v f) + \beta g \).  <a href="structdg_1_1geo_1_1_d_s.html#ac5b4f28a8012eb265343f2fecb88a2f4">More...</a><br /></td></tr>
<tr class="separator:ac5b4f28a8012eb265343f2fecb88a2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd682b8f6e2d7b6eab4853ed5a55310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a7cd682b8f6e2d7b6eab4853ed5a55310">symv</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a7cd682b8f6e2d7b6eab4853ed5a55310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \nabla\cdot ( \vec v \vec v \cdot \nabla f )\).  <a href="structdg_1_1geo_1_1_d_s.html#a7cd682b8f6e2d7b6eab4853ed5a55310">More...</a><br /></td></tr>
<tr class="separator:a7cd682b8f6e2d7b6eab4853ed5a55310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b31544057e833d0efbb6c79ca853e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb6b31544057e833d0efbb6c79ca853e">symv</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:acb6b31544057e833d0efbb6c79ca853e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \nabla\cdot ( \vec v \vec v \cdot \nabla f ) + \beta g\) as a symmetric matrix.  <a href="structdg_1_1geo_1_1_d_s.html#acb6b31544057e833d0efbb6c79ca853e">More...</a><br /></td></tr>
<tr class="separator:acb6b31544057e833d0efbb6c79ca853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2adaf51aa28f332bb738d7c7a5fa149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac2adaf51aa28f332bb738d7c7a5fa149">dss</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ac2adaf51aa28f332bb738d7c7a5fa149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = (\vec v\cdot \nabla)^2 f \).  <a href="structdg_1_1geo_1_1_d_s.html#ac2adaf51aa28f332bb738d7c7a5fa149">More...</a><br /></td></tr>
<tr class="separator:ac2adaf51aa28f332bb738d7c7a5fa149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a968a4d343037e248a2f7458e15e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a37a968a4d343037e248a2f7458e15e4c">dss</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a37a968a4d343037e248a2f7458e15e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \).  <a href="structdg_1_1geo_1_1_d_s.html#a37a968a4d343037e248a2f7458e15e4c">More...</a><br /></td></tr>
<tr class="separator:a37a968a4d343037e248a2f7458e15e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c0a604127403aefdbe3fffc17a91fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a27c0a604127403aefdbe3fffc17a91fc">dss_bc_along_field</a> (double alpha, const container &amp;f, double beta, container &amp;g, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bound, std::array&lt; double, 2 &gt; boundary_value={0, 0})</td></tr>
<tr class="memdesc:a27c0a604127403aefdbe3fffc17a91fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code><a class="el" href="group__fieldaligned.html#ga9d0308bf8d169f14efc488419bfa33b6" title="Centered derivative .">dg::geo::dss_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>.  <a href="structdg_1_1geo_1_1_d_s.html#a27c0a604127403aefdbe3fffc17a91fc">More...</a><br /></td></tr>
<tr class="separator:a27c0a604127403aefdbe3fffc17a91fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0284d45e7af4e824d387880fb537c371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0284d45e7af4e824d387880fb537c371">dssd</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a0284d45e7af4e824d387880fb537c371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code>.  <a href="structdg_1_1geo_1_1_d_s.html#a0284d45e7af4e824d387880fb537c371">More...</a><br /></td></tr>
<tr class="separator:a0284d45e7af4e824d387880fb537c371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3258a65655f65af0dc81d828a5949a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a3258a65655f65af0dc81d828a5949a79">dssd_bc_along_field</a> (double alpha, const container &amp;f, double beta, container &amp;g, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bound, std::array&lt; double, 2 &gt; boundary_value={0, 0})</td></tr>
<tr class="memdesc:a3258a65655f65af0dc81d828a5949a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>.  <a href="structdg_1_1geo_1_1_d_s.html#a3258a65655f65af0dc81d828a5949a79">More...</a><br /></td></tr>
<tr class="separator:a3258a65655f65af0dc81d828a5949a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae470c3af9246e55e9becedffba7856e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ae470c3af9246e55e9becedffba7856e0">set_jfactor</a> (double new_jfactor)</td></tr>
<tr class="memdesc:ae470c3af9246e55e9becedffba7856e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the currently used jfactor ( \( \alpha \))  <a href="structdg_1_1geo_1_1_d_s.html#ae470c3af9246e55e9becedffba7856e0">More...</a><br /></td></tr>
<tr class="separator:ae470c3af9246e55e9becedffba7856e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219af8b39bb8dbbdc0d3f7ff11fc2235"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a219af8b39bb8dbbdc0d3f7ff11fc2235">get_jfactor</a> () const</td></tr>
<tr class="memdesc:a219af8b39bb8dbbdc0d3f7ff11fc2235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently used jfactor ( \( \alpha \))  <a href="structdg_1_1geo_1_1_d_s.html#a219af8b39bb8dbbdc0d3f7ff11fc2235">More...</a><br /></td></tr>
<tr class="separator:a219af8b39bb8dbbdc0d3f7ff11fc2235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdfadabfec3035166f405de30b0a9ba"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#aecdfadabfec3035166f405de30b0a9ba">weights</a> () const</td></tr>
<tr class="memdesc:aecdfadabfec3035166f405de30b0a9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The volume form with dG weights.  <a href="structdg_1_1geo_1_1_d_s.html#aecdfadabfec3035166f405de30b0a9ba">More...</a><br /></td></tr>
<tr class="separator:aecdfadabfec3035166f405de30b0a9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c34ffb67ec8f2f20b60a75109b110a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a62c34ffb67ec8f2f20b60a75109b110a">fieldaligned</a> ()</td></tr>
<tr class="memdesc:a62c34ffb67ec8f2f20b60a75109b110a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the underlying <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object  <a href="structdg_1_1geo_1_1_d_s.html#a62c34ffb67ec8f2f20b60a75109b110a">More...</a><br /></td></tr>
<tr class="separator:a62c34ffb67ec8f2f20b60a75109b110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883a5e61aac8a24d3b0c50ff30a75b70"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a883a5e61aac8a24d3b0c50ff30a75b70">fieldaligned</a> () const</td></tr>
<tr class="separator:a883a5e61aac8a24d3b0c50ff30a75b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt;<br />
struct dg::geo::DS&lt; ProductGeometry, IMatrix, Matrix, container &gt;</div><p >Class for the evaluation of parallel derivatives. </p>
<p >This class discretizes the operators \( \nabla_\parallel = \vec{v}\cdot \nabla = v^\zeta\partial_\zeta + v^\eta\partial_\eta + v^\varphi\partial_\varphi \), \(\nabla_\parallel^\dagger = -\nabla\cdot(\vec v .)\) and \(\Delta_\parallel=-\nabla_\parallel^\dagger\cdot\nabla_\parallel\) in arbitrary coordinates </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code hl_structRef" href="../../dg/html/structdg_1_1_real_cylindrical_grid3d.html">dg::CylindricalGrid3d</a> g3d( R_0-a, R_0+a, -a, a, 0, 2.*M_PI, n, Nx, Ny, Nz, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>);</div>
<div class="line">    <span class="comment">//create magnetic field</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> mag = <a class="code hl_function" href="group__circular.html#ga16471692288263e2076b897dae16799f">dg::geo::createCircularField</a>( R_0, I_0);</div>
<div class="line">    <span class="keyword">auto</span> bhat = <a class="code hl_function" href="group__magnetic.html#gac7f646da25a618a26e3f6ff9ba3ff09e">dg::geo::createBHat</a>(mag);</div>
<div class="line">    <span class="comment">//create Fieldaligned object and construct DS from it</span></div>
<div class="line">    <a class="code hl_struct" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned&lt;dg::aProductGeometry3d,dg::IDMatrix,dg::DVec&gt;</a>  dsFA(</div>
<div class="line">            bhat, g3d, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_structRef" href="../../dg/html/structdg_1_1_z_e_r_o.html">dg::geo::NoLimiter</a>(), 1e-8, mx[0], mx[1],</div>
<div class="line">            -1, method);</div>
<div class="line">    <a class="code hl_struct" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS&lt;dg::aProductGeometry3d, dg::IDMatrix, dg::DMatrix, dg::DVec&gt;</a></div>
<div class="line">        <a class="code hl_function" href="structdg_1_1geo_1_1_d_s.html#a0a97e094e84673f71297df22a9bba4c5">ds</a>( dsFA );</div>
<div class="ttc" id="agroup__circular_html_ga16471692288263e2076b897dae16799f"><div class="ttname"><a href="group__circular.html#ga16471692288263e2076b897dae16799f">dg::geo::createCircularField</a></div><div class="ttdeci">static dg::geo::TokamakMagneticField createCircularField(double R0, double I0)</div><div class="ttdoc">Create a Magnetic field with circular flux surfaces and constant current.</div><div class="ttdef"><b>Definition:</b> toroidal.h:125</div></div>
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3"><div class="ttname"><a href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></div><div class="ttdeci">PER</div></div>
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10"><div class="ttname"><a href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></div><div class="ttdeci">NEU</div></div>
<div class="ttc" id="agroup__magnetic_html_gac7f646da25a618a26e3f6ff9ba3ff09e"><div class="ttname"><a href="group__magnetic.html#gac7f646da25a618a26e3f6ff9ba3ff09e">dg::geo::createBHat</a></div><div class="ttdeci">CylindricalVectorLvl1 createBHat(const TokamakMagneticField &amp;mag)</div><div class="ttdoc">Contravariant components of the magnetic unit vector field and its Divergence and derivative in cylin...</div><div class="ttdef"><b>Definition:</b> magnetic_field.h:931</div></div>
<div class="ttc" id="astructdg_1_1_real_cylindrical_grid3d_html"><div class="ttname"><a href="../../dg/html/structdg_1_1_real_cylindrical_grid3d.html">dg::RealCylindricalGrid3d</a></div></div>
<div class="ttc" id="astructdg_1_1_z_e_r_o_html"><div class="ttname"><a href="../../dg/html/structdg_1_1_z_e_r_o.html">dg::ZERO</a></div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_d_s_html"><div class="ttname"><a href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a></div><div class="ttdoc">Class for the evaluation of parallel derivatives.</div><div class="ttdef"><b>Definition:</b> ds.h:349</div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_d_s_html_a0a97e094e84673f71297df22a9bba4c5"><div class="ttname"><a href="structdg_1_1geo_1_1_d_s.html#a0a97e094e84673f71297df22a9bba4c5">dg::geo::DS::ds</a></div><div class="ttdeci">void ds(dg::direction dir, const container &amp;f, container &amp;g)</div><div class="ttdoc">Discretizes .</div><div class="ttdef"><b>Definition:</b> ds.h:568</div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_fieldaligned_html"><div class="ttname"><a href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a></div><div class="ttdoc">Create and manage interpolation matrices from fieldline integration.</div><div class="ttdef"><b>Definition:</b> fieldaligned.h:376</div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_tokamak_magnetic_field_html"><div class="ttname"><a href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a></div><div class="ttdoc">A tokamak field as given by R0, Psi and Ipol plus Meta-data like shape and equilibrium.</div><div class="ttdef"><b>Definition:</b> magnetic_field.h:162</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The parallel Laplacian cannot be inverted as long as there are closed fieldlines somewhere in the domain (which is virtually always true). There is therefore no norm parameter in the class. </dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ProductGeometry</td><td>must be either <code><a class="elRef" href="../../dg/html/group__gridtypes.html#gad3d6bea9081a22d2133ce8c42bd5ca46">dg::aProductGeometry3d</a></code> or <code><a class="elRef" href="../../dg/html/group__gridtypes.html#ga4f8e4aa131946e62c3a8b0325956c73e">dg::aProductMPIGeometry3d</a></code> or any derivative </td></tr>
    <tr><td class="paramname">IMatrix</td><td>The type of the interpolation matrix<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#ga3d74638bbcf620f19e3728a07ef1706d">dg::IHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gaec4df2a8ab65260aed0efeb6f5d115e4">dg::IDMatrix</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga6f954391920cbd9b9ec4c7b68fdb7682">dg::MIHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gabed94dc9f33454571b7a124fb3851091">dg::MIDMatrix</a></code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">Matrix</td><td>The matrix class of the jump matrix<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#gac2134505608b45616787fdb2f6eedc87">dg::HMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16">dg::DMatrix</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161">dg::MHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005">dg::MDMatrix</a></code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">container</td><td>The container-class on which the interpolation matrix operates on<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0">dg::MHVec</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55">dg::MDVec</a></code> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The pdf <a href="https://www.overleaf.com/read/jjvstccqzcjv" target="_blank">parallel derivative</a> writeup </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac83f7ebb7593a8739c9ea0585cd7d0de" name="ac83f7ebb7593a8739c9ea0585cd7d0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83f7ebb7593a8739c9ea0585cd7d0de">&#9670;&nbsp;</a></span>FA</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt;ProductGeometry, IMatrix, container&gt; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::FA</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >conveniently abbreviates underlying <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea274cabb48d6b0b2808951fcd845e99" name="aea274cabb48d6b0b2808951fcd845e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea274cabb48d6b0b2808951fcd845e99">&#9670;&nbsp;</a></span>DS() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::DS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No memory allocation; all member calls except construct are invalid. </p>

</div>
</div>
<a id="ae00c107ed4443bf45d3b3cc8b4ce17a6" name="ae00c107ed4443bf45d3b3cc8b4ce17a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00c107ed4443bf45d3b3cc8b4ce17a6">&#9670;&nbsp;</a></span>DS() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::DS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mx</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>my</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>interpolation_method</em> = <code>&quot;dg&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>benchmark</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the magnetic unit vector field and construct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">bcx</td><td>This parameter is passed on to <code><a class="elRef" href="../../dg/html/group__interpolation.html#gabccfc4cf8551380841951e9e3d4ea6eb">dg::create::interpolation(const thrust::host_vector&lt;real_type&gt;&amp;,const thrust::host_vector&lt;real_type&gt;&amp;,const aRealTopology2d&lt;real_type&gt;&amp;,dg::bc,dg::bc,std::string)</a></code> (see there for more details) function and deterimens what happens when the endpoint of the fieldline integration leaves the domain boundaries of <code>grid</code>. Note that <code>bcx</code> and <code>grid.bcx()</code> have to be either both periodic or both not periodic. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Note that if <code>grid.bcz()==<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code> this parameter is ignored, Default is a limiter everywhere)</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">mx</td><td>refinement factor in X of the fine grid relative to grid (Set to 1, if the x-component of <code>vec</code> vanishes, else as high as possible, 10 is a good start) </td></tr>
    <tr><td class="paramname">my</td><td>analogous to <code>mx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>The angular distance that the fieldline-integrator will integrate. Per default this is the distance between planes, which is chosen automatically if you set it &lt;=0, i.e. if deltaPhi &lt;=0 then it will be overwritten to deltaPhi = grid.hz(). Sometimes however, you may want to set it to a different value from <code>grid.hz()</code> for example for 2d problems or for a staggered grid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>deltaPhi influences the interpolation matrices and the parallel modulation in the <a class="elRef" href="../../dg/html/group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">evaluate()</a> member function. </dd>
<dd>
If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpolation_method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial </td></tr>
    <tr><td class="paramname">benchmark</td><td>If true write construction timings to std::cout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> </dd></dl>

</div>
</div>
<a id="a86a733ea78279e2967933004994b7155" name="a86a733ea78279e2967933004994b7155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a733ea78279e2967933004994b7155">&#9670;&nbsp;</a></span>DS() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::DS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl1.html">dg::geo::CylindricalVectorLvl1</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mx</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>my</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>interpolation_method</em> = <code>&quot;dg&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>benchmark</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the given vector field to construct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">bcx</td><td>This parameter is passed on to <code><a class="elRef" href="../../dg/html/group__interpolation.html#gabccfc4cf8551380841951e9e3d4ea6eb">dg::create::interpolation(const thrust::host_vector&lt;real_type&gt;&amp;,const thrust::host_vector&lt;real_type&gt;&amp;,const aRealTopology2d&lt;real_type&gt;&amp;,dg::bc,dg::bc,std::string)</a></code> (see there for more details) function and deterimens what happens when the endpoint of the fieldline integration leaves the domain boundaries of <code>grid</code>. Note that <code>bcx</code> and <code>grid.bcx()</code> have to be either both periodic or both not periodic. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Note that if <code>grid.bcz()==<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code> this parameter is ignored, Default is a limiter everywhere)</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">mx</td><td>refinement factor in X of the fine grid relative to grid (Set to 1, if the x-component of <code>vec</code> vanishes, else as high as possible, 10 is a good start) </td></tr>
    <tr><td class="paramname">my</td><td>analogous to <code>mx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>The angular distance that the fieldline-integrator will integrate. Per default this is the distance between planes, which is chosen automatically if you set it &lt;=0, i.e. if deltaPhi &lt;=0 then it will be overwritten to deltaPhi = grid.hz(). Sometimes however, you may want to set it to a different value from <code>grid.hz()</code> for example for 2d problems or for a staggered grid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>deltaPhi influences the interpolation matrices and the parallel modulation in the <a class="elRef" href="../../dg/html/group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">evaluate()</a> member function. </dd>
<dd>
If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpolation_method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial </td></tr>
    <tr><td class="paramname">benchmark</td><td>If true write construction timings to std::cout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> </dd></dl>

</div>
</div>
<a id="a3c538d2a53b86c401c3cb1f40819e1f9" name="a3c538d2a53b86c401c3cb1f40819e1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c538d2a53b86c401c3cb1f40819e1f9">&#9670;&nbsp;</a></span>DS() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::DS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a>&#160;</td>
          <td class="paramname"><em>fieldaligned</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldaligned</td><td>this object will be used in all further member calls </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0ec3cea560d6cbbafd6a229deeef6036" name="a0ec3cea560d6cbbafd6a229deeef6036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec3cea560d6cbbafd6a229deeef6036">&#9670;&nbsp;</a></span>backward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::backward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward derivative \( g = \vec v \cdot \nabla f \) </p>
<p >backward derivative \( g_i = \frac{v^\varphi}{\Delta\varphi}(f_{i} - f_{i-1}) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a515d0bfa7ff3e56ddd7073f94e00d821" name="a515d0bfa7ff3e56ddd7073f94e00d821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515d0bfa7ff3e56ddd7073f94e00d821">&#9670;&nbsp;</a></span>backward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::backward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p >backward derivative \( g_i = \alpha \frac{1}{h_z^-}(f_{i} - f_{i-1}) + \beta g_i \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="ad03b2ab5e4d2c4a52583906f137bf39f" name="ad03b2ab5e4d2c4a52583906f137bf39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03b2ab5e4d2c4a52583906f137bf39f">&#9670;&nbsp;</a></span>backward2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::backward2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2nd order backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p >backward derivative \( g_i = \alpha \frac{1}{2h_z^-}(3f_{i} - 4f_{i-1} + f_{i-2}) + \beta g_i \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="ab9dd64e4aa948e9f6ff13a1f5970ddb4" name="ab9dd64e4aa948e9f6ff13a1f5970ddb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dd64e4aa948e9f6ff13a1f5970ddb4">&#9670;&nbsp;</a></span>centered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::centered </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered derivative \( g = \vec v \cdot \nabla f \) </p>
<p >centered derivative \( g_i = \frac{v^\varphi}{2\Delta\varphi}(f_{i+1} - f_{i-1})\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="acb890f75e68957fdbc0f30953438e431" name="acb890f75e68957fdbc0f30953438e431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb890f75e68957fdbc0f30953438e431">&#9670;&nbsp;</a></span>centered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::centered </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p >The centered derivative is constructed by fitting a polynomial through the plus point the minus point and the center point and evaluating its derivative at the center point. For the exact resulting formula consult the <a href="https://www.overleaf.com/read/jjvstccqzcjv" target="_blank">parallel derivative</a> writeup</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a234ed5a5981b91f40472151824dc4985" name="a234ed5a5981b91f40472151824dc4985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234ed5a5981b91f40472151824dc4985">&#9670;&nbsp;</a></span>centered_bc_along_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::centered_bc_along_field </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>boundary_value</em> = <code>{0,0}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="group__fieldaligned.html#ga70d98ba526a42601f26374d4aacddec5" title="centered derivative">dg::geo::ds_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>. </p>

</div>
</div>
<a id="aff0dac9a94313bf6d006c1e398d1e56c" name="aff0dac9a94313bf6d006c1e398d1e56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0dac9a94313bf6d006c1e398d1e56c">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a397b9c50490e4c721c488c3568e6a5c2" name="a397b9c50490e4c721c488c3568e6a5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397b9c50490e4c721c488c3568e6a5c2">&#9670;&nbsp;</a></span>div() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::div </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \nabla \cdot ( \vec v f) \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a76f5b90b635b69bb0c5eacde3e3647a7" title="forward divergence">divForward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#af397aba8d43c37b88e1d85272d662d4d" title="backward divergence">divBackward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a64d5b30389cb32f6b624de430483ea54" title="centered divergence">divCentered()</a></code> </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="ac5b4f28a8012eb265343f2fecb88a2f4" name="ac5b4f28a8012eb265343f2fecb88a2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b4f28a8012eb265343f2fecb88a2f4">&#9670;&nbsp;</a></span>div() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::div </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \nabla \cdot( \vec v f) + \beta g \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a76f5b90b635b69bb0c5eacde3e3647a7" title="forward divergence">divForward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#af397aba8d43c37b88e1d85272d662d4d" title="backward divergence">divBackward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a64d5b30389cb32f6b624de430483ea54" title="centered divergence">divCentered()</a></code> </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="a2a489bdafca25538c65ceba000a1fef8" name="a2a489bdafca25538c65ceba000a1fef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a489bdafca25538c65ceba000a1fef8">&#9670;&nbsp;</a></span>divBackward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divBackward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="af397aba8d43c37b88e1d85272d662d4d" name="af397aba8d43c37b88e1d85272d662d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af397aba8d43c37b88e1d85272d662d4d">&#9670;&nbsp;</a></span>divBackward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divBackward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="ad464d8ddfe153648575abf6e6ca0d91d" name="ad464d8ddfe153648575abf6e6ca0d91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad464d8ddfe153648575abf6e6ca0d91d">&#9670;&nbsp;</a></span>divCentered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divCentered </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="a64d5b30389cb32f6b624de430483ea54" name="a64d5b30389cb32f6b624de430483ea54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d5b30389cb32f6b624de430483ea54">&#9670;&nbsp;</a></span>divCentered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divCentered </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="a6fa2b1fe16de8ec27c88ab6522367352" name="a6fa2b1fe16de8ec27c88ab6522367352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa2b1fe16de8ec27c88ab6522367352">&#9670;&nbsp;</a></span>divForward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divForward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="a76f5b90b635b69bb0c5eacde3e3647a7" name="a76f5b90b635b69bb0c5eacde3e3647a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f5b90b635b69bb0c5eacde3e3647a7">&#9670;&nbsp;</a></span>divForward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divForward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="a0a97e094e84673f71297df22a9bba4c5" name="a0a97e094e84673f71297df22a9bba4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a97e094e84673f71297df22a9bba4c5">&#9670;&nbsp;</a></span>ds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::ds </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \vec v\cdot \nabla f \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347" title="forward derivative">forward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821" title="backward derivative">backward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431" title="centered derivative">centered()</a></code> </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a3de32d878848eebdea7aee2d41b87a27" name="a3de32d878848eebdea7aee2d41b87a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de32d878848eebdea7aee2d41b87a27">&#9670;&nbsp;</a></span>ds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::ds </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347" title="forward derivative">forward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821" title="backward derivative">backward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431" title="centered derivative">centered()</a></code> </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="ac2adaf51aa28f332bb738d7c7a5fa149" name="ac2adaf51aa28f332bb738d7c7a5fa149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2adaf51aa28f332bb738d7c7a5fa149">&#9670;&nbsp;</a></span>dss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::dss </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = (\vec v\cdot \nabla)^2 f \). </p>
<p >The formula used is </p><p class="formulaDsp">
\[ \nabla_\parallel^2 f = 2\left(\frac{f^+}{h_z^+ h_z^0} - \frac{f^0}{h_z^- h_z^+} + \frac{f^-}{h_z^-h_z^0}\right) \]
</p>
<p> which is the second derivative of a 2nd order polynomial fitted through the plus, minus and centre points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a37a968a4d343037e248a2f7458e15e4c" name="a37a968a4d343037e248a2f7458e15e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a968a4d343037e248a2f7458e15e4c">&#9670;&nbsp;</a></span>dss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::dss </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \). </p>
<p >The formula used is </p><p class="formulaDsp">
\[ \nabla_\parallel^2 f = 2\left(\frac{f^+}{h_z^+ h_z^0} - \frac{f^0}{h_z^- h_z^+} + \frac{f^-}{h_z^-h_z^0}\right) \]
</p>
<p> which is the second derivative of a 2nd order polynomial fitted through the plus, minus and centre points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a27c0a604127403aefdbe3fffc17a91fc" name="a27c0a604127403aefdbe3fffc17a91fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c0a604127403aefdbe3fffc17a91fc">&#9670;&nbsp;</a></span>dss_bc_along_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::dss_bc_along_field </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>boundary_value</em> = <code>{0,0}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="group__fieldaligned.html#ga9d0308bf8d169f14efc488419bfa33b6" title="Centered derivative .">dg::geo::dss_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>. </p>

</div>
</div>
<a id="a0284d45e7af4e824d387880fb537c371" name="a0284d45e7af4e824d387880fb537c371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0284d45e7af4e824d387880fb537c371">&#9670;&nbsp;</a></span>dssd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::dssd </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code>. </p>

</div>
</div>
<a id="a3258a65655f65af0dc81d828a5949a79" name="a3258a65655f65af0dc81d828a5949a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3258a65655f65af0dc81d828a5949a79">&#9670;&nbsp;</a></span>dssd_bc_along_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::dssd_bc_along_field </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>boundary_value</em> = <code>{0,0}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>. </p>

</div>
</div>
<a id="a62c34ffb67ec8f2f20b60a75109b110a" name="a62c34ffb67ec8f2f20b60a75109b110a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c34ffb67ec8f2f20b60a75109b110a">&#9670;&nbsp;</a></span>fieldaligned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::fieldaligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the underlying <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object </p>
<dl class="section return"><dt>Returns</dt><dd>acces to <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object </dd></dl>

</div>
</div>
<a id="a883a5e61aac8a24d3b0c50ff30a75b70" name="a883a5e61aac8a24d3b0c50ff30a75b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883a5e61aac8a24d3b0c50ff30a75b70">&#9670;&nbsp;</a></span>fieldaligned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::fieldaligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae763e441ade3578a617e9df6aa97244b" name="ae763e441ade3578a617e9df6aa97244b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae763e441ade3578a617e9df6aa97244b">&#9670;&nbsp;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward derivative \( g = \vec v \cdot \nabla f \) </p>
<p >forward derivative \( g_i = \frac{v^\varphi}{\Delta\varphi}(f_{i+1} - f_{i})\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a181d80e0ee9c46b0f17f4737b01c7347" name="a181d80e0ee9c46b0f17f4737b01c7347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181d80e0ee9c46b0f17f4737b01c7347">&#9670;&nbsp;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p >forward derivative \( g_i = \alpha \frac{1}{h_z^+}(f_{i+1} - f_{i}) + \beta g_i\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a907c91fbf7f59dd085d55c3e0dca7e6b" name="a907c91fbf7f59dd085d55c3e0dca7e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907c91fbf7f59dd085d55c3e0dca7e6b">&#9670;&nbsp;</a></span>forward2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::forward2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2nd order forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p >forward derivative \( g_i = \alpha \frac{1}{2h_z^+}(-f_{i+2} + 4f_{i+1} - 3f_{i}) + \beta g_i\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a219af8b39bb8dbbdc0d3f7ff11fc2235" name="a219af8b39bb8dbbdc0d3f7ff11fc2235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219af8b39bb8dbbdc0d3f7ff11fc2235">&#9670;&nbsp;</a></span>get_jfactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::get_jfactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently used jfactor ( \( \alpha \)) </p>
<dl class="section return"><dt>Returns</dt><dd>The current scale factor for jump terms </dd></dl>

</div>
</div>
<a id="a02f14efeac450de2c7d109e20e1f1382" name="a02f14efeac450de2c7d109e20e1f1382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f14efeac450de2c7d109e20e1f1382">&#9670;&nbsp;</a></span>set_boundaries() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p >if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">global</td><td>3D vector containing boundary values </td></tr>
    <tr><td class="paramname">scal_left</td><td>left scaling factor </td></tr>
    <tr><td class="paramname">scal_right</td><td>right scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0897218b8eeb3bfdc70a1e2e3e912d76" name="a0897218b8eeb3bfdc70a1e2e3e912d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0897218b8eeb3bfdc70a1e2e3e912d76">&#9670;&nbsp;</a></span>set_boundaries() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p >if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>spatially variable left boundary value (2d size) </td></tr>
    <tr><td class="paramname">right</td><td>spatially variable right boundary value (2d size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a100b598ea427067b6e24885965e2a118" name="a100b598ea427067b6e24885965e2a118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100b598ea427067b6e24885965e2a118">&#9670;&nbsp;</a></span>set_boundaries() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p >if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>constant left boundary value </td></tr>
    <tr><td class="paramname">right</td><td>constant right boundary value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae470c3af9246e55e9becedffba7856e0" name="ae470c3af9246e55e9becedffba7856e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae470c3af9246e55e9becedffba7856e0">&#9670;&nbsp;</a></span>set_jfactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_jfactor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>new_jfactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the currently used jfactor ( \( \alpha \)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_jfactor</td><td>The new scale factor for jump terms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cd682b8f6e2d7b6eab4853ed5a55310" name="a7cd682b8f6e2d7b6eab4853ed5a55310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd682b8f6e2d7b6eab4853ed5a55310">&#9670;&nbsp;</a></span>symv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::symv </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \nabla\cdot ( \vec v \vec v \cdot \nabla f )\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="acb6b31544057e833d0efbb6c79ca853e" name="acb6b31544057e833d0efbb6c79ca853e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6b31544057e833d0efbb6c79ca853e">&#9670;&nbsp;</a></span>symv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::symv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \nabla\cdot ( \vec v \vec v \cdot \nabla f ) + \beta g\) as a symmetric matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>) </dd></dl>

</div>
</div>
<a id="aecdfadabfec3035166f405de30b0a9ba" name="aecdfadabfec3035166f405de30b0a9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdfadabfec3035166f405de30b0a9ba">&#9670;&nbsp;</a></span>weights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The volume form with dG weights. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ds_8h_source.html">ds.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="namespacedg_1_1geo.html">geo</a></li><li class="navelem"><a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a></li>
    <li class="footer">Generated on Fri Jan 28 2022 17:46:33 for Extension: Geometries by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
