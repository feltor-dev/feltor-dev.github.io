<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Geometry: dg::geo::DS&lt; ProductGeometry, IMatrix, Matrix, container &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="tablist"> 
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dG</a></li>
    <li><a href="../../geometries/html/modules.html">geometry</a></li>
    <li><a href="../../file/html/namespacefile.html">file</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Geometry
   </div>
   <div id="projectbrief">Library for magnetic flux functions, grids and grid generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structdg_1_1geo_1_1_d_s.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1geo_1_1_d_s-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::geo::DS&lt; ProductGeometry, IMatrix, Matrix, container &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__fieldaligned.html">4. Fieldaligned derivatives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for the evaluation of parallel derivatives.  
 <a href="structdg_1_1geo_1_1_d_s.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ds_8h_source.html">ds.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac83f7ebb7593a8739c9ea0585cd7d0de"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a></td></tr>
<tr class="separator:ac83f7ebb7593a8739c9ea0585cd7d0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea274cabb48d6b0b2808951fcd845e99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#aea274cabb48d6b0b2808951fcd845e99">DS</a> ()</td></tr>
<tr class="memdesc:aea274cabb48d6b0b2808951fcd845e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">No memory allocation; all member calls except construct are invalid.  <a href="#aea274cabb48d6b0b2808951fcd845e99">More...</a><br /></td></tr>
<tr class="separator:aea274cabb48d6b0b2808951fcd845e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0daa0e8cbf7cf4226ef676f9d4fc24"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:a6a0daa0e8cbf7cf4226ef676f9d4fc24"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a6a0daa0e8cbf7cf4226ef676f9d4fc24">DS</a> (const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;vec, const ProductGeometry &amp;grid, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a> no=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">dg::normed</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>, double eps=1e-5, unsigned multiplyX=10, unsigned multiplyY=10, bool dependsOnX=true, bool dependsOnY=true, bool integrateAll=true)</td></tr>
<tr class="memdesc:a6a0daa0e8cbf7cf4226ef676f9d4fc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the magnetic unit vector field and construct.  <a href="#a6a0daa0e8cbf7cf4226ef676f9d4fc24">More...</a><br /></td></tr>
<tr class="separator:a6a0daa0e8cbf7cf4226ef676f9d4fc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dfe6c0a366d6338d9f771765d0c145"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:a86dfe6c0a366d6338d9f771765d0c145"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a86dfe6c0a366d6338d9f771765d0c145">DS</a> (const <a class="el" href="structdg_1_1geo_1_1_binary_vector_lvl0.html">dg::geo::BinaryVectorLvl0</a> &amp;vec, const ProductGeometry &amp;grid, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a> no=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">dg::normed</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>, double eps=1e-5, unsigned multiplyX=10, unsigned multiplyY=10, bool dependsOnX=true, bool dependsOnY=true, bool integrateAll=true)</td></tr>
<tr class="memdesc:a86dfe6c0a366d6338d9f771765d0c145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the given vector field to construct.  <a href="#a86dfe6c0a366d6338d9f771765d0c145">More...</a><br /></td></tr>
<tr class="separator:a86dfe6c0a366d6338d9f771765d0c145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215b83e9c29b7ba8af530aeee91d895c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a215b83e9c29b7ba8af530aeee91d895c">DS</a> (const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp;<a class="el" href="structdg_1_1geo_1_1_d_s.html#a26667babe74320162c09f3cd6cbc48fb">fieldaligned</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a> no=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">dg::normed</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>)</td></tr>
<tr class="memdesc:a215b83e9c29b7ba8af530aeee91d895c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration. ">Fieldaligned</a></code> object.  <a href="#a215b83e9c29b7ba8af530aeee91d895c">More...</a><br /></td></tr>
<tr class="separator:a215b83e9c29b7ba8af530aeee91d895c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ae114ed661c3409cc53b209c3a48e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a64ae114ed661c3409cc53b209c3a48e8">construct</a> (const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp;<a class="el" href="structdg_1_1geo_1_1_d_s.html#a26667babe74320162c09f3cd6cbc48fb">fieldaligned</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a> no=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">dg::normed</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir=<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>)</td></tr>
<tr class="memdesc:a64ae114ed661c3409cc53b209c3a48e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration. ">Fieldaligned</a></code> object.  <a href="#a64ae114ed661c3409cc53b209c3a48e8">More...</a><br /></td></tr>
<tr class="separator:a64ae114ed661c3409cc53b209c3a48e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100b598ea427067b6e24885965e2a118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a100b598ea427067b6e24885965e2a118">set_boundaries</a> (<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, double left, double right)</td></tr>
<tr class="memdesc:a100b598ea427067b6e24885965e2a118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="#a100b598ea427067b6e24885965e2a118">More...</a><br /></td></tr>
<tr class="separator:a100b598ea427067b6e24885965e2a118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0897218b8eeb3bfdc70a1e2e3e912d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0897218b8eeb3bfdc70a1e2e3e912d76">set_boundaries</a> (<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;left, const container &amp;right)</td></tr>
<tr class="memdesc:a0897218b8eeb3bfdc70a1e2e3e912d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="#a0897218b8eeb3bfdc70a1e2e3e912d76">More...</a><br /></td></tr>
<tr class="separator:a0897218b8eeb3bfdc70a1e2e3e912d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f14efeac450de2c7d109e20e1f1382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a02f14efeac450de2c7d109e20e1f1382">set_boundaries</a> (<a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;global, double scal_left, double scal_right)</td></tr>
<tr class="memdesc:a02f14efeac450de2c7d109e20e1f1382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="#a02f14efeac450de2c7d109e20e1f1382">More...</a><br /></td></tr>
<tr class="separator:a02f14efeac450de2c7d109e20e1f1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181d80e0ee9c46b0f17f4737b01c7347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347">forward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a181d80e0ee9c46b0f17f4737b01c7347"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="#a181d80e0ee9c46b0f17f4737b01c7347">More...</a><br /></td></tr>
<tr class="separator:a181d80e0ee9c46b0f17f4737b01c7347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515d0bfa7ff3e56ddd7073f94e00d821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821">backward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a515d0bfa7ff3e56ddd7073f94e00d821"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="#a515d0bfa7ff3e56ddd7073f94e00d821">More...</a><br /></td></tr>
<tr class="separator:a515d0bfa7ff3e56ddd7073f94e00d821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb890f75e68957fdbc0f30953438e431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431">centered</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:acb890f75e68957fdbc0f30953438e431"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="#acb890f75e68957fdbc0f30953438e431">More...</a><br /></td></tr>
<tr class="separator:acb890f75e68957fdbc0f30953438e431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec3cea560d6cbbafd6a229deeef6036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0ec3cea560d6cbbafd6a229deeef6036">backward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a0ec3cea560d6cbbafd6a229deeef6036"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \vec v \cdot \nabla f \)  <a href="#a0ec3cea560d6cbbafd6a229deeef6036">More...</a><br /></td></tr>
<tr class="separator:a0ec3cea560d6cbbafd6a229deeef6036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae763e441ade3578a617e9df6aa97244b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ae763e441ade3578a617e9df6aa97244b">forward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ae763e441ade3578a617e9df6aa97244b"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \vec v \cdot \nabla f \)  <a href="#ae763e441ade3578a617e9df6aa97244b">More...</a><br /></td></tr>
<tr class="separator:ae763e441ade3578a617e9df6aa97244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd64e4aa948e9f6ff13a1f5970ddb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ab9dd64e4aa948e9f6ff13a1f5970ddb4">centered</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ab9dd64e4aa948e9f6ff13a1f5970ddb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \vec v \cdot \nabla f \)  <a href="#ab9dd64e4aa948e9f6ff13a1f5970ddb4">More...</a><br /></td></tr>
<tr class="separator:ab9dd64e4aa948e9f6ff13a1f5970ddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ed43f349b4d24349728da7617fa65e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#af8ed43f349b4d24349728da7617fa65e">forwardDiv</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:af8ed43f349b4d24349728da7617fa65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <a href="#af8ed43f349b4d24349728da7617fa65e">More...</a><br /></td></tr>
<tr class="separator:af8ed43f349b4d24349728da7617fa65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac739bf6d0229ad9b7a5d19014e915c00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac739bf6d0229ad9b7a5d19014e915c00">backwardDiv</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ac739bf6d0229ad9b7a5d19014e915c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <a href="#ac739bf6d0229ad9b7a5d19014e915c00">More...</a><br /></td></tr>
<tr class="separator:ac739bf6d0229ad9b7a5d19014e915c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a900c954253b1325074fbbaeebbdcf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a9a900c954253b1325074fbbaeebbdcf8">centeredDiv</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a9a900c954253b1325074fbbaeebbdcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <a href="#a9a900c954253b1325074fbbaeebbdcf8">More...</a><br /></td></tr>
<tr class="separator:a9a900c954253b1325074fbbaeebbdcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5c9d0f7ad2f772a5e169038417c770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a4b5c9d0f7ad2f772a5e169038417c770">forwardDiv</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a4b5c9d0f7ad2f772a5e169038417c770"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward divergence \( g = \nabla\cdot(\vec v f)\)  <a href="#a4b5c9d0f7ad2f772a5e169038417c770">More...</a><br /></td></tr>
<tr class="separator:a4b5c9d0f7ad2f772a5e169038417c770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0a3571fff8f52bb2b8bfc450549dfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a7d0a3571fff8f52bb2b8bfc450549dfc">backwardDiv</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a7d0a3571fff8f52bb2b8bfc450549dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward divergence \( g = \nabla\cdot(\vec v f)\)  <a href="#a7d0a3571fff8f52bb2b8bfc450549dfc">More...</a><br /></td></tr>
<tr class="separator:a7d0a3571fff8f52bb2b8bfc450549dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e58aca0efe20933f41e2f40175af310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a2e58aca0efe20933f41e2f40175af310">centeredDiv</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a2e58aca0efe20933f41e2f40175af310"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered divergence \( g = \nabla\cdot(\vec v f) g\)  <a href="#a2e58aca0efe20933f41e2f40175af310">More...</a><br /></td></tr>
<tr class="separator:a2e58aca0efe20933f41e2f40175af310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09906879fa12715b82ce80013f62ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a7f09906879fa12715b82ce80013f62ad">operator()</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a7f09906879fa12715b82ce80013f62ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \vec v\cdot \nabla f \).  <a href="#a7f09906879fa12715b82ce80013f62ad">More...</a><br /></td></tr>
<tr class="separator:a7f09906879fa12715b82ce80013f62ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4ff8ce9d41c92ca5d8ef2dcae6dff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a6e4ff8ce9d41c92ca5d8ef2dcae6dff3">operator()</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a6e4ff8ce9d41c92ca5d8ef2dcae6dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \).  <a href="#a6e4ff8ce9d41c92ca5d8ef2dcae6dff3">More...</a><br /></td></tr>
<tr class="separator:a6e4ff8ce9d41c92ca5d8ef2dcae6dff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd682b8f6e2d7b6eab4853ed5a55310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a7cd682b8f6e2d7b6eab4853ed5a55310">symv</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a7cd682b8f6e2d7b6eab4853ed5a55310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \nabla\cdot ( \vec v \vec v \cdot \nabla f )\) as a symmetric matrix.  <a href="#a7cd682b8f6e2d7b6eab4853ed5a55310">More...</a><br /></td></tr>
<tr class="separator:a7cd682b8f6e2d7b6eab4853ed5a55310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b31544057e833d0efbb6c79ca853e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb6b31544057e833d0efbb6c79ca853e">symv</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:acb6b31544057e833d0efbb6c79ca853e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \nabla\cdot ( \vec v \vec v \cdot \nabla f ) + \beta g\) as a symmetric matrix.  <a href="#acb6b31544057e833d0efbb6c79ca853e">More...</a><br /></td></tr>
<tr class="separator:acb6b31544057e833d0efbb6c79ca853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2adaf51aa28f332bb738d7c7a5fa149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac2adaf51aa28f332bb738d7c7a5fa149">dss</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ac2adaf51aa28f332bb738d7c7a5fa149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = (\vec v\cdot \nabla)^2 f \).  <a href="#ac2adaf51aa28f332bb738d7c7a5fa149">More...</a><br /></td></tr>
<tr class="separator:ac2adaf51aa28f332bb738d7c7a5fa149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a968a4d343037e248a2f7458e15e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a37a968a4d343037e248a2f7458e15e4c">dss</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a37a968a4d343037e248a2f7458e15e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \).  <a href="#a37a968a4d343037e248a2f7458e15e4c">More...</a><br /></td></tr>
<tr class="separator:a37a968a4d343037e248a2f7458e15e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004bab62e3c60fc16a68aa72493c4aac"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a004bab62e3c60fc16a68aa72493c4aac">weights</a> () const </td></tr>
<tr class="separator:a004bab62e3c60fc16a68aa72493c4aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcff3ae57cfd042b19918580de93262"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a2fcff3ae57cfd042b19918580de93262">inv_weights</a> () const </td></tr>
<tr class="separator:a2fcff3ae57cfd042b19918580de93262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b634c59412a5bbdb93860772f9cd097"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0b634c59412a5bbdb93860772f9cd097">precond</a> () const </td></tr>
<tr class="separator:a0b634c59412a5bbdb93860772f9cd097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26667babe74320162c09f3cd6cbc48fb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a26667babe74320162c09f3cd6cbc48fb">fieldaligned</a> () const </td></tr>
<tr class="memdesc:a26667babe74320162c09f3cd6cbc48fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the underlying <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration. ">Fieldaligned</a> object for evaluate  <a href="#a26667babe74320162c09f3cd6cbc48fb">More...</a><br /></td></tr>
<tr class="separator:a26667babe74320162c09f3cd6cbc48fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt;<br />
struct dg::geo::DS&lt; ProductGeometry, IMatrix, Matrix, container &gt;</h3>

<p>Class for the evaluation of parallel derivatives. </p>
<p>This class discretizes the operators \( \nabla_\parallel = \vec{v}\cdot \nabla = v^\zeta\partial_\zeta + v^\eta\partial_\eta + v^\varphi\partial_\varphi \), \(\nabla_\parallel^\dagger = -\nabla\cdot(\vec v .)\) and \(\Delta_\parallel=-\nabla_\parallel^\dagger\cdot\nabla_\parallel\) in arbitrary coordinates </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/structdg_1_1_cylindrical_grid3d.html">dg::CylindricalGrid3d</a> g3d( R_0 - a, R_0+a, -a, a, 0, 2.*M_PI, n, Nx, Ny, Nz, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>);</div><div class="line">    <span class="comment">//create magnetic field</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> mag = <a class="code" href="group__geom.html#gaa6d78afe4f306e34d509934f8f79421a">dg::geo::createCircularField</a>( R_0, I_0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structdg_1_1geo_1_1_binary_vector_lvl0.html">dg::geo::BinaryVectorLvl0</a> bhat( (<a class="code" href="structdg_1_1geo_1_1_b_hat_r.html">dg::geo::BHatR</a>)(mag), (<a class="code" href="structdg_1_1geo_1_1_b_hat_z.html">dg::geo::BHatZ</a>)(mag), (<a class="code" href="structdg_1_1geo_1_1_b_hat_p.html">dg::geo::BHatP</a>)(mag));</div><div class="line">    <span class="comment">//create Fieldaligned object and construct DS from it</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned&lt;dg::aProductGeometry3d,dg::IDMatrix,dg::DVec&gt;</a>  dsFA( bhat, g3d, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/structdg_1_1_z_e_r_o.html">dg::geo::NoLimiter</a>(), 1e-8, mx, my, <span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>);</div><div class="line">    <a class="code" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS&lt;dg::aProductGeometry3d, dg::IDMatrix, dg::DMatrix, dg::DVec&gt;</a> ds( dsFA, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066">dg::not_normed</a>, <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>);</div><div class="line">    <span class="comment">//apply to function </span></div><div class="line">    <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> <span class="keyword">function</span> = <a class="codeRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__evaluation.html#ga7521f4acb4edaf2d7896d99f97e1ed9d">dg::evaluate</a>( func, g3d), derivative(<span class="keyword">function</span>);</div><div class="line">    ds( <span class="keyword">function</span>, derivative);</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ProductGeometry</td><td>must be either <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/structdg_1_1a_product_geometry3d.html">dg::aProductGeometry3d</a> or <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/structdg_1_1a_product_m_p_i_geometry3d.html">dg::aProductMPIGeometry3d</a> or any derivative </td></tr>
    <tr><td class="paramname">IMatrix</td><td>The type of the interpolation matrix<ul>
<li><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga4780e2f8f426e5e691562dc00b34a9c2">dg::IHMatrix</a>, or <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga3f4eb35626ac9b7ec1a9e1ac44489c43">dg::IDMatrix</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a>, or <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga2fdf95d30a7a404b03e2e5ed4e88b603">dg::MIDMatrix</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">Matrix</td><td>The matrix class of the jump matrix<ul>
<li><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga03ea77a5e974bed59c16fc1b50e32fad">dg::HMatrix</a>, or <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gade8f2d2e22d78d961a4a83baad054922">dg::DMatrix</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gaa6f6bf3d7e428a9e66630a1a0e135d3a">dg::MHMatrix</a>, or <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga5d1f28d85330d29c74ea77f048d2978c">dg::MDMatrix</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">container</td><td>The container-class on which the interpolation matrix operates on<ul>
<li><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gab99e8227ed890885a7b9915806865a7a">dg::HVec</a>, or <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a>, <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f">dg::MHVec</a>, or <a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__typedefs.html#ga25cae493b710b17992387cce395ad7ae">dg::MDVec</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The pdf <a href="./parallel.pdf" target="_blank">parallel derivative</a> writeup </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ac83f7ebb7593a8739c9ea0585cd7d0de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt;ProductGeometry, IMatrix, container&gt; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>conveniently abbreviates underlying <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration. ">Fieldaligned</a></code> type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aea274cabb48d6b0b2808951fcd845e99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No memory allocation; all member calls except construct are invalid. </p>

</div>
</div>
<a class="anchor" id="a6a0daa0e8cbf7cf4226ef676f9d4fc24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a>&#160;</td>
          <td class="paramname"><em>no</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">dg::normed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyX</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyY</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnX</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnY</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>integrateAll</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the magnetic unit vector field and construct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to operate defines the parallel boundary condition in case there is a limiter. </td></tr>
    <tr><td class="paramname">bcx</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">bcy</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Default is a limiter everywhere, note that if <code>grid.bcz()</code> is periodic it doesn't matter if there is a limiter or not) </td></tr>
    <tr><td class="paramname">no</td><td>indicate if the symv function should be symmetric (not_normed) or not </td></tr>
    <tr><td class="paramname">dir</td><td>indicate the direction in the bracket operator and in symv</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">multiplyX</td><td>defines the resolution in X of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">multiplyY</td><td>defines the resolution in Y of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">dependsOnX</td><td>indicates, whether the given vector field vec depends on the first coordinate </td></tr>
    <tr><td class="paramname">dependsOnY</td><td>indicates, whether the given vector field vec depends on the second coordinate </td></tr>
    <tr><td class="paramname">integrateAll</td><td>indicates, that all fieldlines of the fine grid should be integrated instead of interpolating it from the coarse grid. Should be true if the streamlines of the vector field cross the domain boudary. </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>Is either &lt;0 (then it's ignored), or may differ from grid.hz() if grid.Nz() == 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration. ">Fieldaligned</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a86dfe6c0a366d6338d9f771765d0c145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_binary_vector_lvl0.html">dg::geo::BinaryVectorLvl0</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a>&#160;</td>
          <td class="paramname"><em>no</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">dg::normed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyX</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyY</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnX</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependsOnY</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>integrateAll</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the given vector field to construct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to operate defines the parallel boundary condition in case there is a limiter. </td></tr>
    <tr><td class="paramname">bcx</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">bcy</td><td>Defines the interpolation behaviour when a fieldline intersects the boundary box in the perpendicular direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Default is a limiter everywhere, note that if <code>grid.bcz()</code> is periodic it doesn't matter if there is a limiter or not) </td></tr>
    <tr><td class="paramname">no</td><td>indicate if the symv function should be symmetric (not_normed) or not </td></tr>
    <tr><td class="paramname">dir</td><td>indicate the direction in the bracket operator and in symv</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">multiplyX</td><td>defines the resolution in X of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">multiplyY</td><td>defines the resolution in Y of the fine grid relative to grid </td></tr>
    <tr><td class="paramname">dependsOnX</td><td>indicates, whether the given vector field vec depends on the first coordinate </td></tr>
    <tr><td class="paramname">dependsOnY</td><td>indicates, whether the given vector field vec depends on the second coordinate </td></tr>
    <tr><td class="paramname">integrateAll</td><td>indicates, that all fieldlines of the fine grid should be integrated instead of interpolating it from the coarse grid. Should be true if the streamlines of the vector field cross the domain boudary. </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>Is either &lt;0 (then it's ignored), or may differ from grid.hz() if grid.Nz() == 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration. ">Fieldaligned</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a215b83e9c29b7ba8af530aeee91d895c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldaligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a>&#160;</td>
          <td class="paramname"><em>no</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">dg::normed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration. ">Fieldaligned</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldaligned</td><td>this object will be used in all further member calls </td></tr>
    <tr><td class="paramname">no</td><td>indicate if the symv function should be symmetric (not_normed) or not </td></tr>
    <tr><td class="paramname">dir</td><td>indicate the direction in the bracket operator and in symv </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a515d0bfa7ff3e56ddd7073f94e00d821"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::backward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>backward derivative \( g_i = \alpha \frac{1}{2h_z^-}(f_{i} - f_{i-1}) + \beta g_i \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="a0ec3cea560d6cbbafd6a229deeef6036"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::backward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward derivative \( g = \vec v \cdot \nabla f \) </p>
<p>backward derivative \( g_i = \frac{1}{2h_z^-}(f_{i} - f_{i-1}) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="ac739bf6d0229ad9b7a5d19014e915c00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::backwardDiv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd>
<dd>
backwardDiv is the negative adjoint of forward </dd></dl>

</div>
</div>
<a class="anchor" id="a7d0a3571fff8f52bb2b8bfc450549dfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::backwardDiv </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd>
<dd>
backwardDiv is the negative adjoint of forward </dd></dl>

</div>
</div>
<a class="anchor" id="acb890f75e68957fdbc0f30953438e431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::centered </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>centered derivative \( g_i = \alpha \frac{1}{2h_z^0}(f_{i+1} - f_{i-1}) + \beta g_i\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="ab9dd64e4aa948e9f6ff13a1f5970ddb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::centered </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered derivative \( g = \vec v \cdot \nabla f \) </p>
<p>centered derivative \( g_i = \frac{1}{2h_z^0}(f_{i+1} - f_{i-1})\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="a9a900c954253b1325074fbbaeebbdcf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::centeredDiv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd>
<dd>
centeredDiv is the negative adjoint of centered </dd></dl>

</div>
</div>
<a class="anchor" id="a2e58aca0efe20933f41e2f40175af310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::centeredDiv </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered divergence \( g = \nabla\cdot(\vec v f) g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd>
<dd>
centeredDiv is the negative adjoint of centered </dd></dl>

</div>
</div>
<a class="anchor" id="a64ae114ed661c3409cc53b209c3a48e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldaligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a>&#160;</td>
          <td class="paramname"><em>no</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">dg::normed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration. ">Fieldaligned</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldaligned</td><td>this object will be used in all further member calls </td></tr>
    <tr><td class="paramname">no</td><td>indicate if the symv function should be symmetric (not_normed) or not </td></tr>
    <tr><td class="paramname">dir</td><td>indicate the direction in the bracket operator and in symv </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2adaf51aa28f332bb738d7c7a5fa149"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::dss </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = (\vec v\cdot \nabla)^2 f \). </p>
<p>The formula used is </p><p class="formulaDsp">
\[ \nabla_\parallel^2 f = 2\left(\frac{f^+}{h_z^+h_z^0} - \frac{f^0}{h_z^+h_z^-} + \frac{f^-}{h_z^-h_z^0}\right) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="a37a968a4d343037e248a2f7458e15e4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::dss </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \). </p>
<p>The formula used is </p><p class="formulaDsp">
\[ \nabla_\parallel^2 f = 2\left(\frac{f^+}{h_z^+h_z^0} - \frac{f^0}{h_z^+h_z^-} + \frac{f^-}{h_z^-h_z^0}\right) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="a26667babe74320162c09f3cd6cbc48fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a>&amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::fieldaligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the underlying <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration. ">Fieldaligned</a> object for evaluate </p>
<dl class="section return"><dt>Returns</dt><dd>acces to fieldaligned object </dd></dl>

</div>
</div>
<a class="anchor" id="a181d80e0ee9c46b0f17f4737b01c7347"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>forward derivative \( g_i = \alpha \frac{1}{h_z^+}(f_{i+1} - f_{i}) + \beta g_i\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="ae763e441ade3578a617e9df6aa97244b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward derivative \( g = \vec v \cdot \nabla f \) </p>
<p>forward derivative \( g_i = \frac{1}{h_z^+}(f_{i+1} - f_{i})\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="af8ed43f349b4d24349728da7617fa65e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::forwardDiv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd>
<dd>
forwardDiv is the negative adjoint of backward </dd></dl>

</div>
</div>
<a class="anchor" id="a4b5c9d0f7ad2f772a5e169038417c770"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::forwardDiv </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd>
<dd>
forwardDiv is the negative adjoint of backward </dd></dl>

</div>
</div>
<a class="anchor" id="a2fcff3ae57cfd042b19918580de93262"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container&amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::inv_weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f09906879fa12715b82ce80013f62ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \vec v\cdot \nabla f \). </p>
<p>dependent on dir given in constructor redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347" title="forward derivative  ">forward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821" title="backward derivative  ">backward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431" title="centered derivative  ">centered()</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="a6e4ff8ce9d41c92ca5d8ef2dcae6dff3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \). </p>
<p>dependent on dir given in constructor redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347" title="forward derivative  ">forward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821" title="backward derivative  ">backward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431" title="centered derivative  ">centered()</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a class="anchor" id="a0b634c59412a5bbdb93860772f9cd097"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container&amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::precond </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a100b598ea427067b6e24885965e2a118"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>constant left boundary value </td></tr>
    <tr><td class="paramname">right</td><td>constant right boundary value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0897218b8eeb3bfdc70a1e2e3e912d76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>spatially variable left boundary value (2d size) </td></tr>
    <tr><td class="paramname">right</td><td>spatially variable right boundary value (2d size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02f14efeac450de2c7d109e20e1f1382"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/dg.tag:../../dg/html/" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">global</td><td>3D vector containing boundary values </td></tr>
    <tr><td class="paramname">scal_left</td><td>left scaling factor </td></tr>
    <tr><td class="paramname">scal_right</td><td>right scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cd682b8f6e2d7b6eab4853ed5a55310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::symv </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \nabla\cdot ( \vec v \vec v \cdot \nabla f )\) as a symmetric matrix. </p>
<p>if direction given in constructor is centered then centered followed by centeredDiv and adding jump terms is called, else a symmetric forward/backward discretization is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd>
<dd>
if dependsOnX is false then no jump terms will be added in the x-direction; analogous in y </dd></dl>

</div>
</div>
<a class="anchor" id="acb6b31544057e833d0efbb6c79ca853e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::symv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \nabla\cdot ( \vec v \vec v \cdot \nabla f ) + \beta g\) as a symmetric matrix. </p>
<p>if direction given in constructor is centered then centered followed by centeredDiv and adding jump terms is called, else a symmetric forward/backward discretization is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd>
<dd>
if dependsOnX is false then no jump terms will be added in the x-direction; analogous in y </dd></dl>

</div>
</div>
<a class="anchor" id="a004bab62e3c60fc16a68aa72493c4aac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container&amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ds_8h_source.html">ds.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="namespacedg_1_1geo.html">geo</a></li><li class="navelem"><a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a></li>
    <li class="footer">Generated on Wed Nov 15 2017 10:37:33 for Geometry by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
