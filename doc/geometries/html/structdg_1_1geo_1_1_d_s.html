<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Extension: Geometries: dg::geo::DS&lt; ProductGeometry, IMatrix, Matrix, container &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Extension: Geometries
   </div>
   <div id="projectbrief">Magnetic flux functions, parallel derivatives and new grids and grid generators in &quot;dg/geometries/geometries.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structdg_1_1geo_1_1_d_s.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1geo_1_1_d_s-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::geo::DS&lt; ProductGeometry, IMatrix, Matrix, container &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__fieldaligned.html">4. Fieldaligned derivatives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for the evaluation of parallel derivatives.  
 <a href="structdg_1_1geo_1_1_d_s.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ds_8h_source.html">ds.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac83f7ebb7593a8739c9ea0585cd7d0de"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a></td></tr>
<tr class="separator:ac83f7ebb7593a8739c9ea0585cd7d0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea274cabb48d6b0b2808951fcd845e99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#aea274cabb48d6b0b2808951fcd845e99">DS</a> ()</td></tr>
<tr class="memdesc:aea274cabb48d6b0b2808951fcd845e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">No memory allocation; all member calls except construct are invalid.  <a href="structdg_1_1geo_1_1_d_s.html#aea274cabb48d6b0b2808951fcd845e99">More...</a><br /></td></tr>
<tr class="separator:aea274cabb48d6b0b2808951fcd845e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b8277c8ee59e348d87b9e43ba0dc3a"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:a82b8277c8ee59e348d87b9e43ba0dc3a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a82b8277c8ee59e348d87b9e43ba0dc3a">DS</a> (const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;vec, const ProductGeometry &amp;grid, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), <a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir=<a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>, double eps=1e-5, unsigned mx=10, unsigned my=10, double deltaPhi=-1)</td></tr>
<tr class="memdesc:a82b8277c8ee59e348d87b9e43ba0dc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the magnetic unit vector field and construct.  <a href="structdg_1_1geo_1_1_d_s.html#a82b8277c8ee59e348d87b9e43ba0dc3a">More...</a><br /></td></tr>
<tr class="separator:a82b8277c8ee59e348d87b9e43ba0dc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41149195ff54693259471dcb2ad766d9"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:a41149195ff54693259471dcb2ad766d9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a41149195ff54693259471dcb2ad766d9">DS</a> (const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl0.html">dg::geo::CylindricalVectorLvl0</a> &amp;vec, const ProductGeometry &amp;grid, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), <a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir=<a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>, double eps=1e-5, unsigned mx=10, unsigned my=10, double deltaPhi=-1)</td></tr>
<tr class="memdesc:a41149195ff54693259471dcb2ad766d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the given vector field to construct.  <a href="structdg_1_1geo_1_1_d_s.html#a41149195ff54693259471dcb2ad766d9">More...</a><br /></td></tr>
<tr class="separator:a41149195ff54693259471dcb2ad766d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0f9a42762ff9f75c03086b0b3fa708"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a7f0f9a42762ff9f75c03086b0b3fa708">DS</a> (<a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> <a class="el" href="structdg_1_1geo_1_1_d_s.html#a9be1d0b4cd476e4363097205eccf273a">fieldaligned</a>, <a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir=<a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>)</td></tr>
<tr class="memdesc:a7f0f9a42762ff9f75c03086b0b3fa708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> object.  <a href="structdg_1_1geo_1_1_d_s.html#a7f0f9a42762ff9f75c03086b0b3fa708">More...</a><br /></td></tr>
<tr class="separator:a7f0f9a42762ff9f75c03086b0b3fa708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0dac9a94313bf6d006c1e398d1e56c"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:aff0dac9a94313bf6d006c1e398d1e56c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#aff0dac9a94313bf6d006c1e398d1e56c">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:aff0dac9a94313bf6d006c1e398d1e56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.  <a href="structdg_1_1geo_1_1_d_s.html#aff0dac9a94313bf6d006c1e398d1e56c">More...</a><br /></td></tr>
<tr class="separator:aff0dac9a94313bf6d006c1e398d1e56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889a9a97c8c2c94308f2936a8753f490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a889a9a97c8c2c94308f2936a8753f490">set_direction</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir)</td></tr>
<tr class="memdesc:a889a9a97c8c2c94308f2936a8753f490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the direction used in the operator() and symv member.  <a href="structdg_1_1geo_1_1_d_s.html#a889a9a97c8c2c94308f2936a8753f490">More...</a><br /></td></tr>
<tr class="separator:a889a9a97c8c2c94308f2936a8753f490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100b598ea427067b6e24885965e2a118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a100b598ea427067b6e24885965e2a118">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, double left, double right)</td></tr>
<tr class="memdesc:a100b598ea427067b6e24885965e2a118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="structdg_1_1geo_1_1_d_s.html#a100b598ea427067b6e24885965e2a118">More...</a><br /></td></tr>
<tr class="separator:a100b598ea427067b6e24885965e2a118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0897218b8eeb3bfdc70a1e2e3e912d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0897218b8eeb3bfdc70a1e2e3e912d76">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;left, const container &amp;right)</td></tr>
<tr class="memdesc:a0897218b8eeb3bfdc70a1e2e3e912d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="structdg_1_1geo_1_1_d_s.html#a0897218b8eeb3bfdc70a1e2e3e912d76">More...</a><br /></td></tr>
<tr class="separator:a0897218b8eeb3bfdc70a1e2e3e912d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f14efeac450de2c7d109e20e1f1382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a02f14efeac450de2c7d109e20e1f1382">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;global, double scal_left, double scal_right)</td></tr>
<tr class="memdesc:a02f14efeac450de2c7d109e20e1f1382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.  <a href="structdg_1_1geo_1_1_d_s.html#a02f14efeac450de2c7d109e20e1f1382">More...</a><br /></td></tr>
<tr class="separator:a02f14efeac450de2c7d109e20e1f1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181d80e0ee9c46b0f17f4737b01c7347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347">forward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a181d80e0ee9c46b0f17f4737b01c7347"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347">More...</a><br /></td></tr>
<tr class="separator:a181d80e0ee9c46b0f17f4737b01c7347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515d0bfa7ff3e56ddd7073f94e00d821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821">backward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a515d0bfa7ff3e56ddd7073f94e00d821"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821">More...</a><br /></td></tr>
<tr class="separator:a515d0bfa7ff3e56ddd7073f94e00d821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb890f75e68957fdbc0f30953438e431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431">centered</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:acb890f75e68957fdbc0f30953438e431"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431">More...</a><br /></td></tr>
<tr class="separator:acb890f75e68957fdbc0f30953438e431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec3cea560d6cbbafd6a229deeef6036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0ec3cea560d6cbbafd6a229deeef6036">backward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a0ec3cea560d6cbbafd6a229deeef6036"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \vec v \cdot \nabla f \)  <a href="structdg_1_1geo_1_1_d_s.html#a0ec3cea560d6cbbafd6a229deeef6036">More...</a><br /></td></tr>
<tr class="separator:a0ec3cea560d6cbbafd6a229deeef6036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae763e441ade3578a617e9df6aa97244b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ae763e441ade3578a617e9df6aa97244b">forward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ae763e441ade3578a617e9df6aa97244b"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \vec v \cdot \nabla f \)  <a href="structdg_1_1geo_1_1_d_s.html#ae763e441ade3578a617e9df6aa97244b">More...</a><br /></td></tr>
<tr class="separator:ae763e441ade3578a617e9df6aa97244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd64e4aa948e9f6ff13a1f5970ddb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ab9dd64e4aa948e9f6ff13a1f5970ddb4">centered</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ab9dd64e4aa948e9f6ff13a1f5970ddb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \vec v \cdot \nabla f \)  <a href="structdg_1_1geo_1_1_d_s.html#ab9dd64e4aa948e9f6ff13a1f5970ddb4">More...</a><br /></td></tr>
<tr class="separator:ab9dd64e4aa948e9f6ff13a1f5970ddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f5b90b635b69bb0c5eacde3e3647a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a76f5b90b635b69bb0c5eacde3e3647a7">divForward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a76f5b90b635b69bb0c5eacde3e3647a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#a76f5b90b635b69bb0c5eacde3e3647a7">More...</a><br /></td></tr>
<tr class="separator:a76f5b90b635b69bb0c5eacde3e3647a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af397aba8d43c37b88e1d85272d662d4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#af397aba8d43c37b88e1d85272d662d4d">divBackward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:af397aba8d43c37b88e1d85272d662d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#af397aba8d43c37b88e1d85272d662d4d">More...</a><br /></td></tr>
<tr class="separator:af397aba8d43c37b88e1d85272d662d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d5b30389cb32f6b624de430483ea54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a64d5b30389cb32f6b624de430483ea54">divCentered</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a64d5b30389cb32f6b624de430483ea54"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <a href="structdg_1_1geo_1_1_d_s.html#a64d5b30389cb32f6b624de430483ea54">More...</a><br /></td></tr>
<tr class="separator:a64d5b30389cb32f6b624de430483ea54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa2b1fe16de8ec27c88ab6522367352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a6fa2b1fe16de8ec27c88ab6522367352">divForward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a6fa2b1fe16de8ec27c88ab6522367352"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward divergence \( g = \nabla\cdot(\vec v f)\)  <a href="structdg_1_1geo_1_1_d_s.html#a6fa2b1fe16de8ec27c88ab6522367352">More...</a><br /></td></tr>
<tr class="separator:a6fa2b1fe16de8ec27c88ab6522367352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a489bdafca25538c65ceba000a1fef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a2a489bdafca25538c65ceba000a1fef8">divBackward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a2a489bdafca25538c65ceba000a1fef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward divergence \( g = \nabla\cdot(\vec v f)\)  <a href="structdg_1_1geo_1_1_d_s.html#a2a489bdafca25538c65ceba000a1fef8">More...</a><br /></td></tr>
<tr class="separator:a2a489bdafca25538c65ceba000a1fef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad464d8ddfe153648575abf6e6ca0d91d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ad464d8ddfe153648575abf6e6ca0d91d">divCentered</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ad464d8ddfe153648575abf6e6ca0d91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered divergence \( g = \nabla\cdot(\vec v f)\)  <a href="structdg_1_1geo_1_1_d_s.html#ad464d8ddfe153648575abf6e6ca0d91d">More...</a><br /></td></tr>
<tr class="separator:ad464d8ddfe153648575abf6e6ca0d91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09906879fa12715b82ce80013f62ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a7f09906879fa12715b82ce80013f62ad">operator()</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a7f09906879fa12715b82ce80013f62ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \vec v\cdot \nabla f \).  <a href="structdg_1_1geo_1_1_d_s.html#a7f09906879fa12715b82ce80013f62ad">More...</a><br /></td></tr>
<tr class="separator:a7f09906879fa12715b82ce80013f62ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4ff8ce9d41c92ca5d8ef2dcae6dff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a6e4ff8ce9d41c92ca5d8ef2dcae6dff3">operator()</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a6e4ff8ce9d41c92ca5d8ef2dcae6dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \).  <a href="structdg_1_1geo_1_1_d_s.html#a6e4ff8ce9d41c92ca5d8ef2dcae6dff3">More...</a><br /></td></tr>
<tr class="separator:a6e4ff8ce9d41c92ca5d8ef2dcae6dff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a97e094e84673f71297df22a9bba4c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a0a97e094e84673f71297df22a9bba4c5">ds</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a0a97e094e84673f71297df22a9bba4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \vec v\cdot \nabla f \).  <a href="structdg_1_1geo_1_1_d_s.html#a0a97e094e84673f71297df22a9bba4c5">More...</a><br /></td></tr>
<tr class="separator:a0a97e094e84673f71297df22a9bba4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de32d878848eebdea7aee2d41b87a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a3de32d878848eebdea7aee2d41b87a27">ds</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a3de32d878848eebdea7aee2d41b87a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \).  <a href="structdg_1_1geo_1_1_d_s.html#a3de32d878848eebdea7aee2d41b87a27">More...</a><br /></td></tr>
<tr class="separator:a3de32d878848eebdea7aee2d41b87a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397b9c50490e4c721c488c3568e6a5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a397b9c50490e4c721c488c3568e6a5c2">div</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a397b9c50490e4c721c488c3568e6a5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \nabla \cdot ( \vec v f) \).  <a href="structdg_1_1geo_1_1_d_s.html#a397b9c50490e4c721c488c3568e6a5c2">More...</a><br /></td></tr>
<tr class="separator:a397b9c50490e4c721c488c3568e6a5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b4f28a8012eb265343f2fecb88a2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac5b4f28a8012eb265343f2fecb88a2f4">div</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ac5b4f28a8012eb265343f2fecb88a2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \nabla \cdot( \vec v f) + \beta g \).  <a href="structdg_1_1geo_1_1_d_s.html#ac5b4f28a8012eb265343f2fecb88a2f4">More...</a><br /></td></tr>
<tr class="separator:ac5b4f28a8012eb265343f2fecb88a2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd682b8f6e2d7b6eab4853ed5a55310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a7cd682b8f6e2d7b6eab4853ed5a55310">symv</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a7cd682b8f6e2d7b6eab4853ed5a55310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \nabla\cdot ( \vec v \vec v \cdot \nabla f )\).  <a href="structdg_1_1geo_1_1_d_s.html#a7cd682b8f6e2d7b6eab4853ed5a55310">More...</a><br /></td></tr>
<tr class="separator:a7cd682b8f6e2d7b6eab4853ed5a55310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b31544057e833d0efbb6c79ca853e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb6b31544057e833d0efbb6c79ca853e">symv</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:acb6b31544057e833d0efbb6c79ca853e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \nabla\cdot ( \vec v \vec v \cdot \nabla f ) + \beta g\) as a symmetric matrix.  <a href="structdg_1_1geo_1_1_d_s.html#acb6b31544057e833d0efbb6c79ca853e">More...</a><br /></td></tr>
<tr class="separator:acb6b31544057e833d0efbb6c79ca853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2adaf51aa28f332bb738d7c7a5fa149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac2adaf51aa28f332bb738d7c7a5fa149">dss</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ac2adaf51aa28f332bb738d7c7a5fa149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = (\vec v\cdot \nabla)^2 f \).  <a href="structdg_1_1geo_1_1_d_s.html#ac2adaf51aa28f332bb738d7c7a5fa149">More...</a><br /></td></tr>
<tr class="separator:ac2adaf51aa28f332bb738d7c7a5fa149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a968a4d343037e248a2f7458e15e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a37a968a4d343037e248a2f7458e15e4c">dss</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a37a968a4d343037e248a2f7458e15e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \).  <a href="structdg_1_1geo_1_1_d_s.html#a37a968a4d343037e248a2f7458e15e4c">More...</a><br /></td></tr>
<tr class="separator:a37a968a4d343037e248a2f7458e15e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186161681f43813d2036347e0b7efa17"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a186161681f43813d2036347e0b7efa17">weights</a> () const</td></tr>
<tr class="separator:a186161681f43813d2036347e0b7efa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48b9432470a8e5de58bca0fbad12b3c"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ad48b9432470a8e5de58bca0fbad12b3c">inv_weights</a> () const</td></tr>
<tr class="separator:ad48b9432470a8e5de58bca0fbad12b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e60e008773654113c1fab1bd3a279c7"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a6e60e008773654113c1fab1bd3a279c7">precond</a> () const</td></tr>
<tr class="separator:a6e60e008773654113c1fab1bd3a279c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be1d0b4cd476e4363097205eccf273a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html#a9be1d0b4cd476e4363097205eccf273a">fieldaligned</a> () const</td></tr>
<tr class="memdesc:a9be1d0b4cd476e4363097205eccf273a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the underlying <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object  <a href="structdg_1_1geo_1_1_d_s.html#a9be1d0b4cd476e4363097205eccf273a">More...</a><br /></td></tr>
<tr class="separator:a9be1d0b4cd476e4363097205eccf273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ProductGeometry, class IMatrix, class Matrix, class container&gt;<br />
struct dg::geo::DS&lt; ProductGeometry, IMatrix, Matrix, container &gt;</h3>

<p>Class for the evaluation of parallel derivatives. </p>
<p>This class discretizes the operators \( \nabla_\parallel = \vec{v}\cdot \nabla = v^\zeta\partial_\zeta + v^\eta\partial_\eta + v^\varphi\partial_\varphi \), \(\nabla_\parallel^\dagger = -\nabla\cdot(\vec v .)\) and \(\Delta_\parallel=-\nabla_\parallel^\dagger\cdot\nabla_\parallel\) in arbitrary coordinates </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="codeRef" href="../../dg/html/structdg_1_1_real_cylindrical_grid3d.html">dg::CylindricalGrid3d</a> g3d( R_0-a, R_0+a, -a, a, 0, 2.*M_PI, n, Nx, Ny, Nz, <a class="codeRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>);</div>
<div class="line">    <span class="comment">//create magnetic field</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> mag = <a class="code" href="group__toroidal.html#ga16471692288263e2076b897dae16799f">dg::geo::createCircularField</a>( R_0, I_0);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structdg_1_1geo_1_1_cylindrical_vector_lvl0.html">dg::geo::CylindricalVectorLvl0</a> bhat = <a class="code" href="group__magnetic.html#ga6182dc55424bffffb0d9876b9f90222d">dg::geo::createBHat</a>(mag);</div>
<div class="line">    <span class="comment">//create Fieldaligned object and construct DS from it</span></div>
<div class="line">    <a class="code" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned&lt;dg::aProductGeometry3d,dg::IDMatrix,dg::DVec&gt;</a>  dsFA( bhat, g3d, <a class="codeRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="codeRef" href="../../dg/html/structdg_1_1_z_e_r_o.html">dg::geo::NoLimiter</a>(), 1e-8, mx, my);</div>
<div class="line">    <a class="code" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS&lt;dg::aProductGeometry3d, dg::IDMatrix, dg::DMatrix, dg::DVec&gt;</a> <a class="code" href="structdg_1_1geo_1_1_d_s.html#a0a97e094e84673f71297df22a9bba4c5">ds</a>( dsFA, <a class="codeRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a> );</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The parallel Laplacian cannot be inverted as long as there are closed fieldlines somewhere in the domain (which is virtually always true). There is therefore no norm parameter in the class. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably work only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ProductGeometry</td><td>must be either <code><a class="elRef" href="../../dg/html/group__gridtypes.html#gad3d6bea9081a22d2133ce8c42bd5ca46">dg::aProductGeometry3d</a></code> or <code><a class="elRef" href="../../dg/html/group__gridtypes.html#ga4f8e4aa131946e62c3a8b0325956c73e">dg::aProductMPIGeometry3d</a></code> or any derivative </td></tr>
    <tr><td class="paramname">IMatrix</td><td>The type of the interpolation matrix<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#ga3d74638bbcf620f19e3728a07ef1706d">dg::IHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gaec4df2a8ab65260aed0efeb6f5d115e4">dg::IDMatrix</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga6f954391920cbd9b9ec4c7b68fdb7682">dg::MIHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gabed94dc9f33454571b7a124fb3851091">dg::MIDMatrix</a></code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">Matrix</td><td>The matrix class of the jump matrix<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#gac2134505608b45616787fdb2f6eedc87">dg::HMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16">dg::DMatrix</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161">dg::MHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005">dg::MDMatrix</a></code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">container</td><td>The container-class on which the interpolation matrix operates on<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0">dg::MHVec</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55">dg::MDVec</a></code> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The pdf <a href="./parallel.pdf" target="_blank">parallel derivative</a> writeup </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac83f7ebb7593a8739c9ea0585cd7d0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83f7ebb7593a8739c9ea0585cd7d0de">&#9670;&nbsp;</a></span>FA</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt;ProductGeometry, IMatrix, container&gt; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>conveniently abbreviates underlying <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea274cabb48d6b0b2808951fcd845e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea274cabb48d6b0b2808951fcd845e99">&#9670;&nbsp;</a></span>DS() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No memory allocation; all member calls except construct are invalid. </p>

</div>
</div>
<a id="a82b8277c8ee59e348d87b9e43ba0dc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b8277c8ee59e348d87b9e43ba0dc3a">&#9670;&nbsp;</a></span>DS() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mx</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>my</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the magnetic unit vector field and construct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">bcx</td><td>This parameter is passed on to <code><a class="elRef" href="../../dg/html/group__interpolation.html#gac238077768fe5fc49ab3cd4f94569ef4">dg::create::interpolation(const thrust::host_vector&lt;real_type&gt;&amp;,const thrust::host_vector&lt;real_type&gt;&amp;,const aRealTopology2d&lt;real_type&gt;&amp;,dg::bc,dg::bc)</a></code> (see there for more details) function and deterimens what happens when the endpoint of the fieldline integration leaves the domain boundaries of <code>grid</code>. Note that <code>bcx</code> and <code>grid.bcx()</code> have to be either both periodic or both not periodic. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Note that if <code>grid.bcz()==<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code> this parameter is ignored, Default is a limiter everywhere)</td></tr>
    <tr><td class="paramname">dir</td><td>indicate the direction in the bracket operator and in symv</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">mx</td><td>refinement factor in X of the fine grid relative to grid (Set to 1, if the x-component of <code>vec</code> vanishes, else as high as possible, 10 is a good start) </td></tr>
    <tr><td class="paramname">my</td><td>analogous to <code>mx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>Is either &lt;0 (then it's ignored), or may differ from <code>grid.hz()</code> if <code>grid.Nz()==1</code>, then <code>deltaPhi</code> is taken instead of <code>grid.hz()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> </dd></dl>

</div>
</div>
<a id="a41149195ff54693259471dcb2ad766d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41149195ff54693259471dcb2ad766d9">&#9670;&nbsp;</a></span>DS() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl0.html">dg::geo::CylindricalVectorLvl0</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mx</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>my</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deltaPhi</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the given vector field to construct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">bcx</td><td>This parameter is passed on to <code><a class="elRef" href="../../dg/html/group__interpolation.html#gac238077768fe5fc49ab3cd4f94569ef4">dg::create::interpolation(const thrust::host_vector&lt;real_type&gt;&amp;,const thrust::host_vector&lt;real_type&gt;&amp;,const aRealTopology2d&lt;real_type&gt;&amp;,dg::bc,dg::bc)</a></code> (see there for more details) function and deterimens what happens when the endpoint of the fieldline integration leaves the domain boundaries of <code>grid</code>. Note that <code>bcx</code> and <code>grid.bcx()</code> have to be either both periodic or both not periodic. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Note that if <code>grid.bcz()==<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code> this parameter is ignored, Default is a limiter everywhere)</td></tr>
    <tr><td class="paramname">dir</td><td>indicate the direction in the bracket operator and in symv</td></tr>
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">mx</td><td>refinement factor in X of the fine grid relative to grid (Set to 1, if the x-component of <code>vec</code> vanishes, else as high as possible, 10 is a good start) </td></tr>
    <tr><td class="paramname">my</td><td>analogous to <code>mx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>Is either &lt;0 (then it's ignored), or may differ from <code>grid.hz()</code> if <code>grid.Nz()==1</code>, then <code>deltaPhi</code> is taken instead of <code>grid.hz()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> </dd></dl>

</div>
</div>
<a id="a7f0f9a42762ff9f75c03086b0b3fa708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0f9a42762ff9f75c03086b0b3fa708">&#9670;&nbsp;</a></span>DS() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::<a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a>&#160;</td>
          <td class="paramname"><em>fieldaligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldaligned</td><td>this object will be used in all further member calls</td></tr>
    <tr><td class="paramname">dir</td><td>indicate the direction in the bracket operator and in symv </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0ec3cea560d6cbbafd6a229deeef6036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec3cea560d6cbbafd6a229deeef6036">&#9670;&nbsp;</a></span>backward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::backward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward derivative \( g = \vec v \cdot \nabla f \) </p>
<p>backward derivative \( g_i = \frac{1}{h_z^-}(f_{i} - f_{i-1}) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a515d0bfa7ff3e56ddd7073f94e00d821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515d0bfa7ff3e56ddd7073f94e00d821">&#9670;&nbsp;</a></span>backward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::backward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>backward derivative \( g_i = \alpha \frac{1}{h_z^-}(f_{i} - f_{i-1}) + \beta g_i \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="ab9dd64e4aa948e9f6ff13a1f5970ddb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dd64e4aa948e9f6ff13a1f5970ddb4">&#9670;&nbsp;</a></span>centered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::centered </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered derivative \( g = \vec v \cdot \nabla f \) </p>
<p>The centered derivative is constructed by fitting a polynomial through the plus point the minus point and the center point and evaluating its derivative at the center point. For the exact resulting formula consult the <a href="./parallel.pdf" target="_blank">parallel derivative</a> writeup</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="acb890f75e68957fdbc0f30953438e431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb890f75e68957fdbc0f30953438e431">&#9670;&nbsp;</a></span>centered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::centered </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>The centered derivative is constructed by fitting a polynomial through the plus point the minus point and the center point and evaluating its derivative at the center point. For the exact resulting formula consult the <a href="./parallel.pdf" target="_blank">parallel derivative</a> writeup</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="aff0dac9a94313bf6d006c1e398d1e56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0dac9a94313bf6d006c1e398d1e56c">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a397b9c50490e4c721c488c3568e6a5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397b9c50490e4c721c488c3568e6a5c2">&#9670;&nbsp;</a></span>div() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::div </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \nabla \cdot ( \vec v f) \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a76f5b90b635b69bb0c5eacde3e3647a7" title="forward divergence">divForward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#af397aba8d43c37b88e1d85272d662d4d" title="backward divergence">divBackward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a64d5b30389cb32f6b624de430483ea54" title="centered divergence">divCentered()</a></code> </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>

</div>
</div>
<a id="ac5b4f28a8012eb265343f2fecb88a2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b4f28a8012eb265343f2fecb88a2f4">&#9670;&nbsp;</a></span>div() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::div </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \nabla \cdot( \vec v f) + \beta g \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a76f5b90b635b69bb0c5eacde3e3647a7" title="forward divergence">divForward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#af397aba8d43c37b88e1d85272d662d4d" title="backward divergence">divBackward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a64d5b30389cb32f6b624de430483ea54" title="centered divergence">divCentered()</a></code> </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>

</div>
</div>
<a id="a2a489bdafca25538c65ceba000a1fef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a489bdafca25538c65ceba000a1fef8">&#9670;&nbsp;</a></span>divBackward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divBackward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>
<dl class="section note"><dt>Note</dt><dd>divBackward is the negative adjoint of forward </dd></dl>

</div>
</div>
<a id="af397aba8d43c37b88e1d85272d662d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af397aba8d43c37b88e1d85272d662d4d">&#9670;&nbsp;</a></span>divBackward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divBackward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>
<dl class="section note"><dt>Note</dt><dd>divBackward is the negative adjoint of forward </dd></dl>

</div>
</div>
<a id="ad464d8ddfe153648575abf6e6ca0d91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad464d8ddfe153648575abf6e6ca0d91d">&#9670;&nbsp;</a></span>divCentered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divCentered </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>
<dl class="section note"><dt>Note</dt><dd>divCentered is the negative adjoint of centered </dd></dl>

</div>
</div>
<a id="a64d5b30389cb32f6b624de430483ea54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d5b30389cb32f6b624de430483ea54">&#9670;&nbsp;</a></span>divCentered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divCentered </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>
<dl class="section note"><dt>Note</dt><dd>divCentered is the negative adjoint of centered </dd></dl>

</div>
</div>
<a id="a6fa2b1fe16de8ec27c88ab6522367352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa2b1fe16de8ec27c88ab6522367352">&#9670;&nbsp;</a></span>divForward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divForward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>
<dl class="section note"><dt>Note</dt><dd>divForward is the negative adjoint of backward </dd></dl>

</div>
</div>
<a id="a76f5b90b635b69bb0c5eacde3e3647a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f5b90b635b69bb0c5eacde3e3647a7">&#9670;&nbsp;</a></span>divForward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::divForward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>
<dl class="section note"><dt>Note</dt><dd>divForward is the negative adjoint of backward </dd></dl>

</div>
</div>
<a id="a0a97e094e84673f71297df22a9bba4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a97e094e84673f71297df22a9bba4c5">&#9670;&nbsp;</a></span>ds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::ds </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \vec v\cdot \nabla f \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347" title="forward derivative">forward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821" title="backward derivative">backward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431" title="centered derivative">centered()</a></code> </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a3de32d878848eebdea7aee2d41b87a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de32d878848eebdea7aee2d41b87a27">&#9670;&nbsp;</a></span>ds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::ds </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347" title="forward derivative">forward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821" title="backward derivative">backward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431" title="centered derivative">centered()</a></code> </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="ac2adaf51aa28f332bb738d7c7a5fa149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2adaf51aa28f332bb738d7c7a5fa149">&#9670;&nbsp;</a></span>dss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::dss </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = (\vec v\cdot \nabla)^2 f \). </p>
<p>The formula used is </p><p class="formulaDsp">
\[ \nabla_\parallel^2 f = 2\left(\frac{f^+}{h_z^+ h_z^0} - \frac{f^0}{h_z^- h_z^+} + \frac{f^-}{h_z^-h_z^0}\right) \]
</p>
<p> which is the second derivative of a 2nd order polynomial fitted through the plus, minus and centre points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a37a968a4d343037e248a2f7458e15e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a968a4d343037e248a2f7458e15e4c">&#9670;&nbsp;</a></span>dss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::dss </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \). </p>
<p>The formula used is </p><p class="formulaDsp">
\[ \nabla_\parallel^2 f = 2\left(\frac{f^+}{h_z^+ h_z^0} - \frac{f^0}{h_z^- h_z^+} + \frac{f^-}{h_z^-h_z^0}\right) \]
</p>
<p> which is the second derivative of a 2nd order polynomial fitted through the plus, minus and centre points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a9be1d0b4cd476e4363097205eccf273a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be1d0b4cd476e4363097205eccf273a">&#9670;&nbsp;</a></span>fieldaligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdg_1_1geo_1_1_d_s.html#ac83f7ebb7593a8739c9ea0585cd7d0de">FA</a>&amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::fieldaligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the underlying <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object </p>
<dl class="section return"><dt>Returns</dt><dd>acces to <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object </dd></dl>

</div>
</div>
<a id="ae763e441ade3578a617e9df6aa97244b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae763e441ade3578a617e9df6aa97244b">&#9670;&nbsp;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward derivative \( g = \vec v \cdot \nabla f \) </p>
<p>forward derivative \( g_i = \frac{1}{h_z^+}(f_{i+1} - f_{i})\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a181d80e0ee9c46b0f17f4737b01c7347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181d80e0ee9c46b0f17f4737b01c7347">&#9670;&nbsp;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>forward derivative \( g_i = \alpha \frac{1}{h_z^+}(f_{i+1} - f_{i}) + \beta g_i\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="ad48b9432470a8e5de58bca0fbad12b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48b9432470a8e5de58bca0fbad12b3c">&#9670;&nbsp;</a></span>inv_weights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container&amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::inv_weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f09906879fa12715b82ce80013f62ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f09906879fa12715b82ce80013f62ad">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \vec v\cdot \nabla f \). </p>
<p>dependent on dir given in constructor redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347" title="forward derivative">forward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821" title="backward derivative">backward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431" title="centered derivative">centered()</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a6e4ff8ce9d41c92ca5d8ef2dcae6dff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4ff8ce9d41c92ca5d8ef2dcae6dff3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \). </p>
<p>dependent on dir given in constructor redirects to either <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a181d80e0ee9c46b0f17f4737b01c7347" title="forward derivative">forward()</a></code>, <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#a515d0bfa7ff3e56ddd7073f94e00d821" title="backward derivative">backward()</a></code> or <code><a class="el" href="structdg_1_1geo_1_1_d_s.html#acb890f75e68957fdbc0f30953438e431" title="centered derivative">centered()</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor </dd></dl>

</div>
</div>
<a id="a6e60e008773654113c1fab1bd3a279c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e60e008773654113c1fab1bd3a279c7">&#9670;&nbsp;</a></span>precond()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container&amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::precond </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02f14efeac450de2c7d109e20e1f1382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f14efeac450de2c7d109e20e1f1382">&#9670;&nbsp;</a></span>set_boundaries() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scal_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">global</td><td>3D vector containing boundary values </td></tr>
    <tr><td class="paramname">scal_left</td><td>left scaling factor </td></tr>
    <tr><td class="paramname">scal_right</td><td>right scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0897218b8eeb3bfdc70a1e2e3e912d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0897218b8eeb3bfdc70a1e2e3e912d76">&#9670;&nbsp;</a></span>set_boundaries() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>spatially variable left boundary value (2d size) </td></tr>
    <tr><td class="paramname">right</td><td>spatially variable right boundary value (2d size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a100b598ea427067b6e24885965e2a118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100b598ea427067b6e24885965e2a118">&#9670;&nbsp;</a></span>set_boundaries() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region. </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>constant left boundary value </td></tr>
    <tr><td class="paramname">right</td><td>constant right boundary value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a889a9a97c8c2c94308f2936a8753f490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889a9a97c8c2c94308f2936a8753f490">&#9670;&nbsp;</a></span>set_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::set_direction </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a>&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the direction used in the operator() and symv member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>new direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cd682b8f6e2d7b6eab4853ed5a55310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd682b8f6e2d7b6eab4853ed5a55310">&#9670;&nbsp;</a></span>symv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::symv </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \nabla\cdot ( \vec v \vec v \cdot \nabla f )\). </p>
<p>If direction given in constructor is centered then centered followed by divCentered and adding jump terms is called, else a symmetric forward/backward discretization is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>

</div>
</div>
<a id="acb6b31544057e833d0efbb6c79ca853e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6b31544057e833d0efbb6c79ca853e">&#9670;&nbsp;</a></span>symv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::symv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \nabla\cdot ( \vec v \vec v \cdot \nabla f ) + \beta g\) as a symmetric matrix. </p>
<p>if direction given in constructor is centered then centered followed by divCentered and adding jump terms is called, else a symmetric forward/backward discretization is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (write only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <code>div</code> and <code>symv</code> member functions reliably converge only if fieldlines do not(!) intersect the boundary and then only if the <code>mx</code> and <code>my</code> parameters are sufficiently high </dd></dl>

</div>
</div>
<a id="a186161681f43813d2036347e0b7efa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186161681f43813d2036347e0b7efa17">&#9670;&nbsp;</a></span>weights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class Matrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container&amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, Matrix, container &gt;::weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ds_8h_source.html">ds.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3"><div class="ttname"><a href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></div><div class="ttdeci">PER</div></div>
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10"><div class="ttname"><a href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></div><div class="ttdeci">NEU</div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_fieldaligned_html"><div class="ttname"><a href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a></div><div class="ttdoc">Create and manage interpolation matrices from fieldline integration.</div><div class="ttdef"><b>Definition:</b> fieldaligned.h:225</div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_tokamak_magnetic_field_html"><div class="ttname"><a href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a></div><div class="ttdoc">A tokamak field as given by R0, Psi and Ipol plus Meta-data like shape and equilibrium.</div><div class="ttdef"><b>Definition:</b> magnetic_field.h:161</div></div>
<div class="ttc" id="astructdg_1_1_z_e_r_o_html"><div class="ttname"><a href="../../dg/html/structdg_1_1_z_e_r_o.html">dg::ZERO</a></div></div>
<div class="ttc" id="agroup__magnetic_html_ga6182dc55424bffffb0d9876b9f90222d"><div class="ttname"><a href="group__magnetic.html#ga6182dc55424bffffb0d9876b9f90222d">dg::geo::createBHat</a></div><div class="ttdeci">CylindricalVectorLvl0 createBHat(const TokamakMagneticField &amp;mag)</div><div class="ttdoc">Contravariant components of the magnetic unit vector field in cylindrical coordinates.</div><div class="ttdef"><b>Definition:</b> magnetic_field.h:731</div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_d_s_html"><div class="ttname"><a href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a></div><div class="ttdoc">Class for the evaluation of parallel derivatives.</div><div class="ttdef"><b>Definition:</b> ds.h:259</div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_d_s_html_a0a97e094e84673f71297df22a9bba4c5"><div class="ttname"><a href="structdg_1_1geo_1_1_d_s.html#a0a97e094e84673f71297df22a9bba4c5">dg::geo::DS::ds</a></div><div class="ttdeci">void ds(dg::direction dir, const container &amp;f, container &amp;g)</div><div class="ttdoc">Discretizes .</div><div class="ttdef"><b>Definition:</b> ds.h:472</div></div>
<div class="ttc" id="agroup__creation_html_ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df"><div class="ttname"><a href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></div><div class="ttdeci">centered</div></div>
<div class="ttc" id="agroup__toroidal_html_ga16471692288263e2076b897dae16799f"><div class="ttname"><a href="group__toroidal.html#ga16471692288263e2076b897dae16799f">dg::geo::createCircularField</a></div><div class="ttdeci">static dg::geo::TokamakMagneticField createCircularField(double R0, double I0)</div><div class="ttdoc">Create a Magnetic field with circular flux surfaces and constant current.</div><div class="ttdef"><b>Definition:</b> toroidal.h:123</div></div>
<div class="ttc" id="astructdg_1_1_real_cylindrical_grid3d_html"><div class="ttname"><a href="../../dg/html/structdg_1_1_real_cylindrical_grid3d.html">dg::RealCylindricalGrid3d</a></div></div>
<div class="ttc" id="astructdg_1_1geo_1_1_cylindrical_vector_lvl0_html"><div class="ttname"><a href="structdg_1_1geo_1_1_cylindrical_vector_lvl0.html">dg::geo::CylindricalVectorLvl0</a></div><div class="ttdef"><b>Definition:</b> fluxfunctions.h:403</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="namespacedg_1_1geo.html">geo</a></li><li class="navelem"><a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a></li>
    <li class="footer">Generated on Tue Feb 23 2021 15:27:19 for Extension: Geometries by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
