<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: dg::BijectiveComm&lt; Index, Vector &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structdg_1_1_bijective_comm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_bijective_comm-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::BijectiveComm&lt; Index, Vector &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__backend.html">Level 1: Vectors, Matrices and basic operations</a> &raquo; <a class="el" href="group__mpi__structures.html">MPI backend</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Perform bijective gather and its transpose (scatter) operation across processes on distributed vectors using mpi.  
 <a href="structdg_1_1_bijective_comm.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for dg::BijectiveComm&lt; Index, Vector &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structdg_1_1_bijective_comm__inherit__graph.svg" width="155" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ae489e5157a1aae7b07b4871d715ea4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_bijective_comm.html#a6ae489e5157a1aae7b07b4871d715ea4">BijectiveComm</a> ()</td></tr>
<tr class="memdesc:a6ae489e5157a1aae7b07b4871d715ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">no memory allocation; size 0  <a href="structdg_1_1_bijective_comm.html#a6ae489e5157a1aae7b07b4871d715ea4">More...</a><br /></td></tr>
<tr class="separator:a6ae489e5157a1aae7b07b4871d715ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2caf023a7c9fd5c743f6f1d1d7fa04c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_bijective_comm.html#ac2caf023a7c9fd5c743f6f1d1d7fa04c">BijectiveComm</a> (const thrust::host_vector&lt; int &gt; &amp;pids, MPI_Comm comm)</td></tr>
<tr class="memdesc:ac2caf023a7c9fd5c743f6f1d1d7fa04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a given scatter map with respect to the source/data vector.  <a href="structdg_1_1_bijective_comm.html#ac2caf023a7c9fd5c743f6f1d1d7fa04c">More...</a><br /></td></tr>
<tr class="separator:ac2caf023a7c9fd5c743f6f1d1d7fa04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45309d36d7087af6eec752ec6a8506c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_bijective_comm.html#ae45309d36d7087af6eec752ec6a8506c">BijectiveComm</a> (unsigned <a class="el" href="structdg_1_1a_communicator.html#a190bc7d049ea3aaea0d1f50ff9f86f4b">local_size</a>, thrust::host_vector&lt; int &gt; localGatherMap, thrust::host_vector&lt; int &gt; pidGatherMap, MPI_Comm comm)</td></tr>
<tr class="memdesc:ae45309d36d7087af6eec752ec6a8506c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from local indices and PIDs gather map.  <a href="structdg_1_1_bijective_comm.html#ae45309d36d7087af6eec752ec6a8506c">More...</a><br /></td></tr>
<tr class="separator:ae45309d36d7087af6eec752ec6a8506c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5535fdb5170535612f7efdd89332251a"><td class="memTemplParams" colspan="2">template&lt;class ConversionPolicy &gt; </td></tr>
<tr class="memitem:a5535fdb5170535612f7efdd89332251a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_bijective_comm.html#a5535fdb5170535612f7efdd89332251a">BijectiveComm</a> (const thrust::host_vector&lt; int &gt; &amp;globalGatherMap, const ConversionPolicy &amp;p)</td></tr>
<tr class="memdesc:a5535fdb5170535612f7efdd89332251a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from global indices gather map.  <a href="structdg_1_1_bijective_comm.html#a5535fdb5170535612f7efdd89332251a">More...</a><br /></td></tr>
<tr class="separator:a5535fdb5170535612f7efdd89332251a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8f270119b1bd28c43ac178df23f679"><td class="memTemplParams" colspan="2">template&lt;class OtherIndex , class OtherVector &gt; </td></tr>
<tr class="memitem:a6f8f270119b1bd28c43ac178df23f679"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_bijective_comm.html#a6f8f270119b1bd28c43ac178df23f679">BijectiveComm</a> (const <a class="el" href="structdg_1_1_bijective_comm.html">BijectiveComm</a>&lt; OtherIndex, OtherVector &gt; &amp;src)</td></tr>
<tr class="memdesc:a6f8f270119b1bd28c43ac178df23f679"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct from another type; if src is empty, same as default constructor  <a href="structdg_1_1_bijective_comm.html#a6f8f270119b1bd28c43ac178df23f679">More...</a><br /></td></tr>
<tr class="separator:a6f8f270119b1bd28c43ac178df23f679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012aaef1fbac290dedb021dc280376b2"><td class="memItemLeft" align="right" valign="top">const thrust::host_vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_bijective_comm.html#a012aaef1fbac290dedb021dc280376b2">get_pids</a> () const</td></tr>
<tr class="memdesc:a012aaef1fbac290dedb021dc280376b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the pids that were given in the Constructor.  <a href="structdg_1_1_bijective_comm.html#a012aaef1fbac290dedb021dc280376b2">More...</a><br /></td></tr>
<tr class="separator:a012aaef1fbac290dedb021dc280376b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71f27a0610e8a9fee136b283a2d7d2e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structdg_1_1_bijective_comm.html">BijectiveComm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_bijective_comm.html#ae71f27a0610e8a9fee136b283a2d7d2e">clone</a> () const override final</td></tr>
<tr class="memdesc:ae71f27a0610e8a9fee136b283a2d7d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic copy method.  <a href="structdg_1_1_bijective_comm.html#ae71f27a0610e8a9fee136b283a2d7d2e">More...</a><br /></td></tr>
<tr class="separator:ae71f27a0610e8a9fee136b283a2d7d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structdg_1_1a_communicator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structdg_1_1a_communicator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator&lt; Vector &gt;</a></td></tr>
<tr class="memitem:a9a29bf560157c2d0a81d4ce96b1a0634 inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a9a29bf560157c2d0a81d4ce96b1a0634">allocate_buffer</a> () const</td></tr>
<tr class="memdesc:a9a29bf560157c2d0a81d4ce96b1a0634 inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer object of size <code><a class="el" href="structdg_1_1a_communicator.html#a7c0b8733751b2b82449a54676e4f0397" title="The local size of the buffer vector w = local map size.">buffer_size()</a></code>  <a href="structdg_1_1a_communicator.html#a9a29bf560157c2d0a81d4ce96b1a0634">More...</a><br /></td></tr>
<tr class="separator:a9a29bf560157c2d0a81d4ce96b1a0634 inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4afb767c3d62c1908eed2c4eb156a7 inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a0d4afb767c3d62c1908eed2c4eb156a7">global_gather</a> (const <a class="el" href="structdg_1_1a_communicator.html#a6b3761c8938941ad409b0e5ae8f396ba">value_type</a> *values, Vector &amp;buffer) const</td></tr>
<tr class="memdesc:a0d4afb767c3d62c1908eed2c4eb156a7 inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( w = G v\). Globally (across processes) gather data into a buffer  <a href="structdg_1_1a_communicator.html#a0d4afb767c3d62c1908eed2c4eb156a7">More...</a><br /></td></tr>
<tr class="separator:a0d4afb767c3d62c1908eed2c4eb156a7 inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977b6a58f608dc19041bb2a1f310ba3a inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a977b6a58f608dc19041bb2a1f310ba3a">global_gather</a> (const <a class="el" href="structdg_1_1a_communicator.html#a6b3761c8938941ad409b0e5ae8f396ba">value_type</a> *values) const</td></tr>
<tr class="memdesc:a977b6a58f608dc19041bb2a1f310ba3a inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( w = G v\). Globally (across processes) gather data into a buffer (memory allocating version)  <a href="structdg_1_1a_communicator.html#a977b6a58f608dc19041bb2a1f310ba3a">More...</a><br /></td></tr>
<tr class="separator:a977b6a58f608dc19041bb2a1f310ba3a inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342c5ad30f218eb1e2588369aae72fd2 inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a342c5ad30f218eb1e2588369aae72fd2">global_scatter_reduce</a> (const Vector &amp;toScatter, <a class="el" href="structdg_1_1a_communicator.html#a6b3761c8938941ad409b0e5ae8f396ba">value_type</a> *values) const</td></tr>
<tr class="memdesc:a342c5ad30f218eb1e2588369aae72fd2 inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( v = G^\mathrm{T} w\). Globally (across processes) scatter data accross processes and reduce on multiple indices  <a href="structdg_1_1a_communicator.html#a342c5ad30f218eb1e2588369aae72fd2">More...</a><br /></td></tr>
<tr class="separator:a342c5ad30f218eb1e2588369aae72fd2 inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0b8733751b2b82449a54676e4f0397 inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a7c0b8733751b2b82449a54676e4f0397">buffer_size</a> () const</td></tr>
<tr class="memdesc:a7c0b8733751b2b82449a54676e4f0397 inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local size of the buffer vector w = local map size.  <a href="structdg_1_1a_communicator.html#a7c0b8733751b2b82449a54676e4f0397">More...</a><br /></td></tr>
<tr class="separator:a7c0b8733751b2b82449a54676e4f0397 inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190bc7d049ea3aaea0d1f50ff9f86f4b inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a190bc7d049ea3aaea0d1f50ff9f86f4b">local_size</a> () const</td></tr>
<tr class="memdesc:a190bc7d049ea3aaea0d1f50ff9f86f4b inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local size of the source vector v = local size of the <code><a class="el" href="structdg_1_1_m_p_i___vector.html" title="mpi Vector class">dg::MPI_Vector</a></code>.  <a href="structdg_1_1a_communicator.html#a190bc7d049ea3aaea0d1f50ff9f86f4b">More...</a><br /></td></tr>
<tr class="separator:a190bc7d049ea3aaea0d1f50ff9f86f4b inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6da46a52184be235645f0194f22cdd2 inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#ab6da46a52184be235645f0194f22cdd2">isCommunicating</a> () const</td></tr>
<tr class="memdesc:ab6da46a52184be235645f0194f22cdd2 inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the gather/scatter operation involves actual MPI communication.  <a href="structdg_1_1a_communicator.html#ab6da46a52184be235645f0194f22cdd2">More...</a><br /></td></tr>
<tr class="separator:ab6da46a52184be235645f0194f22cdd2 inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc738661d96a4d926541c14fd28723c6 inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#acc738661d96a4d926541c14fd28723c6">communicator</a> () const</td></tr>
<tr class="memdesc:acc738661d96a4d926541c14fd28723c6 inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal MPI communicator used.  <a href="structdg_1_1a_communicator.html#acc738661d96a4d926541c14fd28723c6">More...</a><br /></td></tr>
<tr class="separator:acc738661d96a4d926541c14fd28723c6 inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb505e6ee0a7f9119cfdfcba059f7f12 inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#aeb505e6ee0a7f9119cfdfcba059f7f12">clone</a> () const=0</td></tr>
<tr class="memdesc:aeb505e6ee0a7f9119cfdfcba059f7f12 inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic copy method.  <a href="structdg_1_1a_communicator.html#aeb505e6ee0a7f9119cfdfcba059f7f12">More...</a><br /></td></tr>
<tr class="separator:aeb505e6ee0a7f9119cfdfcba059f7f12 inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94374e74e4a9a7857f65de3a5e64ba37 inherit pub_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a94374e74e4a9a7857f65de3a5e64ba37">~aCommunicator</a> ()</td></tr>
<tr class="memdesc:a94374e74e4a9a7857f65de3a5e64ba37 inherit pub_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">vritual destructor  <a href="structdg_1_1a_communicator.html#a94374e74e4a9a7857f65de3a5e64ba37">More...</a><br /></td></tr>
<tr class="separator:a94374e74e4a9a7857f65de3a5e64ba37 inherit pub_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_structdg_1_1a_communicator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structdg_1_1a_communicator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator&lt; Vector &gt;</a></td></tr>
<tr class="memitem:a6b3761c8938941ad409b0e5ae8f396ba inherit pub_types_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a6b3761c8938941ad409b0e5ae8f396ba">value_type</a> = <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; Vector &gt;</td></tr>
<tr class="memdesc:a6b3761c8938941ad409b0e5ae8f396ba inherit pub_types_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">reveal value type  <a href="structdg_1_1a_communicator.html#a6b3761c8938941ad409b0e5ae8f396ba">More...</a><br /></td></tr>
<tr class="separator:a6b3761c8938941ad409b0e5ae8f396ba inherit pub_types_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edbb00e9845d00160d9aa75c9bd80da inherit pub_types_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a5edbb00e9845d00160d9aa75c9bd80da">container_type</a> = Vector</td></tr>
<tr class="memdesc:a5edbb00e9845d00160d9aa75c9bd80da inherit pub_types_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">reveal local container type  <a href="structdg_1_1a_communicator.html#a5edbb00e9845d00160d9aa75c9bd80da">More...</a><br /></td></tr>
<tr class="separator:a5edbb00e9845d00160d9aa75c9bd80da inherit pub_types_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_structdg_1_1a_communicator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_structdg_1_1a_communicator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator&lt; Vector &gt;</a></td></tr>
<tr class="memitem:af7d649518836cb8d29e7abbeb530abc9 inherit pro_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#af7d649518836cb8d29e7abbeb530abc9">aCommunicator</a> (unsigned <a class="el" href="structdg_1_1a_communicator.html#a190bc7d049ea3aaea0d1f50ff9f86f4b">local_size</a>=0)</td></tr>
<tr class="memdesc:af7d649518836cb8d29e7abbeb530abc9 inherit pro_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">only derived classes can construct  <a href="structdg_1_1a_communicator.html#af7d649518836cb8d29e7abbeb530abc9">More...</a><br /></td></tr>
<tr class="separator:af7d649518836cb8d29e7abbeb530abc9 inherit pro_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2861411ab00b8988436cf0259edbbc1b inherit pro_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a2861411ab00b8988436cf0259edbbc1b">aCommunicator</a> (const <a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> &amp;src)</td></tr>
<tr class="memdesc:a2861411ab00b8988436cf0259edbbc1b inherit pro_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">only derived classes can copy  <a href="structdg_1_1a_communicator.html#a2861411ab00b8988436cf0259edbbc1b">More...</a><br /></td></tr>
<tr class="separator:a2861411ab00b8988436cf0259edbbc1b inherit pro_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141c1eead2eba27e720b3a51f0ae3c38 inherit pro_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a141c1eead2eba27e720b3a51f0ae3c38">operator=</a> (const <a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> &amp;src)</td></tr>
<tr class="memdesc:a141c1eead2eba27e720b3a51f0ae3c38 inherit pro_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">only derived classes can assign  <a href="structdg_1_1a_communicator.html#a141c1eead2eba27e720b3a51f0ae3c38">More...</a><br /></td></tr>
<tr class="separator:a141c1eead2eba27e720b3a51f0ae3c38 inherit pro_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcacc78e5bdce668b052adf1a9e1169 inherit pro_methods_structdg_1_1a_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a8bcacc78e5bdce668b052adf1a9e1169">set_local_size</a> (unsigned new_size)</td></tr>
<tr class="memdesc:a8bcacc78e5bdce668b052adf1a9e1169 inherit pro_methods_structdg_1_1a_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local size of the source vector v.  <a href="structdg_1_1a_communicator.html#a8bcacc78e5bdce668b052adf1a9e1169">More...</a><br /></td></tr>
<tr class="separator:a8bcacc78e5bdce668b052adf1a9e1169 inherit pro_methods_structdg_1_1a_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Index, class Vector&gt;<br />
struct dg::BijectiveComm&lt; Index, Vector &gt;</div><p >Perform bijective gather and its transpose (scatter) operation across processes on distributed vectors using mpi. </p>
<p >If the gather map idx[i] is bijective, each element of the source vector v maps to exactly one location in the buffer vector w. In this case the scatter matrix S is the inverse of G. (see <code><a class="el" href="structdg_1_1a_communicator.html" title="Struct that performs collective scatter and gather operations across processes on distributed vectors...">aCommunicator</a></code> for more details) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = myrank;</div>
<div class="line"><span class="keywordtype">double</span> values[8] = {i,i,i,i, 9,9,9,9};</div>
<div class="line">thrust::host_vector&lt;double&gt; hvalues( values, values+8);</div>
<div class="line"><span class="keywordtype">int</span> pids[8] =      {0,1,2,3, 0,1,2,3};</div>
<div class="line">thrust::host_vector&lt;int&gt; hpids( pids, pids+8);</div>
<div class="line"><a class="code hl_function" href="structdg_1_1_bijective_comm.html#a6ae489e5157a1aae7b07b4871d715ea4">BijectiveComm</a> coll( hpids, MPI_COMM_WORLD);</div>
<div class="line">thrust::host_vector&lt;double&gt; hrecv = coll.global_gather( hvalues); <span class="comment">//for e.g. process 0 hrecv is now {0,9,1,9,2,9,3,9}</span></div>
<div class="line">thrust::host_vector&lt;double&gt; hrecv2( hvalues.size());</div>
<div class="line">coll.global_scatter_reduce( hrecv, hrecv2); <span class="comment">//hrecv2 now equals hvalues independent of process rank</span></div>
<div class="ttc" id="astructdg_1_1_bijective_comm_html_a6ae489e5157a1aae7b07b4871d715ea4"><div class="ttname"><a href="structdg_1_1_bijective_comm.html#a6ae489e5157a1aae7b07b4871d715ea4">dg::BijectiveComm::BijectiveComm</a></div><div class="ttdeci">BijectiveComm()</div><div class="ttdoc">no memory allocation; size 0</div><div class="ttdef"><b>Definition:</b> mpi_collective.h:212</div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>an integer thrust Vector </td></tr>
    <tr><td class="paramname">Vector</td><td>a thrust Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a scatter followed by a gather of the received values restores the original array </dd>
<dd>
The order of the received elements is according to their original array index (i.e. a[0] appears before a[1]) and their process rank of origin ( i.e. values from rank 0 appear before values from rank 1) </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ae489e5157a1aae7b07b4871d715ea4" name="a6ae489e5157a1aae7b07b4871d715ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae489e5157a1aae7b07b4871d715ea4">&#9670;&nbsp;</a></span>BijectiveComm() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_bijective_comm.html">dg::BijectiveComm</a>&lt; Index, Vector &gt;::BijectiveComm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>no memory allocation; size 0 </p>

</div>
</div>
<a id="ac2caf023a7c9fd5c743f6f1d1d7fa04c" name="ac2caf023a7c9fd5c743f6f1d1d7fa04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2caf023a7c9fd5c743f6f1d1d7fa04c">&#9670;&nbsp;</a></span>BijectiveComm() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_bijective_comm.html">dg::BijectiveComm</a>&lt; Index, Vector &gt;::BijectiveComm </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a given scatter map with respect to the source/data vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pids</td><td>Gives to every index i of the values/data vector (not the buffer vector!) the rank pids[i] to which to send the data element data[i]. The rank pids[i] needs to be element of the given communicator. </td></tr>
    <tr><td class="paramname">comm</td><td>An MPI Communicator that contains the participants of the scatter/gather </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The actual scatter/gather map is constructed from the given map so the result behaves as if pids was the actual scatter/gather map on the buffer </dd></dl>

</div>
</div>
<a id="ae45309d36d7087af6eec752ec6a8506c" name="ae45309d36d7087af6eec752ec6a8506c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45309d36d7087af6eec752ec6a8506c">&#9670;&nbsp;</a></span>BijectiveComm() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_bijective_comm.html">dg::BijectiveComm</a>&lt; Index, Vector &gt;::BijectiveComm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>local_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thrust::host_vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>localGatherMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thrust::host_vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>pidGatherMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from local indices and PIDs gather map. </p>
<p >The indices in the gather map are written with respect to the buffer vector. Each location in the source vector is uniquely specified by a local vector index and the process rank. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_size</td><td>local size of a <code><a class="el" href="structdg_1_1_m_p_i___vector.html" title="mpi Vector class">dg::MPI_Vector</a></code> (same for all processes) </td></tr>
    <tr><td class="paramname">localGatherMap</td><td>Each element <code>localGatherMap</code>[i] represents a local vector index from where to gather the value. There are "local buffer size" elements. </td></tr>
    <tr><td class="paramname">pidGatherMap</td><td>Each element <code>pidGatherMap</code>[i] represents the pid/rank from where to gather the corresponding local index <code>localGatherMap</code>[i]. Same size as localGatherMap. The pid/rank needs to be element of the given communicator. </td></tr>
    <tr><td class="paramname">comm</td><td>The MPI communicator participating in the scatter/gather operations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>we assume that the gather map is bijective </dd></dl>

</div>
</div>
<a id="a5535fdb5170535612f7efdd89332251a" name="a5535fdb5170535612f7efdd89332251a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5535fdb5170535612f7efdd89332251a">&#9670;&nbsp;</a></span>BijectiveComm() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Vector &gt; </div>
<div class="memtemplate">
template&lt;class ConversionPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_bijective_comm.html">dg::BijectiveComm</a>&lt; Index, Vector &gt;::BijectiveComm </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>globalGatherMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConversionPolicy &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from global indices gather map. </p>
<p >Uses the <code>global2localIdx()</code> member of MPITopology to generate localGatherMap and pidGatherMap </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConversionPolicy</td><td>has to have the members:<ul>
<li><code>bool<code>global2localIdx(unsigned,unsigned&amp;,unsigned&amp;)</code> <code>const</code>;</code> where the first parameter is the global index and the other two are the output pair (localIdx, rank). return true if successful, false if global index is not part of the grid</li>
<li><code>MPI_Comm</code> <code>communicator</code>() <code>const</code>; returns the communicator to use in the gather/scatter</li>
<li><code><a class="el" href="structdg_1_1a_communicator.html#a190bc7d049ea3aaea0d1f50ff9f86f4b" title="The local size of the source vector v = local size of the dg::MPI_Vector.">local_size()</a></code>; return the local vector size </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalGatherMap</td><td>Each element <code>globalGatherMap</code>[i] represents a global vector index from where to take the value. There are "local buffer size == size()" elements. </td></tr>
    <tr><td class="paramname">p</td><td>the conversion object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__basictopology.html">Topology base classes</a> the MPI grids defined in Level 3 can all be used as a ConversionPolicy </dd></dl>
<dl class="section note"><dt>Note</dt><dd>we assume that the gather map is bijective </dd></dl>

</div>
</div>
<a id="a6f8f270119b1bd28c43ac178df23f679" name="a6f8f270119b1bd28c43ac178df23f679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8f270119b1bd28c43ac178df23f679">&#9670;&nbsp;</a></span>BijectiveComm() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Vector &gt; </div>
<div class="memtemplate">
template&lt;class OtherIndex , class OtherVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_bijective_comm.html">dg::BijectiveComm</a>&lt; Index, Vector &gt;::BijectiveComm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_bijective_comm.html">BijectiveComm</a>&lt; OtherIndex, OtherVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reconstruct from another type; if src is empty, same as default constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae71f27a0610e8a9fee136b283a2d7d2e" name="ae71f27a0610e8a9fee136b283a2d7d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71f27a0610e8a9fee136b283a2d7d2e">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structdg_1_1_bijective_comm.html">BijectiveComm</a> * <a class="el" href="structdg_1_1_bijective_comm.html">dg::BijectiveComm</a>&lt; Index, Vector &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic copy method. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated object </dd></dl>

<p>Implements <a class="el" href="structdg_1_1a_communicator.html#aeb505e6ee0a7f9119cfdfcba059f7f12">dg::aCommunicator&lt; Vector &gt;</a>.</p>

</div>
</div>
<a id="a012aaef1fbac290dedb021dc280376b2" name="a012aaef1fbac290dedb021dc280376b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012aaef1fbac290dedb021dc280376b2">&#9670;&nbsp;</a></span>get_pids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const thrust::host_vector&lt; int &gt; &amp; <a class="el" href="structdg_1_1_bijective_comm.html">dg::BijectiveComm</a>&lt; Index, Vector &gt;::get_pids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are the pids that were given in the Constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector given in the constructor </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>backend/<a class="el" href="mpi__collective_8h_source.html">mpi_collective.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_bijective_comm.html">BijectiveComm</a></li>
    <li class="footer">Generated on Fri Jan 14 2022 13:22:08 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
