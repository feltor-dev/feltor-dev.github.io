<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Discontinuous Galerkin Library: BLAS level 2 routines: Matrix-Vector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Container free algorithms and discontinuous Galerkin numerical methods in &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__blas2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BLAS level 2 routines: Matrix-Vector<div class="ingroups"><a class="el" href="group__backend.html">Level 1: Vectors, Matrices and basic operations</a> &raquo; <a class="el" href="group__blas.html">Basic container independent subroutines</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>\( \alpha M \cdot x + \beta y\) and \( x^T M y \)  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for BLAS level 2 routines: Matrix-Vector:</div>
<div class="dyncontent">
<div class="center"><img src="group__blas2.png" border="0" usemap="#group____blas2" alt=""/></div>
<map name="group____blas2" id="group____blas2">
<area shape="rect" title="and" alt="" coords="260,5,421,45"/>
<area shape="rect" href="group__blas.html" title=" " alt="" coords="5,5,212,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedg_1_1blas2"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1blas2.html">dg::blas2</a></td></tr>
<tr class="memdesc:namespacedg_1_1blas2"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 2 routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaafba91956e948b0ea53f30889a3c20d"><td class="memTemplParams" colspan="2">template&lt;class ContainerType1 , class MatrixType , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gaaafba91956e948b0ea53f30889a3c20d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas2.html#gaaafba91956e948b0ea53f30889a3c20d">dg::blas2::dot</a> (const ContainerType1 &amp;x, const MatrixType &amp;m, const ContainerType2 &amp;y)</td></tr>
<tr class="memdesc:gaaafba91956e948b0ea53f30889a3c20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x^T M y\); Binary reproducible general dot product  <a href="group__blas2.html#gaaafba91956e948b0ea53f30889a3c20d">More...</a><br /></td></tr>
<tr class="separator:gaaafba91956e948b0ea53f30889a3c20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33daee0a61293b14d7bbe5cf901993d1"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType &gt; </td></tr>
<tr class="memitem:ga33daee0a61293b14d7bbe5cf901993d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas2.html#ga33daee0a61293b14d7bbe5cf901993d1">dg::blas2::dot</a> (const MatrixType &amp;m, const ContainerType &amp;x)</td></tr>
<tr class="memdesc:ga33daee0a61293b14d7bbe5cf901993d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x^T M x\); Binary reproducible general dot product  <a href="group__blas2.html#ga33daee0a61293b14d7bbe5cf901993d1">More...</a><br /></td></tr>
<tr class="separator:ga33daee0a61293b14d7bbe5cf901993d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bd2015d31362b25d61110f91cf3b0b9"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga9bd2015d31362b25d61110f91cf3b0b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas2.html#ga9bd2015d31362b25d61110f91cf3b0b9">dg::blas2::symv</a> (<a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType1 &gt; alpha, MatrixType &amp;&amp;M, const ContainerType1 &amp;x, <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType1 &gt; beta, ContainerType2 &amp;y)</td></tr>
<tr class="memdesc:ga9bd2015d31362b25d61110f91cf3b0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha M x + \beta y\)  <a href="group__blas2.html#ga9bd2015d31362b25d61110f91cf3b0b9">More...</a><br /></td></tr>
<tr class="separator:ga9bd2015d31362b25d61110f91cf3b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3840941bd2bb1d64c6ca3fef1f1b960"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gac3840941bd2bb1d64c6ca3fef1f1b960"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a> (MatrixType &amp;&amp;M, const ContainerType1 &amp;x, ContainerType2 &amp;y)</td></tr>
<tr class="memdesc:gac3840941bd2bb1d64c6ca3fef1f1b960"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = M x\)  <a href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">More...</a><br /></td></tr>
<tr class="separator:gac3840941bd2bb1d64c6ca3fef1f1b960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7e3b58697b6e93169eebbda63f3ed3"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga1b7e3b58697b6e93169eebbda63f3ed3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas2.html#ga1b7e3b58697b6e93169eebbda63f3ed3">dg::blas2::gemv</a> (<a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType1 &gt; alpha, MatrixType &amp;&amp;M, const ContainerType1 &amp;x, <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType1 &gt; beta, ContainerType2 &amp;y)</td></tr>
<tr class="memdesc:ga1b7e3b58697b6e93169eebbda63f3ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha M x + \beta y \); (alias for symv)  <a href="group__blas2.html#ga1b7e3b58697b6e93169eebbda63f3ed3">More...</a><br /></td></tr>
<tr class="separator:ga1b7e3b58697b6e93169eebbda63f3ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7f59acf79dc654da64ca7e8f212284"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga5f7f59acf79dc654da64ca7e8f212284"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas2.html#ga5f7f59acf79dc654da64ca7e8f212284">dg::blas2::gemv</a> (MatrixType &amp;&amp;M, const ContainerType1 &amp;x, ContainerType2 &amp;y)</td></tr>
<tr class="memdesc:ga5f7f59acf79dc654da64ca7e8f212284"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = M x\); (alias for symv)  <a href="group__blas2.html#ga5f7f59acf79dc654da64ca7e8f212284">More...</a><br /></td></tr>
<tr class="separator:ga5f7f59acf79dc654da64ca7e8f212284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53701ba3118a2256a93a4d92a7a8a597"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class AnotherMatrixType &gt; </td></tr>
<tr class="memitem:ga53701ba3118a2256a93a4d92a7a8a597"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597">dg::blas2::transfer</a> (const MatrixType &amp;x, AnotherMatrixType &amp;y)</td></tr>
<tr class="memdesc:ga53701ba3118a2256a93a4d92a7a8a597"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = x\); Generic way to copy and/or convert a Matrix type to a different Matrix type  <a href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597">More...</a><br /></td></tr>
<tr class="separator:ga53701ba3118a2256a93a4d92a7a8a597"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>\( \alpha M \cdot x + \beta y\) and \( x^T M y \) </p>
<p>Successive calls to blas routines are executed sequentially. A manual synchronization of threads or devices is never needed in an application using these functions. All functions returning a value block until the value is ready. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaafba91956e948b0ea53f30889a3c20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaafba91956e948b0ea53f30889a3c20d">&#9670;&nbsp;</a></span>dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType1 , class MatrixType , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt;MatrixType&gt; dg::blas2::dot </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x^T M y\); Binary reproducible general dot product </p>
<p>This routine computes the scalar product defined by the symmetric positive definite matrix M </p><p class="formulaDsp">
\[ x^T M y = \sum_{i,j=0}^{N-1} x_i M_{ij} y_j \]
</p>
<p>This code snippet demonstrates how to discretize and compute the norm of a function on a shared memory system </p><div class="fragment"><div class="line"><span class="comment">// define the function to integrate</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">function</span>(<span class="keywordtype">double</span> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, <span class="keywordtype">double</span> amp){</div>
<div class="line">    <span class="keywordflow">return</span> amp*exp(x)*exp(y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and 3 polynomial coefficients</span></div>
<div class="line"><a class="code" href="structdg_1_1_real_grid2d.html">dg::Grid2d</a> g2d( 0, 2, 0, 2, 3, 20, 20);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create the Gaussian weights (volume form) for the integration</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a> w2d = <a class="code" href="group__highlevel.html#ga771996962c7762bc7ee00b522a17259f">dg::create::weights</a>( g2d);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// our function needs to depend only on x and y so let&#39;s fix the amplitude to 2</span></div>
<div class="line"><span class="keyword">using namespace </span>std::placeholders; <span class="comment">//for _1, _2</span></div>
<div class="line"><span class="keyword">auto</span> functor = std::bind( <span class="keyword">function</span>, _1, _2, 2.);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// discretize the function on the grid</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a> vec = <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( functor, g2d);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// now compute the scalar product (the L2 norm)</span></div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">norm</a> = <a class="code" href="group__blas2.html#gaaafba91956e948b0ea53f30889a3c20d">dg::blas2::dot</a>( vec, w2d, vec);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// norm is now: (e^4-1)^2</span></div>
</div><!-- fragment --> <dl class="section attention"><dt>Attention</dt><dd>if one of the input vectors contains <code>Inf</code> or <code>NaN</code> or the product of the input numbers reaches <code>Inf</code> or <code>Nan</code> then the behaviour is undefined and the function may throw. See <a class="el" href="structdg_1_1_i_s_n_f_i_n_i_t_e.html">dg::ISNFINITE</a> and <a class="el" href="structdg_1_1_i_s_n_s_a_n_e.html">dg::ISNSANE</a> in that case </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Our implementation guarantees <b>binary reproducible</b> results up to and excluding the last mantissa bit of the result. Furthermore, the sum is computed with <b>infinite precision</b> and the result is then rounded to the nearest double precision number. Although the products are not computed with infinite precision, the order of multiplication is guaranteed. This is possible with the help of an adapted version of the <code><a class="elRef" href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></code> library and works for single and double precision.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left input </td></tr>
    <tr><td class="paramname">m</td><td>The diagonal Matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right input (may alias <code>x</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generalized scalar product. If <code>x</code> and <code>y</code> are vectors of containers and <code>m</code> is not, then we sum the results of <code>dg::blas2::dot( x[i], m, y[i])</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. With mpi the result is broadcasted to all processes. Also note that the behaviour is undefined when one of the containers contains <code>nan</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td><code>MatrixType</code> has to have a category derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and must be compatible with the <code>ContainerTypes</code> </td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; (vector of shared device vectors), std::array&lt;double, 4&gt; (array of 4 doubles)</code></li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga33daee0a61293b14d7bbe5cf901993d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33daee0a61293b14d7bbe5cf901993d1">&#9670;&nbsp;</a></span>dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt;MatrixType&gt; dg::blas2::dot </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x^T M x\); Binary reproducible general dot product </p>
<p>Equivalent to <code>dg::blas2::dot( x,m,x)</code> </p><p class="formulaDsp">
\[ x^T M x = \sum_{i,j=0}^{N-1} x_i M_{ij} x_j \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The diagonal Matrix </td></tr>
    <tr><td class="paramname">x</td><td>Right input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generalized scalar product. If <code>x</code> is a vector of containers and <code>m</code> is not, then we sum the results of <code>dg::blas2::dot( m, x[i])</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. </dd>
<dd>
This routine is equivalent to the call <code>dg::blas2::dot( x, m, x)</code>; which should be prefered because it looks more explicit </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td><code>MatrixType</code> has to have a category derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and must be compatible with the <code>ContainerTypes</code> </td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; (vector of shared device vectors), std::array&lt;double, 4&gt; (array of 4 doubles)</code></li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga1b7e3b58697b6e93169eebbda63f3ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b7e3b58697b6e93169eebbda63f3ed3">&#9670;&nbsp;</a></span>gemv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::gemv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType1 &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType1 &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha M x + \beta y \); (alias for symv) </p>
<p>Does exactly the same as symv. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>A Scalar </td></tr>
    <tr><td class="paramname">M</td><td>The Matrix. Note that if <code>x</code> and <code>y</code> have the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code> while <code>M</code> does not, then <code>M</code> is recursively applied to all <code>x</code>[i], <code>y</code>[i] </td></tr>
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">beta</td><td>A Scalar </td></tr>
    <tr><td class="paramname">y</td><td>contains the solution on output (may not alias <code>x</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code>y</code> may not alias <code>x</code>, the only exception is if <code>MatrixType</code> has the <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code>ContainerType1</code> ==<code>ContainerType2</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fullfills the requirements of the there defined Matrix tags derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html">AnyMatrixTag</a></code>. The <code>MatrixType</code> can for example be one of:<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga188bea19979cfa0701387bfc5272be79">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#gaab6ed0cbb6bf7ea723c10da88cd4529f">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
<li>In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code>symv( const ContainerType0&amp;, ContainerType1&amp;)</code>; ) can be called.</li>
</ul>
If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the <code>Matrix</code> is applied to each of the elements.</td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; (vector of shared device vectors), std::array&lt;double, 4&gt; (array of 4 doubles)</code></li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga5f7f59acf79dc654da64ca7e8f212284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f7f59acf79dc654da64ca7e8f212284">&#9670;&nbsp;</a></span>gemv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::gemv </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = M x\); (alias for symv) </p>
<p>Does exactly the same as symv. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The Matrix. Note that if <code>x</code> and <code>y</code> have the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code> while <code>M</code> does not, then <code>M</code> is recursively applied to all <code>x</code>[i], <code>y</code>[i] </td></tr>
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">y</td><td>contains the solution on output (may not alias <code>x</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code>y</code> may not alias <code>x</code>, the only exception is if <code>MatrixType</code> has the <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code>ContainerType1</code> ==<code>ContainerType2</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fullfills the requirements of the there defined Matrix tags derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html">AnyMatrixTag</a></code>. The <code>MatrixType</code> can for example be one of:<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga188bea19979cfa0701387bfc5272be79">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#gaab6ed0cbb6bf7ea723c10da88cd4529f">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
<li>In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code>symv( const ContainerType0&amp;, ContainerType1&amp;)</code>; ) can be called.</li>
</ul>
If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the <code>Matrix</code> is applied to each of the elements.</td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; (vector of shared device vectors), std::array&lt;double, 4&gt; (array of 4 doubles)</code></li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga9bd2015d31362b25d61110f91cf3b0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bd2015d31362b25d61110f91cf3b0b9">&#9670;&nbsp;</a></span>symv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::symv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType1 &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType1 &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha M x + \beta y\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ y = \alpha M x + \beta y \]
</p>
<p> where \( M\) is a matrix.</p>
<p>This code snippet demonstrates how to derive a function on a device </p><div class="fragment"><div class="line"><span class="comment">//define a function to derive</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">function</span>(<span class="keywordtype">double</span> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>){</div>
<div class="line">    <span class="keywordflow">return</span> sin(x)*sin(y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and 3 polynomial coefficients</span></div>
<div class="line"><a class="code" href="structdg_1_1_real_grid2d.html">dg::Grid2d</a> g2d( 0, 2, 0, 2, 3, 20, 20, <a class="code" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//declare a device matrix</span></div>
<div class="line"><a class="code" href="structdg_1_1_ell_sparse_block_mat_device.html">dg::DMatrix</a> <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//create the x derivative on the grid and transfer the matrix to the device</span></div>
<div class="line"><a class="code" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597">dg::blas2::transfer</a>( <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dg::create::dx</a>(g2d), <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//discretize the function on the grid and transfer the result to the device</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a> = dg::construct&lt;dg::DVec&gt;( <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g2d));</div>
<div class="line"> </div>
<div class="line"><span class="comment">//allocate memory for the result</span></div>
<div class="line"><a class="code" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>=<a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//apply the derivative to x and store result in y</span></div>
<div class="line"><a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(<a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>, x,y);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//or equivalently</span></div>
<div class="line"><a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(1., <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>, x, 0., y);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>A Scalar </td></tr>
    <tr><td class="paramname">M</td><td>The Matrix. Note that if <code>x</code> and <code>y</code> have the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code> while <code>M</code> does not, then <code>M</code> is recursively applied to all <code>x</code>[i], <code>y</code>[i] </td></tr>
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">beta</td><td>A Scalar </td></tr>
    <tr><td class="paramname">y</td><td>contains the solution on output (may not alias <code>x</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code>y</code> may not alias <code>x</code>, the only exception is if <code>MatrixType</code> has the <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fullfills the requirements of the there defined Matrix tags derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html">AnyMatrixTag</a></code>. The <code>MatrixType</code> can for example be one of:<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga188bea19979cfa0701387bfc5272be79">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#gaab6ed0cbb6bf7ea723c10da88cd4529f">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
<li>In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code>symv( const ContainerType0&amp;, ContainerType1&amp;)</code>; ) can be called.</li>
</ul>
If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the <code>Matrix</code> is applied to each of the elements.</td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; (vector of shared device vectors), std::array&lt;double, 4&gt; (array of 4 doubles)</code></li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="gac3840941bd2bb1d64c6ca3fef1f1b960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3840941bd2bb1d64c6ca3fef1f1b960">&#9670;&nbsp;</a></span>symv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::symv </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = M x\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ y = M x \]
</p>
<p> where \( M\) is a matrix.</p>
<p>This code snippet demonstrates how to derive a function on a device </p><div class="fragment"><div class="line"><span class="comment">//define a function to derive</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">function</span>(<span class="keywordtype">double</span> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>){</div>
<div class="line">    <span class="keywordflow">return</span> sin(x)*sin(y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and 3 polynomial coefficients</span></div>
<div class="line"><a class="code" href="structdg_1_1_real_grid2d.html">dg::Grid2d</a> g2d( 0, 2, 0, 2, 3, 20, 20, <a class="code" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//declare a device matrix</span></div>
<div class="line"><a class="code" href="structdg_1_1_ell_sparse_block_mat_device.html">dg::DMatrix</a> <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//create the x derivative on the grid and transfer the matrix to the device</span></div>
<div class="line"><a class="code" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597">dg::blas2::transfer</a>( <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dg::create::dx</a>(g2d), <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//discretize the function on the grid and transfer the result to the device</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a> = dg::construct&lt;dg::DVec&gt;( <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g2d));</div>
<div class="line"> </div>
<div class="line"><span class="comment">//allocate memory for the result</span></div>
<div class="line"><a class="code" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>=<a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//apply the derivative to x and store result in y</span></div>
<div class="line"><a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(<a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>, x,y);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//or equivalently</span></div>
<div class="line"><a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(1., <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>, x, 0., y);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The Matrix. Note that if <code>x</code> and <code>y</code> have the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code> while <code>M</code> does not, then <code>M</code> is recursively applied to all <code>x</code>[i], <code>y</code>[i] </td></tr>
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">y</td><td>contains the solution on output (may not alias <code>x</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code>y</code> may not alias <code>x</code>, the only exception is if <code>MatrixType</code> has the <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code>ContainerType1</code> ==<code>ContainerType2</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fullfills the requirements of the there defined Matrix tags derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html">AnyMatrixTag</a></code>. The <code>MatrixType</code> can for example be one of:<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga188bea19979cfa0701387bfc5272be79">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#gaab6ed0cbb6bf7ea723c10da88cd4529f">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
<li>In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code>symv( const ContainerType0&amp;, ContainerType1&amp;)</code>; ) can be called.</li>
</ul>
If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the <code>Matrix</code> is applied to each of the elements.</td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; (vector of shared device vectors), std::array&lt;double, 4&gt; (array of 4 doubles)</code></li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga53701ba3118a2256a93a4d92a7a8a597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53701ba3118a2256a93a4d92a7a8a597">&#9670;&nbsp;</a></span>transfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class AnotherMatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::transfer </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnotherMatrixType &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = x\); Generic way to copy and/or convert a Matrix type to a different Matrix type </p>
<p>e.g. from CPU to GPU, or double to float, etc.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fullfills the requirements of the there defined Matrix tags derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html">AnyMatrixTag</a></code>. The <code>MatrixType</code> can for example be one of:<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga188bea19979cfa0701387bfc5272be79">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#gaab6ed0cbb6bf7ea723c10da88cd4529f">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
<li>In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code>symv( const ContainerType0&amp;, ContainerType1&amp;)</code>; ) can be called.</li>
</ul>
If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the <code>Matrix</code> is applied to each of the elements. </td></tr>
    <tr><td class="paramname">AnotherMatrix</td><td>Another Matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>source </td></tr>
    <tr><td class="paramname">y</td><td>sink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>y gets resized properly</dd></dl>
<p>This code snippet demonstrates how to derive a function on a device </p><div class="fragment"><div class="line"><span class="comment">//define a function to derive</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">function</span>(<span class="keywordtype">double</span> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>){</div>
<div class="line">    <span class="keywordflow">return</span> sin(x)*sin(y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and 3 polynomial coefficients</span></div>
<div class="line"><a class="code" href="structdg_1_1_real_grid2d.html">dg::Grid2d</a> g2d( 0, 2, 0, 2, 3, 20, 20, <a class="code" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//declare a device matrix</span></div>
<div class="line"><a class="code" href="structdg_1_1_ell_sparse_block_mat_device.html">dg::DMatrix</a> <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//create the x derivative on the grid and transfer the matrix to the device</span></div>
<div class="line"><a class="code" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597">dg::blas2::transfer</a>( <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dg::create::dx</a>(g2d), <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//discretize the function on the grid and transfer the result to the device</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a> = dg::construct&lt;dg::DVec&gt;( <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g2d));</div>
<div class="line"> </div>
<div class="line"><span class="comment">//allocate memory for the result</span></div>
<div class="line"><a class="code" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>=<a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//apply the derivative to x and store result in y</span></div>
<div class="line"><a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(<a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>, x,y);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//or equivalently</span></div>
<div class="line"><a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(1., <a class="code" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dx</a>, x, 0., y);</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astructdg_1_1_ell_sparse_block_mat_device_html"><div class="ttname"><a href="structdg_1_1_ell_sparse_block_mat_device.html">dg::EllSparseBlockMatDevice</a></div><div class="ttdoc">Ell Sparse Block Matrix format device version.</div><div class="ttdef"><b>Definition:</b> sparseblockmat.cuh:19</div></div>
<div class="ttc" id="agroup__typedefs_html_ga4fb8e78e7b043edfedb880523f0cd193"><div class="ttname"><a href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a></div><div class="ttdeci">thrust::host_vector&lt; double &gt; HVec</div><div class="ttdoc">Host Vector.</div><div class="ttdef"><b>Definition:</b> typedefs.h:19</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">dg::coo2d::x</a></div><div class="ttdeci">@ x</div><div class="ttdoc">x direction</div></div>
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6"><div class="ttname"><a href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a></div><div class="ttdeci">@ DIR</div><div class="ttdoc">homogeneous dirichlet boundaries</div><div class="ttdef"><b>Definition:</b> enums.h:17</div></div>
<div class="ttc" id="agroup__blas2_html_gaaafba91956e948b0ea53f30889a3c20d"><div class="ttname"><a href="group__blas2.html#gaaafba91956e948b0ea53f30889a3c20d">dg::blas2::dot</a></div><div class="ttdeci">get_value_type&lt; MatrixType &gt; dot(const ContainerType1 &amp;x, const MatrixType &amp;m, const ContainerType2 &amp;y)</div><div class="ttdoc">; Binary reproducible general dot product</div><div class="ttdef"><b>Definition:</b> blas2.h:84</div></div>
<div class="ttc" id="agroup__blas2_html_gac3840941bd2bb1d64c6ca3fef1f1b960"><div class="ttname"><a href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a></div><div class="ttdeci">void symv(MatrixType &amp;&amp;M, const ContainerType1 &amp;x, ContainerType2 &amp;y)</div><div class="ttdef"><b>Definition:</b> blas2.h:222</div></div>
<div class="ttc" id="agroup__evaluation_html_ga0d2da37399e38acb2b243f568d5e7443"><div class="ttname"><a href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a></div><div class="ttdeci">thrust::host_vector&lt; real_type &gt; evaluate(UnaryOp f, const RealGrid1d&lt; real_type &gt; &amp;g)</div><div class="ttdoc">Evaluate a 1d function on grid coordinates.</div><div class="ttdef"><b>Definition:</b> evaluation.h:67</div></div>
<div class="ttc" id="astructdg_1_1_real_grid2d_html"><div class="ttname"><a href="structdg_1_1_real_grid2d.html">dg::RealGrid2d&lt; double &gt;</a></div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">dg::coo2d::y</a></div><div class="ttdeci">@ y</div><div class="ttdoc">y direction</div></div>
<div class="ttc" id="agroup__creation_html_ga9945b71a335bc97f78dc7425911c7287"><div class="ttname"><a href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a></div><div class="ttdeci">norm</div><div class="ttdoc">Switch between normalisations.</div><div class="ttdef"><b>Definition:</b> enums.h:97</div></div>
<div class="ttc" id="agroup__highlevel_html_ga771996962c7762bc7ee00b522a17259f"><div class="ttname"><a href="group__highlevel.html#ga771996962c7762bc7ee00b522a17259f">dg::create::weights</a></div><div class="ttdeci">MPI_Vector&lt; thrust::host_vector&lt; real_type &gt; &gt; weights(const aRealMPITopology2d&lt; real_type &gt; &amp;g)</div><div class="ttdoc">create host vector containing X-space weight coefficients</div><div class="ttdef"><b>Definition:</b> mpi_weights.h:22</div></div>
<div class="ttc" id="agroup__typedefs_html_ga5bbe4ba51ef8ff8d506979d0beda25b8"><div class="ttname"><a href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a></div><div class="ttdeci">thrust::device_vector&lt; double &gt; DVec</div><div class="ttdoc">Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...</div><div class="ttdef"><b>Definition:</b> typedefs.h:23</div></div>
<div class="ttc" id="agroup__blas2_html_ga53701ba3118a2256a93a4d92a7a8a597"><div class="ttname"><a href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597">dg::blas2::transfer</a></div><div class="ttdeci">void transfer(const MatrixType &amp;x, AnotherMatrixType &amp;y)</div><div class="ttdoc">; Generic way to copy and/or convert a Matrix type to a different Matrix type</div><div class="ttdef"><b>Definition:</b> blas2.h:281</div></div>
<div class="ttc" id="agroup__creation_html_ga51aea0f47c5a77bb1a3bce187839dc85"><div class="ttname"><a href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85">dg::create::dx</a></div><div class="ttdeci">EllSparseBlockMat&lt; real_type &gt; dx(const aRealTopology2d&lt; real_type &gt; &amp;g, bc bcx, direction dir=centered)</div><div class="ttdoc">Create 2d derivative in x-direction.</div><div class="ttdef"><b>Definition:</b> derivatives.h:33</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 16 2021 01:15:31 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
