<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Discontinuous Galerkin Library: dg::ARKStep&lt; ContainerType, SolverType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Container free algorithms and discontinuous Galerkin numerical methods in &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structdg_1_1_a_r_k_step.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_a_r_k_step-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::ARKStep&lt; ContainerType, SolverType &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__numerical0.html">Level 2: Basic numerical algorithms</a> &raquo; <a class="el" href="group__time.html">Time integrators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Additive Runge Kutta (semi-implicit) time-step with error estimate following <a href="http://runge.math.smu.edu/arkode_dev/doc/guide/build/html/Mathematics.html#arkstep-additive-runge-kutta-methods">The ARKode library</a>  
 <a href="structdg_1_1_a_r_k_step.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="runge__kutta_8h_source.html">runge_kutta.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab2ba292b836e088549efd5dbbb4de6e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> = <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType &gt;</td></tr>
<tr class="memdesc:ab2ba292b836e088549efd5dbbb4de6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the value type of the time variable (float or double)  <a href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">More...</a><br /></td></tr>
<tr class="separator:ab2ba292b836e088549efd5dbbb4de6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8f1972d5cbb59f65adadb14163c48c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a2f8f1972d5cbb59f65adadb14163c48c">container_type</a> = ContainerType</td></tr>
<tr class="separator:a2f8f1972d5cbb59f65adadb14163c48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa789cea909c59be38c096b62bb418dac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#aa789cea909c59be38c096b62bb418dac">ARKStep</a> ()</td></tr>
<tr class="memdesc:aa789cea909c59be38c096b62bb418dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">No memory allocation, Call <code>construct</code> before using the object.  <a href="structdg_1_1_a_r_k_step.html#aa789cea909c59be38c096b62bb418dac">More...</a><br /></td></tr>
<tr class="separator:aa789cea909c59be38c096b62bb418dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87485e677d8d90e748244774aad407d5"><td class="memTemplParams" colspan="2">template&lt;class ... SolverParams&gt; </td></tr>
<tr class="memitem:a87485e677d8d90e748244774aad407d5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a87485e677d8d90e748244774aad407d5">ARKStep</a> (std::string name, SolverParams &amp;&amp;...ps)</td></tr>
<tr class="memdesc:a87485e677d8d90e748244774aad407d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with given name.  <a href="structdg_1_1_a_r_k_step.html#a87485e677d8d90e748244774aad407d5">More...</a><br /></td></tr>
<tr class="separator:a87485e677d8d90e748244774aad407d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3e1bfa5c26f44a6381d829cd44d81d"><td class="memTemplParams" colspan="2">template&lt;class ... SolverParams&gt; </td></tr>
<tr class="memitem:a6f3e1bfa5c26f44a6381d829cd44d81d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a6f3e1bfa5c26f44a6381d829cd44d81d">ARKStep</a> (<a class="el" href="structdg_1_1_converts_to_butcher_tableau.html">ConvertsToButcherTableau</a>&lt; <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &gt; ex_tableau, <a class="el" href="structdg_1_1_converts_to_butcher_tableau.html">ConvertsToButcherTableau</a>&lt; <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &gt; im_tableau, SolverParams &amp;&amp;...ps)</td></tr>
<tr class="memdesc:a6f3e1bfa5c26f44a6381d829cd44d81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with two Butcher Tableaus.  <a href="structdg_1_1_a_r_k_step.html#a6f3e1bfa5c26f44a6381d829cd44d81d">More...</a><br /></td></tr>
<tr class="separator:a6f3e1bfa5c26f44a6381d829cd44d81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5edac448897ec6b8b71cd496dfe717"><td class="memTemplParams" colspan="2">template&lt;class ... SolverParams&gt; </td></tr>
<tr class="memitem:a1c5edac448897ec6b8b71cd496dfe717"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a1c5edac448897ec6b8b71cd496dfe717">construct</a> (<a class="el" href="structdg_1_1_converts_to_butcher_tableau.html">ConvertsToButcherTableau</a>&lt; <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &gt; ex_tableau, <a class="el" href="structdg_1_1_converts_to_butcher_tableau.html">ConvertsToButcherTableau</a>&lt; <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &gt; im_tableau, SolverParams &amp;&amp;...ps)</td></tr>
<tr class="memdesc:a1c5edac448897ec6b8b71cd496dfe717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with two Butcher Tableaus.  <a href="structdg_1_1_a_r_k_step.html#a1c5edac448897ec6b8b71cd496dfe717">More...</a><br /></td></tr>
<tr class="separator:a1c5edac448897ec6b8b71cd496dfe717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6788d11bafef3590a17688e0714d1dd7"><td class="memItemLeft" align="right" valign="top">const ContainerType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a6788d11bafef3590a17688e0714d1dd7">copyable</a> () const</td></tr>
<tr class="memdesc:a6788d11bafef3590a17688e0714d1dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an object of same size as the object used for construction.  <a href="structdg_1_1_a_r_k_step.html#a6788d11bafef3590a17688e0714d1dd7">More...</a><br /></td></tr>
<tr class="separator:a6788d11bafef3590a17688e0714d1dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d6594e6d6292f033bb607aeb71b667"><td class="memItemLeft" align="right" valign="top">SolverType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a70d6594e6d6292f033bb607aeb71b667">solver</a> ()</td></tr>
<tr class="memdesc:a70d6594e6d6292f033bb607aeb71b667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write access to the internal solver for the implicit part.  <a href="structdg_1_1_a_r_k_step.html#a70d6594e6d6292f033bb607aeb71b667">More...</a><br /></td></tr>
<tr class="separator:a70d6594e6d6292f033bb607aeb71b667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9f492f56b6b9565dc9bc5f01b18667"><td class="memItemLeft" align="right" valign="top">const SolverType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a0f9f492f56b6b9565dc9bc5f01b18667">solver</a> () const</td></tr>
<tr class="memdesc:a0f9f492f56b6b9565dc9bc5f01b18667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to the internal solver for the implicit part.  <a href="structdg_1_1_a_r_k_step.html#a0f9f492f56b6b9565dc9bc5f01b18667">More...</a><br /></td></tr>
<tr class="separator:a0f9f492f56b6b9565dc9bc5f01b18667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d365734ef2d46556c933faf68c61f3"><td class="memTemplParams" colspan="2">template&lt;class Explicit , class Implicit &gt; </td></tr>
<tr class="memitem:a85d365734ef2d46556c933faf68c61f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a85d365734ef2d46556c933faf68c61f3">step</a> (Explicit &amp;ex, Implicit &amp;im, <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> t0, const ContainerType &amp;u0, <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &amp;t1, ContainerType &amp;u1, <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> dt, ContainerType &amp;delta)</td></tr>
<tr class="memdesc:a85d365734ef2d46556c933faf68c61f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance one step.  <a href="structdg_1_1_a_r_k_step.html#a85d365734ef2d46556c933faf68c61f3">More...</a><br /></td></tr>
<tr class="separator:a85d365734ef2d46556c933faf68c61f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ddc9888a7e8fd78df554024b59935b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a00ddc9888a7e8fd78df554024b59935b">order</a> () const</td></tr>
<tr class="memdesc:a00ddc9888a7e8fd78df554024b59935b"><td class="mdescLeft">&#160;</td><td class="mdescRight">global order of the method given by the current Butcher Tableau  <a href="structdg_1_1_a_r_k_step.html#a00ddc9888a7e8fd78df554024b59935b">More...</a><br /></td></tr>
<tr class="separator:a00ddc9888a7e8fd78df554024b59935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3d30399557b2d7fab289841022f83a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a9c3d30399557b2d7fab289841022f83a">embedded_order</a> () const</td></tr>
<tr class="memdesc:a9c3d30399557b2d7fab289841022f83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">global order of the embedding given by the current Butcher Tableau  <a href="structdg_1_1_a_r_k_step.html#a9c3d30399557b2d7fab289841022f83a">More...</a><br /></td></tr>
<tr class="separator:a9c3d30399557b2d7fab289841022f83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1c5ba23f06988fc370505361243cfb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_a_r_k_step.html#a0a1c5ba23f06988fc370505361243cfb">num_stages</a> () const</td></tr>
<tr class="memdesc:a0a1c5ba23f06988fc370505361243cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of stages of the method given by the current Butcher Tableau  <a href="structdg_1_1_a_r_k_step.html#a0a1c5ba23f06988fc370505361243cfb">More...</a><br /></td></tr>
<tr class="separator:a0a1c5ba23f06988fc370505361243cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ContainerType, class SolverType = dg::DefaultSolver&lt;ContainerType&gt;&gt;<br />
struct dg::ARKStep&lt; ContainerType, SolverType &gt;</h3>

<p>Additive Runge Kutta (semi-implicit) time-step with error estimate following <a href="http://runge.math.smu.edu/arkode_dev/doc/guide/build/html/Mathematics.html#arkstep-additive-runge-kutta-methods">The ARKode library</a> </p>
<p>Currently, the possible Butcher Tableaus for a fully implicit-explicit scheme are the "ARK-4-2-3", "ARK-6-3-4" and "ARK-8-4-5" combinations. So far we did not implement the use of a mass matrix <code>M</code>. </p><dl class="section attention"><dt>Attention</dt><dd>When you use the <a class="el" href="structdg_1_1_a_r_k_step.html" title="Additive Runge Kutta (semi-implicit) time-step with error estimate following The ARKode library">ARKStep</a> in combination with the <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep integration.">Adaptive</a> time step algorithm pay attention to solve the implicit part with sufficient accuracy. Else, the error propagates into the time controller, which will then choose the timestep as if the implicit part was explicit i.e. far too small (don't really know fully why though).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SolverType</td><td>The task of this class is to solve the equation \( (y+\alpha\hat I(t,y)) = \rho\) for the given implicit part I, parameter alpha, time t and right hand side rho. For example <code><a class="el" href="structdg_1_1_default_solver.html" title="Default Solver class for solving.">dg::DefaultSolver</a></code> or <code><a class="el" href="structdg_1_1_fixed_point_solver.html" title="Fixed point iterator for solving.">dg::FixedPointSolver</a></code> If you write your own class: it must have a solve method of type: <code>void</code> <code>solve( value_type alpha, Implicit im, value_type t, ContainerType&amp; y, const ContainerType&amp; rhs)</code>; The <code> const ContainerType&amp; <a class="el" href="structdg_1_1_a_r_k_step.html#a6788d11bafef3590a17688e0714d1dd7" title="Return an object of same size as the object used for construction.">copyable() const</a>; </code> member must return a container of the size that is later used in <code>solve</code> (it does not matter what values <code>copyable</code> contains, but its size is important; the <code>solve</code> method will be called with vectors of this size)</td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; (vector of shared device vectors), std::array&lt;double, 4&gt; (array of 4 doubles)</code></li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2f8f1972d5cbb59f65adadb14163c48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8f1972d5cbb59f65adadb14163c48c">&#9670;&nbsp;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::<a class="el" href="structdg_1_1_a_r_k_step.html#a2f8f1972d5cbb59f65adadb14163c48c">container_type</a> =  ContainerType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the type of the vector class in use </p>

</div>
</div>
<a id="ab2ba292b836e088549efd5dbbb4de6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ba292b836e088549efd5dbbb4de6e0">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::<a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> =  <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt;ContainerType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the value type of the time variable (float or double) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa789cea909c59be38c096b62bb418dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa789cea909c59be38c096b62bb418dac">&#9670;&nbsp;</a></span>ARKStep() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::<a class="el" href="structdg_1_1_a_r_k_step.html">ARKStep</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No memory allocation, Call <code>construct</code> before using the object. </p>

</div>
</div>
<a id="a87485e677d8d90e748244774aad407d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87485e677d8d90e748244774aad407d5">&#9670;&nbsp;</a></span>ARKStep() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... SolverParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::<a class="el" href="structdg_1_1_a_r_k_step.html">ARKStep</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverParams &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Currently, one of "ARK-4-2-3", "ARK-6-3-4" or "ARK-8-4-5" </td></tr>
    <tr><td class="paramname">ps</td><td>Parameters that are forwarded to the constructor of <code>SolverType</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SolverParams</td><td>Type of parameters (deduced by the compiler) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f3e1bfa5c26f44a6381d829cd44d81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3e1bfa5c26f44a6381d829cd44d81d">&#9670;&nbsp;</a></span>ARKStep() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... SolverParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::<a class="el" href="structdg_1_1_a_r_k_step.html">ARKStep</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdg_1_1_converts_to_butcher_tableau.html">ConvertsToButcherTableau</a>&lt; <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ex_tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_converts_to_butcher_tableau.html">ConvertsToButcherTableau</a>&lt; <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>im_tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverParams &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with two Butcher Tableaus. </p>
<p>The two Butcher Tableaus represent the parameters for the explicit and implicit parts respectively. If both the explicit and implicit part of your equations are nontrivial, they must be one of the "ARK-X-X-X" methods listed in <code><a class="el" href="structdg_1_1_converts_to_butcher_tableau.html" title="Convert identifiers to their corresponding dg::ButcherTableau.">ConvertsToButcherTableau</a></code>. Or you have your own tableaus of course but both tableaus must have the same number of steps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex_tableau</td><td>Tableau for the explicit part </td></tr>
    <tr><td class="paramname">im_tableau</td><td>Tableau for the implicit part (must have the same number of stages as <code>ex_tableau</code> ) </td></tr>
    <tr><td class="paramname">ps</td><td>Parameters that are forwarded to the constructor of <code>SolverType</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SolverParams</td><td>Type of parameters (deduced by the compiler) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1c5edac448897ec6b8b71cd496dfe717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5edac448897ec6b8b71cd496dfe717">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... SolverParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdg_1_1_converts_to_butcher_tableau.html">ConvertsToButcherTableau</a>&lt; <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ex_tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_converts_to_butcher_tableau.html">ConvertsToButcherTableau</a>&lt; <a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>im_tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverParams &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with two Butcher Tableaus. </p>
<p>The two Butcher Tableaus represent the parameters for the explicit and implicit parts respectively. If both the explicit and implicit part of your equations are nontrivial, they must be one of the "ARK-X-X-X" methods listed in <code><a class="el" href="structdg_1_1_converts_to_butcher_tableau.html" title="Convert identifiers to their corresponding dg::ButcherTableau.">ConvertsToButcherTableau</a></code>. Or you have your own tableaus of course but both tableaus must have the same number of steps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex_tableau</td><td>Tableau for the explicit part </td></tr>
    <tr><td class="paramname">im_tableau</td><td>Tableau for the implicit part (must have the same number of stages as <code>ex_tableau</code> ) </td></tr>
    <tr><td class="paramname">ps</td><td>Parameters that are forwarded to the constructor of <code>SolverType</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SolverParams</td><td>Type of parameters (deduced by the compiler) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6788d11bafef3590a17688e0714d1dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6788d11bafef3590a17688e0714d1dd7">&#9670;&nbsp;</a></span>copyable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ContainerType&amp; <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::copyable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an object of same size as the object used for construction. </p>
<dl class="section return"><dt>Returns</dt><dd>A copyable object; what it contains is undefined, its size is important </dd></dl>

</div>
</div>
<a id="a9c3d30399557b2d7fab289841022f83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3d30399557b2d7fab289841022f83a">&#9670;&nbsp;</a></span>embedded_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::embedded_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>global order of the embedding given by the current Butcher Tableau </p>

</div>
</div>
<a id="a0a1c5ba23f06988fc370505361243cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1c5ba23f06988fc370505361243cfb">&#9670;&nbsp;</a></span>num_stages()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::num_stages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of stages of the method given by the current Butcher Tableau </p>

</div>
</div>
<a id="a00ddc9888a7e8fd78df554024b59935b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ddc9888a7e8fd78df554024b59935b">&#9670;&nbsp;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>global order of the method given by the current Butcher Tableau </p>

</div>
</div>
<a id="a70d6594e6d6292f033bb607aeb71b667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d6594e6d6292f033bb607aeb71b667">&#9670;&nbsp;</a></span>solver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SolverType&amp; <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write access to the internal solver for the implicit part. </p>

</div>
</div>
<a id="a0f9f492f56b6b9565dc9bc5f01b18667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9f492f56b6b9565dc9bc5f01b18667">&#9670;&nbsp;</a></span>solver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SolverType&amp; <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read access to the internal solver for the implicit part. </p>

</div>
</div>
<a id="a85d365734ef2d46556c933faf68c61f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d365734ef2d46556c933faf68c61f3">&#9670;&nbsp;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Explicit , class Implicit &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_a_r_k_step.html">dg::ARKStep</a>&lt; ContainerType, SolverType &gt;::step </td>
          <td>(</td>
          <td class="paramtype">Explicit &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Implicit &amp;&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a>&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_a_r_k_step.html#ab2ba292b836e088549efd5dbbb4de6e0">value_type</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance one step. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Explicit</td><td>The explicit part of the right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = f(t, y) translates to f(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. </td></tr>
    <tr><td class="paramname">Implicit</td><td>The implicit part of the right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = f(t, y) translates to f(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. Furthermore, if the <code><a class="el" href="structdg_1_1_default_solver.html" title="Default Solver class for solving.">DefaultSolver</a></code> is used, the routines weights(), inv_weights() and precond() must be callable and return diagonal weights, inverse weights and the preconditioner for the conjugate gradient method. The return type of these member functions must be useable in <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions together with the ContainerType type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>explic part </td></tr>
    <tr><td class="paramname">im</td><td>implicit part ( must be linear in its second argument and symmetric up to weights) </td></tr>
    <tr><td class="paramname">t0</td><td>start time </td></tr>
    <tr><td class="paramname">u0</td><td>value at <code>t0</code> </td></tr>
    <tr><td class="paramname">t1</td><td>(write only) end time ( equals <code>t0+dt</code> on output, may alias <code>t0</code>) </td></tr>
    <tr><td class="paramname">u1</td><td>(write only) contains result on output (may alias u0) </td></tr>
    <tr><td class="paramname">dt</td><td>timestep </td></tr>
    <tr><td class="paramname">delta</td><td>Contains error estimate on output (must have equal size as <code>u0</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>on return <code>ex(t1, u1)</code> will be the last call to <code>ex</code> (this is useful if <code>Explicit</code> holds state, which is then updated to the current timestep) </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="runge__kutta_8h_source.html">runge_kutta.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_a_r_k_step.html">ARKStep</a></li>
    <li class="footer">Generated on Tue Feb 16 2021 01:15:31 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
