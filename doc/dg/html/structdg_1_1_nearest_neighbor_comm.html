<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Discontinuous Galerkin Library: dg::NearestNeighborComm&lt; Index, Buffer, Vector &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Container free algorithms and discontinuous Galerkin numerical methods in &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structdg_1_1_nearest_neighbor_comm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_nearest_neighbor_comm-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::NearestNeighborComm&lt; Index, Buffer, Vector &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__backend.html">Level 1: Vectors, Matrices and basic operations</a> &raquo; <a class="el" href="group__mpi__structures.html">MPI backend</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Communicator for asynchronous nearest neighbor communication.  
 <a href="structdg_1_1_nearest_neighbor_comm.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mpi__vector_8h_source.html">mpi_vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aabfc3bbed3b1a7ef48d4ae8d1046eac8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#aabfc3bbed3b1a7ef48d4ae8d1046eac8">container_type</a> = Vector</td></tr>
<tr class="separator:aabfc3bbed3b1a7ef48d4ae8d1046eac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca21ce71af2867c5b4424f3aedf2ad91"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#aca21ce71af2867c5b4424f3aedf2ad91">buffer_type</a> = <a class="el" href="structdg_1_1_buffer.html">Buffer</a></td></tr>
<tr class="separator:aca21ce71af2867c5b4424f3aedf2ad91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3428c68d97ffc6a106be3289a644f0cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a3428c68d97ffc6a106be3289a644f0cf">pointer_type</a> = <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; Vector &gt; *</td></tr>
<tr class="separator:a3428c68d97ffc6a106be3289a644f0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf727a5b8915ffad2ad814d185e417c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#abf727a5b8915ffad2ad814d185e417c5">const_pointer_type</a> = <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; Vector &gt; const *</td></tr>
<tr class="separator:abf727a5b8915ffad2ad814d185e417c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8e33ecbc3e2c55deea1ddabc077aa85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#ab8e33ecbc3e2c55deea1ddabc077aa85">NearestNeighborComm</a> ()</td></tr>
<tr class="memdesc:ab8e33ecbc3e2c55deea1ddabc077aa85"><td class="mdescLeft">&#160;</td><td class="mdescRight">no communication  <a href="structdg_1_1_nearest_neighbor_comm.html#ab8e33ecbc3e2c55deea1ddabc077aa85">More...</a><br /></td></tr>
<tr class="separator:ab8e33ecbc3e2c55deea1ddabc077aa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9caac5cbeb9fb587e791cf9001ceb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#aaa9caac5cbeb9fb587e791cf9001ceb2">NearestNeighborComm</a> (unsigned <a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a3f7516e6a6707ebcdcafdc36d9de9f5c">n</a>, const unsigned vector_dimensions[3], MPI_Comm comm, unsigned <a class="el" href="group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">direction</a>)</td></tr>
<tr class="memdesc:aaa9caac5cbeb9fb587e791cf9001ceb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct.  <a href="structdg_1_1_nearest_neighbor_comm.html#aaa9caac5cbeb9fb587e791cf9001ceb2">More...</a><br /></td></tr>
<tr class="separator:aaa9caac5cbeb9fb587e791cf9001ceb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb90b82c228b5d45c0dea912a65158d6"><td class="memTemplParams" colspan="2">template&lt;class OtherIndex , class OtherBuffer , class OtherVector &gt; </td></tr>
<tr class="memitem:adb90b82c228b5d45c0dea912a65158d6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#adb90b82c228b5d45c0dea912a65158d6">NearestNeighborComm</a> (const <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">NearestNeighborComm</a>&lt; OtherIndex, OtherBuffer, OtherVector &gt; &amp;src)</td></tr>
<tr class="memdesc:adb90b82c228b5d45c0dea912a65158d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from other Communicator.  <a href="structdg_1_1_nearest_neighbor_comm.html#adb90b82c228b5d45c0dea912a65158d6">More...</a><br /></td></tr>
<tr class="separator:adb90b82c228b5d45c0dea912a65158d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7516e6a6707ebcdcafdc36d9de9f5c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a3f7516e6a6707ebcdcafdc36d9de9f5c">n</a> () const</td></tr>
<tr class="memdesc:a3f7516e6a6707ebcdcafdc36d9de9f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">halo size  <a href="structdg_1_1_nearest_neighbor_comm.html#a3f7516e6a6707ebcdcafdc36d9de9f5c">More...</a><br /></td></tr>
<tr class="separator:a3f7516e6a6707ebcdcafdc36d9de9f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb96e1033b1ed7240735a2e73a435fe"><td class="memItemLeft" align="right" valign="top">const unsigned *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#afcb96e1033b1ed7240735a2e73a435fe">dims</a> () const</td></tr>
<tr class="memdesc:afcb96e1033b1ed7240735a2e73a435fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensionality of the input vector.  <a href="structdg_1_1_nearest_neighbor_comm.html#afcb96e1033b1ed7240735a2e73a435fe">More...</a><br /></td></tr>
<tr class="separator:afcb96e1033b1ed7240735a2e73a435fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11be4522a94a3905ffe74e8b08ed96c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#ad11be4522a94a3905ffe74e8b08ed96c">direction</a> () const</td></tr>
<tr class="memdesc:ad11be4522a94a3905ffe74e8b08ed96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The direction of communication.  <a href="structdg_1_1_nearest_neighbor_comm.html#ad11be4522a94a3905ffe74e8b08ed96c">More...</a><br /></td></tr>
<tr class="separator:ad11be4522a94a3905ffe74e8b08ed96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3cd554cb8023482bce926157ad74b0"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a5a3cd554cb8023482bce926157ad74b0">communicator</a> () const</td></tr>
<tr class="memdesc:a5a3cd554cb8023482bce926157ad74b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal MPI communicator used.  <a href="structdg_1_1_nearest_neighbor_comm.html#a5a3cd554cb8023482bce926157ad74b0">More...</a><br /></td></tr>
<tr class="separator:a5a3cd554cb8023482bce926157ad74b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9938f3e7dfddbdeaf95a7563df70f56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a9938f3e7dfddbdeaf95a7563df70f56e">allocate_buffer</a> () const</td></tr>
<tr class="memdesc:a9938f3e7dfddbdeaf95a7563df70f56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer object.  <a href="structdg_1_1_nearest_neighbor_comm.html#a9938f3e7dfddbdeaf95a7563df70f56e">More...</a><br /></td></tr>
<tr class="separator:a9938f3e7dfddbdeaf95a7563df70f56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0304036df7739faf176f8dc62d633c7c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a0304036df7739faf176f8dc62d633c7c">buffer_size</a> () const</td></tr>
<tr class="memdesc:a0304036df7739faf176f8dc62d633c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the halo.  <a href="structdg_1_1_nearest_neighbor_comm.html#a0304036df7739faf176f8dc62d633c7c">More...</a><br /></td></tr>
<tr class="separator:a0304036df7739faf176f8dc62d633c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4382fb4c96b288d55e062e64c235ada"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#af4382fb4c96b288d55e062e64c235ada">isCommunicating</a> () const</td></tr>
<tr class="memdesc:af4382fb4c96b288d55e062e64c235ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the gather/scatter operation involves actual MPI communication.  <a href="structdg_1_1_nearest_neighbor_comm.html#af4382fb4c96b288d55e062e64c235ada">More...</a><br /></td></tr>
<tr class="separator:af4382fb4c96b288d55e062e64c235ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8818544132cf8f05be2fa26b0a537e69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a8818544132cf8f05be2fa26b0a537e69">map_index</a> (int i) const</td></tr>
<tr class="memdesc:a8818544132cf8f05be2fa26b0a537e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a local matrix index to a buffer index.  <a href="structdg_1_1_nearest_neighbor_comm.html#a8818544132cf8f05be2fa26b0a537e69">More...</a><br /></td></tr>
<tr class="separator:a8818544132cf8f05be2fa26b0a537e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a26b474d61904090bf4be60506e64b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#ae2a26b474d61904090bf4be60506e64b">global_gather_init</a> (<a class="el" href="structdg_1_1_nearest_neighbor_comm.html#abf727a5b8915ffad2ad814d185e417c5">const_pointer_type</a> input, <a class="el" href="structdg_1_1_nearest_neighbor_comm.html#aca21ce71af2867c5b4424f3aedf2ad91">buffer_type</a> &amp;buffer, MPI_Request rqst[4]) const</td></tr>
<tr class="memdesc:ae2a26b474d61904090bf4be60506e64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather values from given Vector and initiate asynchronous MPI communication.  <a href="structdg_1_1_nearest_neighbor_comm.html#ae2a26b474d61904090bf4be60506e64b">More...</a><br /></td></tr>
<tr class="separator:ae2a26b474d61904090bf4be60506e64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465366c4b1b50bf2e8e78f352ec11be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a465366c4b1b50bf2e8e78f352ec11be0">global_gather_wait</a> (<a class="el" href="structdg_1_1_nearest_neighbor_comm.html#abf727a5b8915ffad2ad814d185e417c5">const_pointer_type</a> input, const <a class="el" href="structdg_1_1_nearest_neighbor_comm.html#aca21ce71af2867c5b4424f3aedf2ad91">buffer_type</a> &amp;buffer, MPI_Request rqst[4]) const</td></tr>
<tr class="memdesc:a465366c4b1b50bf2e8e78f352ec11be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for asynchronous communication to finish and gather received data into buffer.  <a href="structdg_1_1_nearest_neighbor_comm.html#a465366c4b1b50bf2e8e78f352ec11be0">More...</a><br /></td></tr>
<tr class="separator:a465366c4b1b50bf2e8e78f352ec11be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Index, class Buffer, class Vector&gt;<br />
struct dg::NearestNeighborComm&lt; Index, Buffer, Vector &gt;</h3>

<p>Communicator for asynchronous nearest neighbor communication. </p>
<p>Imagine a communicator with Cartesian topology and further imagine that the grid topology is also Cartesian (vectors form a box) in two or three dimensions. In each direction this box has a boundary layer (the halo) of a depth given by the user. Each boundary layer has two neighboring layers, one on the same process and one lying on the neighboring process. What this class does is to provide you with six pointers to each of these six layers (three on each side). The pointers either reference data in an internal communication buffer (since it involves communciation to get the layers from neighboring processes) another buffer (if mpi communication requires to reorder input data) or the input vector itself (if the communication goes along the last dimension there is no need to reorder, in fact, here is the main gain we get from the pointer approach, we save on unnecessary data copies, which might be significant in cases where the communication to computation ratio is high). The size of the data each pointer references is the halo size, <code><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a0304036df7739faf176f8dc62d633c7c" title="The size of the halo.">buffer_size()</a></code> </p>
<p>The communication is done asynchronously i.e. the user can initiate the communication and signal when the results are needed at a later stage.</p>
<dl class="section note"><dt>Note</dt><dd>If the number of neighboring processes in the given direction is 1, the buffer size is 0 and all members return immediately. </dd>
<dd>
the pointers may alias each other (if the input contains less than 4 layers)</dd>
<dd>
the corresponding gather map is of general type and the communication can also be modeled in <code><a class="el" href="structdg_1_1_general_comm.html" title="Perform general gather and its transpose (scatter) operation across processes on distributed vectors ...">GeneralComm</a></code>, but not <code><a class="el" href="structdg_1_1_bijective_comm.html" title="Perform bijective gather and its transpose (scatter) operation across processes on distributed vector...">BijectiveComm</a></code> or <code><a class="el" href="structdg_1_1_surjective_comm.html" title="Perform surjective gather and its transpose (scatter) operation across processes on distributed vecto...">SurjectiveComm</a></code> </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Currently we cannot handle the case where the whole vector is the boundary layer (i.e. <code><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a0304036df7739faf176f8dc62d633c7c" title="The size of the halo.">buffer_size()</a>==input.size()</code> and both neighboring layers are on different processes)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>the type of index container (must be either thrust::host_vector&lt;int&gt; or thrust::device_vector&lt;int&gt;) </td></tr>
    <tr><td class="paramname"><a class="el" href="structdg_1_1_buffer.html" title="a manager class that invokes the copy constructor on the managed ptr when copied (deep copy)">Buffer</a></td><td>the container for the pointers to the buffer arrays </td></tr>
    <tr><td class="paramname">Vector</td><td>the vector container type must have a resize() function and work in the thrust library functions ( i.e. must a thrust::host_vector or thrust::device_vector) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdg_1_1_row_col_dist_mat.html" title="Distributed memory matrix class, asynchronous communication.">dg::RowColDistMat</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aca21ce71af2867c5b4424f3aedf2ad91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca21ce71af2867c5b4424f3aedf2ad91">&#9670;&nbsp;</a></span>buffer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::<a class="el" href="structdg_1_1_nearest_neighbor_comm.html#aca21ce71af2867c5b4424f3aedf2ad91">buffer_type</a> =  <a class="el" href="structdg_1_1_buffer.html">Buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf727a5b8915ffad2ad814d185e417c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf727a5b8915ffad2ad814d185e417c5">&#9670;&nbsp;</a></span>const_pointer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::<a class="el" href="structdg_1_1_nearest_neighbor_comm.html#abf727a5b8915ffad2ad814d185e417c5">const_pointer_type</a> =  <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt;Vector&gt; const *</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabfc3bbed3b1a7ef48d4ae8d1046eac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfc3bbed3b1a7ef48d4ae8d1046eac8">&#9670;&nbsp;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::<a class="el" href="structdg_1_1_nearest_neighbor_comm.html#aabfc3bbed3b1a7ef48d4ae8d1046eac8">container_type</a> =  Vector</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3428c68d97ffc6a106be3289a644f0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3428c68d97ffc6a106be3289a644f0cf">&#9670;&nbsp;</a></span>pointer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::<a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a3428c68d97ffc6a106be3289a644f0cf">pointer_type</a> =  <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt;Vector&gt;*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab8e33ecbc3e2c55deea1ddabc077aa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e33ecbc3e2c55deea1ddabc077aa85">&#9670;&nbsp;</a></span>NearestNeighborComm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::<a class="el" href="structdg_1_1_nearest_neighbor_comm.html">NearestNeighborComm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>no communication </p>

</div>
</div>
<a id="aaa9caac5cbeb9fb587e791cf9001ceb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9caac5cbeb9fb587e791cf9001ceb2">&#9670;&nbsp;</a></span>NearestNeighborComm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::<a class="el" href="structdg_1_1_nearest_neighbor_comm.html">NearestNeighborComm</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>vector_dimensions</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>depth of the halo </td></tr>
    <tr><td class="paramname">vector_dimensions</td><td>{x, y, z} dimension (total number of points) </td></tr>
    <tr><td class="paramname">comm</td><td>the (cartesian) communicator </td></tr>
    <tr><td class="paramname">direction</td><td>0 is x, 1 is y, 2 is z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb90b82c228b5d45c0dea912a65158d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb90b82c228b5d45c0dea912a65158d6">&#9670;&nbsp;</a></span>NearestNeighborComm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<div class="memtemplate">
template&lt;class OtherIndex , class OtherBuffer , class OtherVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::<a class="el" href="structdg_1_1_nearest_neighbor_comm.html">NearestNeighborComm</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">NearestNeighborComm</a>&lt; OtherIndex, OtherBuffer, OtherVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from other Communicator. </p>
<p>Simply copies halo size, dimensions, communicator and direction and constructs a new object </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherIndex</td><td>other index type </td></tr>
    <tr><td class="paramname">OtherVector</td><td>other container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9938f3e7dfddbdeaf95a7563df70f56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9938f3e7dfddbdeaf95a7563df70f56e">&#9670;&nbsp;</a></span>allocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_buffer.html">Buffer</a> <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::allocate_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a buffer object. </p>
<p>The buffer object is only a colletion of pointers to the actual data </p><dl class="section return"><dt>Returns</dt><dd>a buffer object on the stack </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if <code><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a0304036df7739faf176f8dc62d633c7c" title="The size of the halo.">buffer_size()</a>==0</code> the default constructor of <code><a class="el" href="structdg_1_1_buffer.html" title="a manager class that invokes the copy constructor on the managed ptr when copied (deep copy)">Buffer</a></code> is called </dd></dl>

</div>
</div>
<a id="a0304036df7739faf176f8dc62d633c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0304036df7739faf176f8dc62d633c7c">&#9670;&nbsp;</a></span>buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the halo. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the halo (0 if no communication) </dd></dl>

</div>
</div>
<a id="a5a3cd554cb8023482bce926157ad74b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3cd554cb8023482bce926157ad74b0">&#9670;&nbsp;</a></span>communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal MPI communicator used. </p>
<p>can be e.g. used to assert that communicators of matrix and vector are the same </p><dl class="section return"><dt>Returns</dt><dd>MPI Communicator </dd></dl>

</div>
</div>
<a id="afcb96e1033b1ed7240735a2e73a435fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb96e1033b1ed7240735a2e73a435fe">&#9670;&nbsp;</a></span>dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned* <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dimensionality of the input vector. </p>
<dl class="section return"><dt>Returns</dt><dd>dimensions ( 3) </dd></dl>

</div>
</div>
<a id="ad11be4522a94a3905ffe74e8b08ed96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11be4522a94a3905ffe74e8b08ed96c">&#9670;&nbsp;</a></span>direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::<a class="el" href="group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">direction</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction of communication. </p>
<dl class="section return"><dt>Returns</dt><dd>direction </dd></dl>

</div>
</div>
<a id="ae2a26b474d61904090bf4be60506e64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a26b474d61904090bf4be60506e64b">&#9670;&nbsp;</a></span>global_gather_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::global_gather_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#abf727a5b8915ffad2ad814d185e417c5">const_pointer_type</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#aca21ce71af2867c5b4424f3aedf2ad91">buffer_type</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request&#160;</td>
          <td class="paramname"><em>rqst</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather values from given Vector and initiate asynchronous MPI communication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>from which to gather data (it is <b>unsafe</b> to change values on return) </td></tr>
    <tr><td class="paramname">buffer</td><td>(write only) pointers to the received data after <code><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a465366c4b1b50bf2e8e78f352ec11be0" title="Wait for asynchronous communication to finish and gather received data into buffer.">global_gather_wait()</a></code> was called (must be allocated by <code><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a9938f3e7dfddbdeaf95a7563df70f56e" title="Allocate a buffer object.">allocate_buffer()</a></code>) </td></tr>
    <tr><td class="paramname">rqst</td><td>four request variables that can be used to call MPI_Waitall </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a465366c4b1b50bf2e8e78f352ec11be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465366c4b1b50bf2e8e78f352ec11be0">&#9670;&nbsp;</a></span>global_gather_wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::global_gather_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#abf727a5b8915ffad2ad814d185e417c5">const_pointer_type</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_nearest_neighbor_comm.html#aca21ce71af2867c5b4424f3aedf2ad91">buffer_type</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request&#160;</td>
          <td class="paramname"><em>rqst</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for asynchronous communication to finish and gather received data into buffer. </p>
<p>Calls MPI_Waitall on the <code>rqst</code> variables and may do additional cleanup. After this call returns it is safe to use data the buffer points to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>from which to gather data (it is safe to change values on return since values to communicate are copied into <code>buffer</code>) </td></tr>
    <tr><td class="paramname">buffer</td><td>(write only) where received data resides on return (must be allocated by <code><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a9938f3e7dfddbdeaf95a7563df70f56e" title="Allocate a buffer object.">allocate_buffer()</a></code>) </td></tr>
    <tr><td class="paramname">rqst</td><td>the same four request variables that were used in global_gather_init </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4382fb4c96b288d55e062e64c235ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4382fb4c96b288d55e062e64c235ada">&#9670;&nbsp;</a></span>isCommunicating()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::isCommunicating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the gather/scatter operation involves actual MPI communication. </p>
<p>This is more than just a test for zero message size. This is because even if a process has zero message size indicating that it technically does not need to send any data at all it might still need to participate in an MPI communication (sending an empty message to indicate that a certain point in execution has been reached). Only if NONE of the processes in the process group has anything to send will this function return false. This test can be used to avoid the gather operation alltogether in e.g. the construction of a MPI distributed matrix. </p><dl class="section note"><dt>Note</dt><dd>this check involves MPI communication itself, because a process needs to check if itself or any other process in its group is communicating.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>False, if the global gather can be done without MPI communication (i.e. the indices are all local to each calling process), or if the communicator is <code>MPI_COMM_NULL</code>. True else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdg_1_1_nearest_neighbor_comm.html#a0304036df7739faf176f8dc62d633c7c" title="The size of the halo.">buffer_size()</a> </dd></dl>

</div>
</div>
<a id="a8818544132cf8f05be2fa26b0a537e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8818544132cf8f05be2fa26b0a537e69">&#9670;&nbsp;</a></span>map_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::map_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map a local matrix index to a buffer index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>matrix index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer index (0,1,...,5) </dd></dl>

</div>
</div>
<a id="a3f7516e6a6707ebcdcafdc36d9de9f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7516e6a6707ebcdcafdc36d9de9f5c">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Buffer , class Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_nearest_neighbor_comm.html">dg::NearestNeighborComm</a>&lt; Index, <a class="el" href="structdg_1_1_buffer.html">Buffer</a>, Vector &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>halo size </p>
<dl class="section return"><dt>Returns</dt><dd>halo size </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>backend/<a class="el" href="mpi__vector_8h_source.html">mpi_vector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_nearest_neighbor_comm.html">NearestNeighborComm</a></li>
    <li class="footer">Generated on Tue Feb 16 2021 01:15:31 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
