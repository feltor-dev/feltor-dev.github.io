<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Discontinuous Galerkin Library: dg::Adaptive&lt; Stepper &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Container free algorithms and discontinuous Galerkin numerical methods in &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structdg_1_1_adaptive.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_adaptive-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::Adaptive&lt; Stepper &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__numerical0.html">Level 2: Basic numerical algorithms</a> &raquo; <a class="el" href="group__time.html">Time integrators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver class for adaptive timestep integration.  
 <a href="structdg_1_1_adaptive.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="adaptive_8h_source.html">adaptive.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6c48d0d136681f6c6810e41538fb8771"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a> = Stepper</td></tr>
<tr class="separator:a6c48d0d136681f6c6810e41538fb8771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0066793e3a3e9d5159da5c12dfb4b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> = typename Stepper::container_type</td></tr>
<tr class="memdesc:a9b0066793e3a3e9d5159da5c12dfb4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of the vector class in use by <code>Stepper</code>  <a href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">More...</a><br /></td></tr>
<tr class="separator:a9b0066793e3a3e9d5159da5c12dfb4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f64c811c0abb1a6aa871d4bf7b868a0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> = typename Stepper::value_type</td></tr>
<tr class="memdesc:a9f64c811c0abb1a6aa871d4bf7b868a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the value type of the time variable defined by <code>Stepper</code> (float or double)  <a href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">More...</a><br /></td></tr>
<tr class="separator:a9f64c811c0abb1a6aa871d4bf7b868a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5cb5e4317ad65086f4272a6a48b69e2"><td class="memTemplParams" colspan="2">template&lt;class ... StepperParams&gt; </td></tr>
<tr class="memitem:ae5cb5e4317ad65086f4272a6a48b69e2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#ae5cb5e4317ad65086f4272a6a48b69e2">Adaptive</a> (StepperParams &amp;&amp;...ps)</td></tr>
<tr class="memdesc:ae5cb5e4317ad65086f4272a6a48b69e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate workspace and construct stepper.  <a href="structdg_1_1_adaptive.html#ae5cb5e4317ad65086f4272a6a48b69e2">More...</a><br /></td></tr>
<tr class="separator:ae5cb5e4317ad65086f4272a6a48b69e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdd79d57b8a9dd603329fd4ad9bce21"><td class="memTemplParams" colspan="2">template&lt;class Explicit , class ErrorNorm  = value_type(const container_type&amp;)&gt; </td></tr>
<tr class="memitem:a2cdd79d57b8a9dd603329fd4ad9bce21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#a2cdd79d57b8a9dd603329fd4ad9bce21">guess_stepsize</a> (Explicit &amp;ex, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> t0, const <a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;u0, enum <a class="el" href="group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">direction</a> dir, ErrorNorm &amp;<a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">norm</a>, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> rtol, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> atol)</td></tr>
<tr class="memdesc:a2cdd79d57b8a9dd603329fd4ad9bce21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guess an initial stepsize.  <a href="structdg_1_1_adaptive.html#a2cdd79d57b8a9dd603329fd4ad9bce21">More...</a><br /></td></tr>
<tr class="separator:a2cdd79d57b8a9dd603329fd4ad9bce21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db5dcb26199b603e01081481cc61f04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_adaptive.html#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#a8db5dcb26199b603e01081481cc61f04">stepper</a> ()</td></tr>
<tr class="memdesc:a8db5dcb26199b603e01081481cc61f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow write access to internal stepper.  <a href="structdg_1_1_adaptive.html#a8db5dcb26199b603e01081481cc61f04">More...</a><br /></td></tr>
<tr class="separator:a8db5dcb26199b603e01081481cc61f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa335991e84bb465ad12640027010cfa4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdg_1_1_adaptive.html#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#aa335991e84bb465ad12640027010cfa4">stepper</a> () const</td></tr>
<tr class="memdesc:aa335991e84bb465ad12640027010cfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to internal stepper.  <a href="structdg_1_1_adaptive.html#aa335991e84bb465ad12640027010cfa4">More...</a><br /></td></tr>
<tr class="separator:aa335991e84bb465ad12640027010cfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6703b0c64623025c54dcdf3be51d9b"><td class="memTemplParams" colspan="2">template&lt;class RHS , class ControlFunction  = value_type (value_type, value_type, value_type, value_type, unsigned, unsigned), class ErrorNorm  = value_type( const container_type&amp;)&gt; </td></tr>
<tr class="memitem:a6a6703b0c64623025c54dcdf3be51d9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#a6a6703b0c64623025c54dcdf3be51d9b">step</a> (RHS &amp;rhs, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> t0, const <a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;u0, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;t1, <a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;u1, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;dt, ControlFunction &amp;control, ErrorNorm &amp;<a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">norm</a>, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> rtol, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> atol)</td></tr>
<tr class="memdesc:a6a6703b0c64623025c54dcdf3be51d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit or Implicit adaptive step.  <a href="structdg_1_1_adaptive.html#a6a6703b0c64623025c54dcdf3be51d9b">More...</a><br /></td></tr>
<tr class="separator:a6a6703b0c64623025c54dcdf3be51d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee6c1ddddcd48be9002574df4b33b10"><td class="memTemplParams" colspan="2">template&lt;class Explicit , class Implicit , class ControlFunction  = value_type (value_type, value_type, value_type, value_type, unsigned, unsigned), class ErrorNorm  = value_type( const container_type&amp;)&gt; </td></tr>
<tr class="memitem:adee6c1ddddcd48be9002574df4b33b10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#adee6c1ddddcd48be9002574df4b33b10">step</a> (Explicit &amp;ex, Implicit &amp;im, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> t0, const <a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;u0, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;t1, <a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;u1, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;dt, ControlFunction &amp;control, ErrorNorm &amp;<a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">norm</a>, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> rtol, <a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> atol)</td></tr>
<tr class="memdesc:adee6c1ddddcd48be9002574df4b33b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-implicit adaptive step.  <a href="structdg_1_1_adaptive.html#adee6c1ddddcd48be9002574df4b33b10">More...</a><br /></td></tr>
<tr class="separator:adee6c1ddddcd48be9002574df4b33b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11328919ed0d30e7e8719cd2f7629a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_adaptive.html#ad11328919ed0d30e7e8719cd2f7629a2">failed</a> () const</td></tr>
<tr class="memdesc:ad11328919ed0d30e7e8719cd2f7629a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the last stepsize in step was rejected.  <a href="structdg_1_1_adaptive.html#ad11328919ed0d30e7e8719cd2f7629a2">More...</a><br /></td></tr>
<tr class="separator:ad11328919ed0d30e7e8719cd2f7629a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Stepper&gt;<br />
struct dg::Adaptive&lt; Stepper &gt;</h3>

<p>Driver class for adaptive timestep integration. </p>
<p>In order to build an adaptive Time integrator you basically need three ingredients: a <code>Stepper</code>, a <code>ControlFunction</code> and an <code>ErrorNorm</code>. The <code>Stepper</code> does the actual computation and advances the solution one step further with a given timestep <code>dt</code>. Furthermore, it has to come up with an estimate of the error of the solution and indicate the order of that error. With the <code>ErrorNorm</code> the error estimate can be converted to a scalar that can be compared to given relative and absolute error tolerances <code>rtol</code> and <code>atol</code>. Based on the comparison the step is either accepted or rejected. In both cases the <code>ControlFunction</code> then comes up with an adapted suggestion for the timestep in the next step, however, if the step was rejected, we make the stepsize decrease by at least 10%. For more information on these concepts we recommend <a href="http://runge.math.smu.edu/arkode_dev/doc/guide/build/html/Mathematics.html#">the mathematical primer</a> of the ARKode library.</p>
<p>For an example on how to use this class in a practical example consider the following code snippet: </p><div class="fragment"><div class="line">        time = 0., y0 = init;</div>
<div class="line">        <a class="code" href="structdg_1_1_adaptive.html">dg::Adaptive&lt;dg::ARKStep&lt;std::array&lt;double,2&gt;</a>, ImplicitSolver&gt;&gt; adapt( name, nu);</div>
<div class="line">        <span class="keywordtype">double</span> time = 0;</div>
<div class="line">        <span class="keywordtype">double</span> dt = adapt.guess_stepsize( ex, time, y0, <a class="code" href="group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a573a4a72e7f55df92b88c254a13762f2">dg::forward</a>, <a class="code" href="group__time__utils.html#ga6dc9be16f5de1b06f0be3e23cd87436d">dg::l2norm</a>, rtol, atol);</div>
<div class="line">        <span class="keywordtype">int</span> counter=0;</div>
<div class="line">        <span class="keywordflow">while</span>( time &lt; T )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span>( time + dt &gt; T)</div>
<div class="line">                dt = T-time;</div>
<div class="line">            adapt.step( ex, im, time, y0, time, y0, dt, <a class="code" href="group__time__utils.html#gab60fda586e101a8aeb69efa31c46805c">dg::pid_control</a>, <a class="code" href="group__time__utils.html#ga6dc9be16f5de1b06f0be3e23cd87436d">dg::l2norm</a>, rtol, atol);</div>
<div class="line">            counter ++;</div>
<div class="line">        }</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stepper</td><td>A timestepper class that computes the actual timestep and an error estimate, for example an embedded Runge Kutta method <code><a class="el" href="structdg_1_1_e_r_k_step.html" title="Embedded Runge Kutta explicit time-step with error estimate.">dg::ERKStep</a></code> or the additive method <code><a class="el" href="structdg_1_1_a_r_k_step.html" title="Additive Runge Kutta (semi-implicit) time-step with error estimate following The ARKode library">dg::ARKStep</a></code>. But really, you can also choose to use your own timestepper class. The requirement is that there is a <code>step</code> member function that is called as <b>stepper.step( rhs, t0, u0, t1, u1, dt, delta)</b> or <b>stepper.step( ex, im, t0, u0, t1, u1, dt, delta)</b> depending on whether a purely explicit/implicit or a semi-implicit stepper is used. Here, t0, t1 and dt are of type <b>Stepper::value_type</b>, u0,u1 and delta are vector types of type <b>Stepper::container_type&amp;</b> and rhs, ex and im are functors implementing the equations that are forwarded from the caller. The parameters t1, u1 and delta are output parameters and must be updated by the stepper. The <code>Stepper</code> must have the <code>order()</code> and <code>embedded_order()</code> member functions that return the (global) order of the method and its error estimate. The <code> const ContainerType&amp; copyable()const; </code> member must return a container of the size that is later used in <code>step</code> (it does not matter what values <code>copyable</code> contains, but its size is important; the <code>step</code> method can only be called with vectors of this size) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On step rejection, choosing timesteps and introducing restrictions on the controller: here is a quote from professor G. Söderlind (the master of control functions) from a private e-mail conversation:</dd>
<dd>
"The issue is that most controllers are best left to do their work without interference. Each time one interferes with the control loop, one creates a transient that has to be dealt with by the controller.</dd>
<dd>
It is indeed necessary to reject steps every once in a while, but I usually try to avoid it to the greatest possible extent. In my opinion, the fear of having a too large error on some steps is vastly exaggerated. You see, in some steps the error is too large, and in others it is too small, and all controllers I constructed are designed to be “expectation value correct” in the sense that if the errors are random, the too large and too small errors basically cancel in the long run.</dd>
<dd>
Even so, there are times when the error is way out of proportion. But I usually accept an error that is up to, say 2*TOL, which typically won’t cause any problems. Of course, if one hits a sharp change in the solution, the error may be much larger, and the step recomputed. But then one must “reset" the controller, i.e., the controller keeps back information, and it is better to restart the controller to avoid back information to affect the next step." </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Should you use this class instead of a fixed stepsize Multistep say? The thing to consider especially when solving partial differential equations, is that the right hand side might be very costly to evaluate. An adaptive stepper (especially one-step methods) usually calls this right hand side more often than a multistep (only one call per step). The additional computation of the error norm in the <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep integration.">Adaptive</a> step might also be important since the norm requires global communication in a parallel program (bad for scaling to many nodes). So does the <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep integration.">Adaptive</a> timestepper make up for its increased cost throught the adaption of the stepsize? In some cases the answer might be a sound Yes. Especially when there are velocity peaks in the solution the multistep timestep might be restricted too much. In other cases when the timestep does not need to be adapted much, a multistep method can be faster. In any case the big advantage of <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep integration.">Adaptive</a> is that it usually just works (even though it is not fool-proof) and you do not have to spend time finding a suitable timestep like in the multistep method. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9b0066793e3a3e9d5159da5c12dfb4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0066793e3a3e9d5159da5c12dfb4b3">&#9670;&nbsp;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::<a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> =  typename Stepper::container_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of the vector class in use by <code>Stepper</code> </p>

</div>
</div>
<a id="a6c48d0d136681f6c6810e41538fb8771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c48d0d136681f6c6810e41538fb8771">&#9670;&nbsp;</a></span>stepper_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::<a class="el" href="structdg_1_1_adaptive.html#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a> =  Stepper</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f64c811c0abb1a6aa871d4bf7b868a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f64c811c0abb1a6aa871d4bf7b868a0">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::<a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> =  typename Stepper::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the value type of the time variable defined by <code>Stepper</code> (float or double) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae5cb5e4317ad65086f4272a6a48b69e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cb5e4317ad65086f4272a6a48b69e2">&#9670;&nbsp;</a></span>Adaptive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<div class="memtemplate">
template&lt;class ... StepperParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::<a class="el" href="structdg_1_1_adaptive.html">Adaptive</a> </td>
          <td>(</td>
          <td class="paramtype">StepperParams &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate workspace and construct stepper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>All parameters are forwarded to the constructor of <code>Stepper</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StepperParams</td><td>Type of parameters (deduced by the compiler) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The workspace for <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep integration.">Adaptive</a> is constructed from the <code>copyable</code> member of Stepper </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad11328919ed0d30e7e8719cd2f7629a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11328919ed0d30e7e8719cd2f7629a2">&#9670;&nbsp;</a></span>failed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::failed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the last stepsize in step was rejected. </p>

</div>
</div>
<a id="a2cdd79d57b8a9dd603329fd4ad9bce21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdd79d57b8a9dd603329fd4ad9bce21">&#9670;&nbsp;</a></span>guess_stepsize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<div class="memtemplate">
template&lt;class Explicit , class ErrorNorm &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_adaptive.html">Adaptive</a>&lt; Stepper &gt;::<a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::guess_stepsize </td>
          <td>(</td>
          <td class="paramtype">Explicit &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorNorm &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td>
          <td class="paramname"><em>rtol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td>
          <td class="paramname"><em>atol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Guess an initial stepsize. </p>
<p>If you have wondered what stepsize you should choose in the beginning, don't freak out about it. Really, the initial stepsize is not that important, the stepper does not even have to succeed. Usually the control function will very(!) quickly adapt the stepsize in just one or two steps (even if it's several orders of magnitude off in the beginning).</p>
<p>Currently, this function won't do much better than if you just choose a smallish number yourself, but it's there for future improvements. </p>

</div>
</div>
<a id="adee6c1ddddcd48be9002574df4b33b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee6c1ddddcd48be9002574df4b33b10">&#9670;&nbsp;</a></span>step() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<div class="memtemplate">
template&lt;class Explicit , class Implicit , class ControlFunction  = value_type (value_type, value_type, value_type, value_type, unsigned, unsigned), class ErrorNorm  = value_type( const container_type&amp;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::step </td>
          <td>(</td>
          <td class="paramtype">Explicit &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Implicit &amp;&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFunction &amp;&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorNorm &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td>
          <td class="paramname"><em>rtol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td>
          <td class="paramname"><em>atol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Semi-implicit adaptive step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>initial time </td></tr>
    <tr><td class="paramname">u0</td><td>value at <code>t0</code> </td></tr>
    <tr><td class="paramname">t1</td><td>(write only) end time ( equals <code>t0+dt</code> on output if the step was accepted, otherwise equals <code>t0</code>, may alias <code>t0</code>) </td></tr>
    <tr><td class="paramname">u1</td><td>(write only) contains the updated result on output if the step was accepted, otherwise a copy of <code>u0</code> (may alias <code>u0</code>) </td></tr>
    <tr><td class="paramname">dt</td><td>on input: timestep to try out (see <a class="el" href="structdg_1_1_adaptive.html#a2cdd79d57b8a9dd603329fd4ad9bce21" title="Guess an initial stepsize.">dg::Adaptive::guess_stepsize()</a> for an initial stepsize). On output: stepsize proposed by the controller that can be used to continue the integration in the next step. </td></tr>
    <tr><td class="paramname">control</td><td>The control function. Usually <code><a class="el" href="group__time__utils.html#gab60fda586e101a8aeb69efa31c46805c">dg::pid_control</a></code> is a good choice. The task of the control function is to compute a new timestep size based on the old timestep size, the order of the method and the past error(s) </td></tr>
    <tr><td class="paramname">norm</td><td>The error norm. Usually <code><a class="el" href="group__time__utils.html#ga6dc9be16f5de1b06f0be3e23cd87436d" title="Compute.">dg::l2norm</a></code> is a good choice, but for very small vector sizes the time for the binary reproducible dot product might become a performance bottleneck. Then it's time for your own implementation. </td></tr>
    <tr><td class="paramname">rtol</td><td>the desired relative accuracy. Usually 1e-5 is a good choice. </td></tr>
    <tr><td class="paramname">atol</td><td>the desired absolute accuracy. Usually 1e-10 is a good choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Try not to mess with dt. The controller is best left alone and it does a very good job choosing timesteps. But how do I output my solution at certain (equidistant) timesteps? First, think about if you really, really need that. Why is it so bad to have output at non-equidistant timesteps? If you are still firm, then consider using an interpolation scheme (cf. <code><a class="el" href="structdg_1_1_extrapolation.html" title="Extrapolate a polynomial passing through up to three points.">dg::Extrapolation</a></code>). Let choosing the timestep yourself be the very last option if the others are not viable </dd>
<dd>
For partial differential equations the exact value of <code>rtol</code> and <code>atol</code> might not be important. Due to the CFL condition there might be a sharp barrier in the range of possible stepsizes and the controller usually does a good job finding it and keeping the timestep "just right". However, don't make <code>rtol</code> too small, <code>1e-1</code> say, since then the controller might get too close to the CFL barrier. The timestepper is still able to crash, mind, even though the chances of that happening are somewhat lower than in a fixed stepsize method.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Explicit</td><td>The explicit part of the right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = f(t, y) translates to f(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. </td></tr>
    <tr><td class="paramname">Implicit</td><td>The implicit part of the right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = f(t, y) translates to f(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. Furthermore, if the <code><a class="el" href="structdg_1_1_default_solver.html" title="Default Solver class for solving.">DefaultSolver</a></code> is used, the routines weights(), inv_weights() and precond() must be callable and return diagonal weights, inverse weights and the preconditioner for the conjugate gradient method. The return type of these member functions must be useable in <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions together with the ContainerType type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>explic part </td></tr>
    <tr><td class="paramname">im</td><td>implicit part ( must be linear in its second argument and symmetric up to weights)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ControlFunction</td><td>function or Functor called as dt' = control( dt, eps0, eps1, eps2, order, embedded_order), where all parameters are of type value_type except the last two, which are unsigned. </td></tr>
    <tr><td class="paramname">ErrorNorm</td><td>function or Functor of type value_type( const ContainerType&amp;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a6703b0c64623025c54dcdf3be51d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6703b0c64623025c54dcdf3be51d9b">&#9670;&nbsp;</a></span>step() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<div class="memtemplate">
template&lt;class RHS , class ControlFunction  = value_type (value_type, value_type, value_type, value_type, unsigned, unsigned), class ErrorNorm  = value_type( const container_type&amp;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::step </td>
          <td>(</td>
          <td class="paramtype">RHS &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFunction &amp;&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorNorm &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td>
          <td class="paramname"><em>rtol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a>&#160;</td>
          <td class="paramname"><em>atol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit or Implicit adaptive step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right hand side of the equation to integrate</td></tr>
    <tr><td class="paramname">t0</td><td>initial time </td></tr>
    <tr><td class="paramname">u0</td><td>value at <code>t0</code> </td></tr>
    <tr><td class="paramname">t1</td><td>(write only) end time ( equals <code>t0+dt</code> on output if the step was accepted, otherwise equals <code>t0</code>, may alias <code>t0</code>) </td></tr>
    <tr><td class="paramname">u1</td><td>(write only) contains the updated result on output if the step was accepted, otherwise a copy of <code>u0</code> (may alias <code>u0</code>) </td></tr>
    <tr><td class="paramname">dt</td><td>on input: timestep to try out (see <a class="el" href="structdg_1_1_adaptive.html#a2cdd79d57b8a9dd603329fd4ad9bce21" title="Guess an initial stepsize.">dg::Adaptive::guess_stepsize()</a> for an initial stepsize). On output: stepsize proposed by the controller that can be used to continue the integration in the next step. </td></tr>
    <tr><td class="paramname">control</td><td>The control function. Usually <code><a class="el" href="group__time__utils.html#gab60fda586e101a8aeb69efa31c46805c">dg::pid_control</a></code> is a good choice. The task of the control function is to compute a new timestep size based on the old timestep size, the order of the method and the past error(s) </td></tr>
    <tr><td class="paramname">norm</td><td>The error norm. Usually <code><a class="el" href="group__time__utils.html#ga6dc9be16f5de1b06f0be3e23cd87436d" title="Compute.">dg::l2norm</a></code> is a good choice, but for very small vector sizes the time for the binary reproducible dot product might become a performance bottleneck. Then it's time for your own implementation. </td></tr>
    <tr><td class="paramname">rtol</td><td>the desired relative accuracy. Usually 1e-5 is a good choice. </td></tr>
    <tr><td class="paramname">atol</td><td>the desired absolute accuracy. Usually 1e-10 is a good choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Try not to mess with dt. The controller is best left alone and it does a very good job choosing timesteps. But how do I output my solution at certain (equidistant) timesteps? First, think about if you really, really need that. Why is it so bad to have output at non-equidistant timesteps? If you are still firm, then consider using an interpolation scheme (cf. <code><a class="el" href="structdg_1_1_extrapolation.html" title="Extrapolate a polynomial passing through up to three points.">dg::Extrapolation</a></code>). Let choosing the timestep yourself be the very last option if the others are not viable </dd>
<dd>
For partial differential equations the exact value of <code>rtol</code> and <code>atol</code> might not be important. Due to the CFL condition there might be a sharp barrier in the range of possible stepsizes and the controller usually does a good job finding it and keeping the timestep "just right". However, don't make <code>rtol</code> too small, <code>1e-1</code> say, since then the controller might get too close to the CFL barrier. The timestepper is still able to crash, mind, even though the chances of that happening are somewhat lower than in a fixed stepsize method.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RHS</td><td>The right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = f(t, y) translates to f(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor.</td></tr>
    <tr><td class="paramname">ControlFunction</td><td>function or Functor called as dt' = control( dt, eps0, eps1, eps2, order, embedded_order), where all parameters are of type value_type except the last two, which are unsigned. </td></tr>
    <tr><td class="paramname">ErrorNorm</td><td>function or Functor of type value_type( const ContainerType&amp;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db5dcb26199b603e01081481cc61f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db5dcb26199b603e01081481cc61f04">&#9670;&nbsp;</a></span>stepper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_adaptive.html#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a>&amp; <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::stepper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow write access to internal stepper. </p>
<p>Maybe useful to set options in the stepper </p>

</div>
</div>
<a id="aa335991e84bb465ad12640027010cfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa335991e84bb465ad12640027010cfa4">&#9670;&nbsp;</a></span>stepper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdg_1_1_adaptive.html#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a>&amp; <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::stepper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read access to internal stepper. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="adaptive_8h_source.html">adaptive.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astructdg_1_1_adaptive_html"><div class="ttname"><a href="structdg_1_1_adaptive.html">dg::Adaptive</a></div><div class="ttdoc">Driver class for adaptive timestep integration.</div><div class="ttdef"><b>Definition:</b> adaptive.h:175</div></div>
<div class="ttc" id="agroup__creation_html_ggabf9ea3df33484cbb5886e257c3899e48a573a4a72e7f55df92b88c254a13762f2"><div class="ttname"><a href="group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a573a4a72e7f55df92b88c254a13762f2">dg::forward</a></div><div class="ttdeci">@ forward</div><div class="ttdoc">forward derivative (cell to the right and current cell)</div><div class="ttdef"><b>Definition:</b> enums.h:104</div></div>
<div class="ttc" id="agroup__time__utils_html_gab60fda586e101a8aeb69efa31c46805c"><div class="ttname"><a href="group__time__utils.html#gab60fda586e101a8aeb69efa31c46805c">dg::pid_control</a></div><div class="ttdeci">value_type pid_control(value_type dt_old, value_type eps_0, value_type eps_1, value_type eps_2, unsigned embedded_order, unsigned order)</div><div class="ttdef"><b>Definition:</b> adaptive.h:41</div></div>
<div class="ttc" id="agroup__time__utils_html_ga6dc9be16f5de1b06f0be3e23cd87436d"><div class="ttname"><a href="group__time__utils.html#ga6dc9be16f5de1b06f0be3e23cd87436d">dg::l2norm</a></div><div class="ttdeci">get_value_type&lt; ContainerType &gt; l2norm(const ContainerType &amp;x)</div><div class="ttdoc">Compute.</div><div class="ttdef"><b>Definition:</b> adaptive.h:19</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_adaptive.html">Adaptive</a></li>
    <li class="footer">Generated on Tue Feb 23 2021 15:27:09 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
