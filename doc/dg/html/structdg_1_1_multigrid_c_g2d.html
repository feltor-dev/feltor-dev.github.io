<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Discontinuous Galerkin Library: dg::MultigridCG2d&lt; Geometry, Matrix, Container &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Container free algorithms and discontinuous Galerkin numerical methods in &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structdg_1_1_multigrid_c_g2d.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_multigrid_c_g2d-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::MultigridCG2d&lt; Geometry, Matrix, Container &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__numerical1.html">Level 4: Advanced numerical schemes</a> &raquo; <a class="el" href="group__multigrid.html">Multigrid matrix inversion</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Solves the Equation.  
 <a href="structdg_1_1_multigrid_c_g2d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="multigrid_8h_source.html">multigrid.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9f15aac16dcdb67f310e0af621b538c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a9f15aac16dcdb67f310e0af621b538c7">geometry_type</a> = Geometry</td></tr>
<tr class="separator:a9f15aac16dcdb67f310e0af621b538c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb757d36ec9ffe31587b3d93796e6b94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#aeb757d36ec9ffe31587b3d93796e6b94">matrix_type</a> = Matrix</td></tr>
<tr class="separator:aeb757d36ec9ffe31587b3d93796e6b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4241083bbf815e345cbbe751e4e6d44"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#ae4241083bbf815e345cbbe751e4e6d44">container_type</a> = Container</td></tr>
<tr class="separator:ae4241083bbf815e345cbbe751e4e6d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cc3f8e39468ef4b723d00e11b48601"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> = <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; Container &gt;</td></tr>
<tr class="separator:a31cc3f8e39468ef4b723d00e11b48601"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a502323c42d6f651ea5ef5ab6d6a69127"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a502323c42d6f651ea5ef5ab6d6a69127">MultigridCG2d</a> ()</td></tr>
<tr class="memdesc:a502323c42d6f651ea5ef5ab6d6a69127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate nothing, Call <code>construct</code> method before usage.  <a href="structdg_1_1_multigrid_c_g2d.html#a502323c42d6f651ea5ef5ab6d6a69127">More...</a><br /></td></tr>
<tr class="separator:a502323c42d6f651ea5ef5ab6d6a69127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d382d16337a5d055fa7ed675761870"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:ae3d382d16337a5d055fa7ed675761870"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#ae3d382d16337a5d055fa7ed675761870">MultigridCG2d</a> (const Geometry &amp;<a class="el" href="structdg_1_1_multigrid_c_g2d.html#ac08058a7c4d83d0414dbc1a682ac38cb">grid</a>, const unsigned <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a7659e4d18315604a75b8f92f4266aba1">stages</a>, Params &amp;&amp;... ps)</td></tr>
<tr class="memdesc:ae3d382d16337a5d055fa7ed675761870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the grids and the interpolation/projection operators.  <a href="structdg_1_1_multigrid_c_g2d.html#ae3d382d16337a5d055fa7ed675761870">More...</a><br /></td></tr>
<tr class="separator:ae3d382d16337a5d055fa7ed675761870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c55c73ccca5ff891a977000da9612e8"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:a8c55c73ccca5ff891a977000da9612e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a8c55c73ccca5ff891a977000da9612e8">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:a8c55c73ccca5ff891a977000da9612e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.  <a href="structdg_1_1_multigrid_c_g2d.html#a8c55c73ccca5ff891a977000da9612e8">More...</a><br /></td></tr>
<tr class="separator:a8c55c73ccca5ff891a977000da9612e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f373eb2c53b09484688dfb06e9b7b33"><td class="memTemplParams" colspan="2">template&lt;class ContainerType0 &gt; </td></tr>
<tr class="memitem:a2f373eb2c53b09484688dfb06e9b7b33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a2f373eb2c53b09484688dfb06e9b7b33">project</a> (const ContainerType0 &amp;src, std::vector&lt; ContainerType0 &gt; &amp;out)</td></tr>
<tr class="memdesc:a2f373eb2c53b09484688dfb06e9b7b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project vector to all involved grids.  <a href="structdg_1_1_multigrid_c_g2d.html#a2f373eb2c53b09484688dfb06e9b7b33">More...</a><br /></td></tr>
<tr class="separator:a2f373eb2c53b09484688dfb06e9b7b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0944d4eb8fc62b500ec8368ae6f5b9aa"><td class="memTemplParams" colspan="2">template&lt;class ContainerType0 &gt; </td></tr>
<tr class="memitem:a0944d4eb8fc62b500ec8368ae6f5b9aa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ContainerType0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a0944d4eb8fc62b500ec8368ae6f5b9aa">project</a> (const ContainerType0 &amp;src)</td></tr>
<tr class="memdesc:a0944d4eb8fc62b500ec8368ae6f5b9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project vector to all involved grids (allocate memory version)  <a href="structdg_1_1_multigrid_c_g2d.html#a0944d4eb8fc62b500ec8368ae6f5b9aa">More...</a><br /></td></tr>
<tr class="separator:a0944d4eb8fc62b500ec8368ae6f5b9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7659e4d18315604a75b8f92f4266aba1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a7659e4d18315604a75b8f92f4266aba1">stages</a> () const</td></tr>
<tr class="separator:a7659e4d18315604a75b8f92f4266aba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec75fbb948aa597f8d7c227a395028f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#adec75fbb948aa597f8d7c227a395028f">num_stages</a> () const</td></tr>
<tr class="separator:adec75fbb948aa597f8d7c227a395028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08058a7c4d83d0414dbc1a682ac38cb"><td class="memItemLeft" align="right" valign="top">const Geometry &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#ac08058a7c4d83d0414dbc1a682ac38cb">grid</a> (unsigned stage) const</td></tr>
<tr class="separator:ac08058a7c4d83d0414dbc1a682ac38cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f4c33e61798f03fc0241e76c54efa"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#ab94f4c33e61798f03fc0241e76c54efa">max_iter</a> () const</td></tr>
<tr class="separator:ab94f4c33e61798f03fc0241e76c54efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989c84ae52827ff0872b1778e3f0ba50"><td class="memItemLeft" align="right" valign="top">const Container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a989c84ae52827ff0872b1778e3f0ba50">copyable</a> () const</td></tr>
<tr class="memdesc:a989c84ae52827ff0872b1778e3f0ba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an object of same size as the object used for construction on the finest grid.  <a href="structdg_1_1_multigrid_c_g2d.html#a989c84ae52827ff0872b1778e3f0ba50">More...</a><br /></td></tr>
<tr class="separator:a989c84ae52827ff0872b1778e3f0ba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae25504a08ab6099b26d0d0fc2e6b9e9"><td class="memTemplParams" colspan="2">template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </td></tr>
<tr class="memitem:aae25504a08ab6099b26d0d0fc2e6b9e9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#aae25504a08ab6099b26d0d0fc2e6b9e9">direct_solve</a> (std::vector&lt; SymmetricOp &gt; &amp;op, ContainerType0 &amp;x, const ContainerType1 &amp;b, <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> eps)</td></tr>
<tr class="memdesc:aae25504a08ab6099b26d0d0fc2e6b9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">USE THIS <a class="el" href="structdg_1_1_o_n_e.html">ONE</a> Nested iterations.  <a href="structdg_1_1_multigrid_c_g2d.html#aae25504a08ab6099b26d0d0fc2e6b9e9">More...</a><br /></td></tr>
<tr class="separator:aae25504a08ab6099b26d0d0fc2e6b9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79be0c46d85e3b5f9161310a2783f848"><td class="memTemplParams" colspan="2">template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </td></tr>
<tr class="memitem:a79be0c46d85e3b5f9161310a2783f848"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a79be0c46d85e3b5f9161310a2783f848">direct_solve</a> (std::vector&lt; SymmetricOp &gt; &amp;op, ContainerType0 &amp;x, const ContainerType1 &amp;b, std::vector&lt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt; eps)</td></tr>
<tr class="memdesc:a79be0c46d85e3b5f9161310a2783f848"><td class="mdescLeft">&#160;</td><td class="mdescRight">USE THIS <a class="el" href="structdg_1_1_o_n_e.html">ONE</a> Nested iterations.  <a href="structdg_1_1_multigrid_c_g2d.html#a79be0c46d85e3b5f9161310a2783f848">More...</a><br /></td></tr>
<tr class="separator:a79be0c46d85e3b5f9161310a2783f848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b656572ff3ce3406472887581084059"><td class="memTemplParams" colspan="2">template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </td></tr>
<tr class="memitem:a9b656572ff3ce3406472887581084059"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a9b656572ff3ce3406472887581084059">direct_solve_with_chebyshev</a> (std::vector&lt; SymmetricOp &gt; &amp;op, ContainerType0 &amp;x, const ContainerType1 &amp;b, <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> eps, unsigned num_cheby)</td></tr>
<tr class="memdesc:a9b656572ff3ce3406472887581084059"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL Nested iterations with Chebyshev as preconditioner for <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a>.  <a href="structdg_1_1_multigrid_c_g2d.html#a9b656572ff3ce3406472887581084059">More...</a><br /></td></tr>
<tr class="separator:a9b656572ff3ce3406472887581084059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7b3467952a8b6c5bb85b24f2ac9c1b"><td class="memTemplParams" colspan="2">template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </td></tr>
<tr class="memitem:a8f7b3467952a8b6c5bb85b24f2ac9c1b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a8f7b3467952a8b6c5bb85b24f2ac9c1b">direct_solve_with_chebyshev</a> (std::vector&lt; SymmetricOp &gt; &amp;op, ContainerType0 &amp;x, const ContainerType1 &amp;b, std::vector&lt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt; eps, std::vector&lt; unsigned &gt; num_cheby)</td></tr>
<tr class="memdesc:a8f7b3467952a8b6c5bb85b24f2ac9c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL Nested iterations with Chebyshev as preconditioner for <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a>.  <a href="structdg_1_1_multigrid_c_g2d.html#a8f7b3467952a8b6c5bb85b24f2ac9c1b">More...</a><br /></td></tr>
<tr class="separator:a8f7b3467952a8b6c5bb85b24f2ac9c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbb59c01bddc244f83d12024b00b4df"><td class="memTemplParams" colspan="2">template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </td></tr>
<tr class="memitem:a2cbb59c01bddc244f83d12024b00b4df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a2cbb59c01bddc244f83d12024b00b4df">fmg_solve</a> (std::vector&lt; SymmetricOp &gt; &amp;op, ContainerType0 &amp;x, const ContainerType1 &amp;b, std::vector&lt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt; ev, unsigned nu_pre, unsigned nu_post, unsigned gamma, <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> eps)</td></tr>
<tr class="memdesc:a2cbb59c01bddc244f83d12024b00b4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL Full multigrid cycles (use at own risk)  <a href="structdg_1_1_multigrid_c_g2d.html#a2cbb59c01bddc244f83d12024b00b4df">More...</a><br /></td></tr>
<tr class="separator:a2cbb59c01bddc244f83d12024b00b4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeeb1224eebf10036ab940ec0edf396e"><td class="memTemplParams" colspan="2">template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </td></tr>
<tr class="memitem:aeeeb1224eebf10036ab940ec0edf396e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#aeeeb1224eebf10036ab940ec0edf396e">pcg_solve</a> (std::vector&lt; SymmetricOp &gt; &amp;op, ContainerType0 &amp;x, const ContainerType1 &amp;b, std::vector&lt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt; ev, unsigned nu_pre, unsigned nu_post, unsigned gamma, <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> eps)</td></tr>
<tr class="memdesc:aeeeb1224eebf10036ab940ec0edf396e"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL A conjugate gradient with a full multigrid cycle as preconditioner (use at own risk)  <a href="structdg_1_1_multigrid_c_g2d.html#aeeeb1224eebf10036ab940ec0edf396e">More...</a><br /></td></tr>
<tr class="separator:aeeeb1224eebf10036ab940ec0edf396e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Geometry, class Matrix, class Container&gt;<br />
struct dg::MultigridCG2d&lt; Geometry, Matrix, Container &gt;</h3>

<p>Solves the Equation. </p>
<p class="formulaDsp">
\[ \frac{1}{W} \hat O \phi = \rho \]
</p>
<p>using a multigrid algorithm for any operator \(\hat O\) that is symmetric and appropriate weights \(W\) (s. comment below).</p>
<div class="fragment"><div class="line">    <a class="code" href="classdg_1_1_timer.html">dg::Timer</a> t;</div>
<div class="line">    t.<a class="code" href="classdg_1_1_timer.html#ab3ff0dbe977c6151118227cfbd0aefb2">tic</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structdg_1_1_real_cartesian_grid2d.html">dg::CartesianGrid2d</a> <a class="code" href="structdg_1_1_multigrid_c_g2d.html#ac08058a7c4d83d0414dbc1a682ac38cb">grid</a>( 0, lx, 0, ly, n, Nx, Ny, bcx, bcy);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code" href="structdg_1_1_multigrid_c_g2d.html#a7659e4d18315604a75b8f92f4266aba1">stages</a> = 3;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d&lt;dg::aGeometry2d, dg::DMatrix, dg::DVec &gt;</a> multigrid( <a class="code" href="structdg_1_1_multigrid_c_g2d.html#ac08058a7c4d83d0414dbc1a682ac38cb">grid</a>, <a class="code" href="structdg_1_1_multigrid_c_g2d.html#a7659e4d18315604a75b8f92f4266aba1">stages</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> chi =  <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( pol, <a class="code" href="structdg_1_1_multigrid_c_g2d.html#ac08058a7c4d83d0414dbc1a682ac38cb">grid</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;dg::DVec&gt; multi_chi = multigrid.project( chi);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;dg::Elliptic&lt;dg::aGeometry2d, dg::DMatrix, dg::DVec&gt; &gt; multi_pol( <a class="code" href="structdg_1_1_multigrid_c_g2d.html#a7659e4d18315604a75b8f92f4266aba1">stages</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> u=0; u&lt;<a class="code" href="structdg_1_1_multigrid_c_g2d.html#a7659e4d18315604a75b8f92f4266aba1">stages</a>; u++)</div>
<div class="line">    {</div>
<div class="line">        multi_pol[u].construct( multigrid.grid(u), <a class="code" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066">dg::not_normed</a>, <a class="code" href="group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>, jfactor);</div>
<div class="line">        multi_pol[u].set_chi( multi_chi[u]);</div>
<div class="line">        multi_pol[u].set_jump_weighting(jump_weight);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    t.<a class="code" href="classdg_1_1_timer.html#afbe78fc3702a5c3d4263c2941745b8a7">toc</a>();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Creation of multigrid took: &quot;</span>&lt;&lt;t.<a class="code" href="classdg_1_1_timer.html#a27a84dc8acb525e9617cd34d64aad4ed">diff</a>()&lt;&lt;<span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> b =    <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( rhs,     <a class="code" href="structdg_1_1_multigrid_c_g2d.html#ac08058a7c4d83d0414dbc1a682ac38cb">grid</a>);</div>
<div class="line">    <a class="code" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>       =    <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( initial, <a class="code" href="structdg_1_1_multigrid_c_g2d.html#ac08058a7c4d83d0414dbc1a682ac38cb">grid</a>);</div>
<div class="line">    t.<a class="code" href="classdg_1_1_timer.html#ab3ff0dbe977c6151118227cfbd0aefb2">tic</a>();</div>
<div class="line">    std::vector&lt;unsigned&gt; number = multigrid.direct_solve(multi_pol, x, b, eps);</div>
<div class="line">    t.<a class="code" href="classdg_1_1_timer.html#afbe78fc3702a5c3d4263c2941745b8a7">toc</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solution took &quot;</span>&lt;&lt; t.<a class="code" href="classdg_1_1_timer.html#a27a84dc8acb525e9617cd34d64aad4ed">diff</a>() &lt;&lt;<span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> u=0; u&lt;number.size(); u++)</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; # iterations stage &quot;</span>&lt;&lt; number.size()-1-u &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; number[number.size()-1-u] &lt;&lt; <span class="stringliteral">&quot; \n&quot;</span>;</div>
</div><!-- fragment --><p>We use conjugate gradient (<a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a>) at each stage and refine the grids in the first two dimensions (2d / x and y) </p><dl class="section note"><dt>Note</dt><dd>A note on weights, inverse weights and preconditioning. A normalized DG-discretized derivative or operator is normally not symmetric. The diagonal coefficient matrix that is used to make the operator symmetric is called weights W, i.e. \( \hat O = W\cdot O\) is symmetric. Now, to compute the correct scalar product of the right hand side the inverse weights have to be used i.e. \( W\rho\cdot W \rho /W\). Independent from this, a preconditioner should be used to solve the symmetric matrix equation. </dd>
<dd>
The preconditioner for the <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a> solver is taken from the <code><a class="el" href="group__lowlevel.html#ga06ce516b4837f5aafde50b7883c11b83" title="Construct a diagonal operator with inverse weights.">precond()</a></code> method in the <code>SymmetricOp</code> class</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>A type that is or derives from one of the abstract geometry base classes ( <code>aGeometry2d</code>, <code>aGeometry3d</code>, <code>aMPIGeometry2d</code>, ...). <code>Geometry</code> determines which <code>Matrix</code> and <code>Container</code> types can be used: </td></tr>
    <tr><td class="paramname">Matrix</td><td>A class for which the <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions are callable in connection with the <code>Container</code> class and to which the return type of <code><a class="el" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85" title="Create 2d derivative in x-direction.">create::dx()</a></code> can be converted using <code><a class="el" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597" title="; Generic way to copy and/or convert a Matrix type to a different Matrix type">dg::blas2::transfer</a></code>. The <code>Matrix</code> type can be one of:<ul>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> and one of the MPI geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> and one of the MPI geometries </li>
</ul>
</td></tr>
    <tr><td class="paramname">Container</td><td>A data container class for which the <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functionality is overloaded and to which the return type of <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">blas1::subroutine()</a></code> can be converted using <code><a class="el" href="group__backend.html#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code>. We assume that <code>Container</code> is copyable/assignable and has a swap member function. In connection with <code>Geometry</code> this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> when <code>Geometry</code> is a shared memory geometry</li>
<li><code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> when <code>Geometry</code> is one of the MPI geometries</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1_extrapolation.html" title="Extrapolate a polynomial passing through up to three points.">Extrapolation</a></code> to generate an initial guess </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae4241083bbf815e345cbbe751e4e6d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4241083bbf815e345cbbe751e4e6d44">&#9670;&nbsp;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::<a class="el" href="structdg_1_1_multigrid_c_g2d.html#ae4241083bbf815e345cbbe751e4e6d44">container_type</a> =  Container</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f15aac16dcdb67f310e0af621b538c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f15aac16dcdb67f310e0af621b538c7">&#9670;&nbsp;</a></span>geometry_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::<a class="el" href="structdg_1_1_multigrid_c_g2d.html#a9f15aac16dcdb67f310e0af621b538c7">geometry_type</a> =  Geometry</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb757d36ec9ffe31587b3d93796e6b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb757d36ec9ffe31587b3d93796e6b94">&#9670;&nbsp;</a></span>matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::<a class="el" href="structdg_1_1_multigrid_c_g2d.html#aeb757d36ec9ffe31587b3d93796e6b94">matrix_type</a> =  Matrix</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31cc3f8e39468ef4b723d00e11b48601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cc3f8e39468ef4b723d00e11b48601">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::<a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> =  <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt;Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a502323c42d6f651ea5ef5ab6d6a69127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502323c42d6f651ea5ef5ab6d6a69127">&#9670;&nbsp;</a></span>MultigridCG2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::<a class="el" href="structdg_1_1_multigrid_c_g2d.html">MultigridCG2d</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate nothing, Call <code>construct</code> method before usage. </p>

</div>
</div>
<a id="ae3d382d16337a5d055fa7ed675761870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d382d16337a5d055fa7ed675761870">&#9670;&nbsp;</a></span>MultigridCG2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::<a class="el" href="structdg_1_1_multigrid_c_g2d.html">MultigridCG2d</a> </td>
          <td>(</td>
          <td class="paramtype">const Geometry &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>stages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the grids and the interpolation/projection operators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the original grid (Nx() and Ny() must be evenly divisable by pow(2, stages-1) </td></tr>
    <tr><td class="paramname">stages</td><td>number of grids in total (The second grid contains half the points of the original grids, The third grid contains half of the second grid ...). Must be &gt; 1 </td></tr>
    <tr><td class="paramname">ps</td><td>parameters necessary for <code><a class="el" href="group__backend.html#ga5dbfc632d4d66d2d926dd525ed7fcea8" title="Generic way to construct an object of ContainerType given a from_ContainerType object and optional ad...">dg::construct</a></code> to construct a <code>Container</code> from a <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c55c73ccca5ff891a977000da9612e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c55c73ccca5ff891a977000da9612e8">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a989c84ae52827ff0872b1778e3f0ba50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989c84ae52827ff0872b1778e3f0ba50">&#9670;&nbsp;</a></span>copyable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Container&amp; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::copyable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an object of same size as the object used for construction on the finest grid. </p>
<dl class="section return"><dt>Returns</dt><dd>A copyable object; what it contains is undefined, its size is important </dd></dl>

</div>
</div>
<a id="a79be0c46d85e3b5f9161310a2783f848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79be0c46d85e3b5f9161310a2783f848">&#9670;&nbsp;</a></span>direct_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned&gt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::direct_solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SymmetricOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>USE THIS <a class="el" href="structdg_1_1_o_n_e.html">ONE</a> Nested iterations. </p>
<p>Equivalent to the following</p><ol type="1">
<li>Compute residual with given initial guess.</li>
<li>Project residual down to the coarsest grid.</li>
<li>Solve equation on the coarse grid.</li>
<li>interpolate solution up to next finer grid and repeat 3 and 4 until the original grid is reached. <dl class="section note"><dt>Note</dt><dd>The preconditioner for the <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a> solver is taken from the <code><a class="el" href="group__lowlevel.html#ga06ce516b4837f5aafde50b7883c11b83" title="Construct a diagonal operator with inverse weights.">precond()</a></code> method in the <code>SymmetricOp</code> class</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymmetricOp</td><td>A class for which the <code>blas2::symv(Matrix&amp;, Vector1&amp;, Vector2&amp;)</code> function is callable with the <code>Container</code> type as argument. Also, The functions <code>inv_weights</code>() and <code>precond</code>() need to be callable and return inverse weights and the preconditioner for the conjugate gradient method. <code>SymmetricOp</code> is assumed to be linear, symmetric and positive definite! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>you can make your own <code>SymmetricOp</code> by providing the member function <code>void</code> <code>symv(const Container&amp;, Container&amp;)</code>; and specializing <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> with the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> as the <code>tensor_category</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerTypes</td><td>must be usable with <code>Container</code> in <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Index 0 is the <code>SymmetricOp</code> on the original grid, 1 on the half grid, 2 on the quarter grid, ... </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) contains initial guess on input and the solution on output </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side (will be multiplied by <code>weights</code>) </td></tr>
    <tr><td class="paramname">eps</td><td>the accuracy: iteration stops if \( ||b - Ax|| &lt; \epsilon( ||b|| + 1) \). If needed (and it is recommended to tune these values) the accuracy can be set for each stage separately. Per default the same accuracy is used at all stages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations in each of the stages beginning with the finest grid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the Macro <code>DG_BENCHMARK</code> is defined this function will write timings to <code>std::cout</code> </dd></dl>
</li>
</ol>

</div>
</div>
<a id="aae25504a08ab6099b26d0d0fc2e6b9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae25504a08ab6099b26d0d0fc2e6b9e9">&#9670;&nbsp;</a></span>direct_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned&gt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::direct_solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SymmetricOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a>&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>USE THIS <a class="el" href="structdg_1_1_o_n_e.html">ONE</a> Nested iterations. </p>
<p>Equivalent to the following</p><ol type="1">
<li>Compute residual with given initial guess.</li>
<li>Project residual down to the coarsest grid.</li>
<li>Solve equation on the coarse grid.</li>
<li>interpolate solution up to next finer grid and repeat 3 and 4 until the original grid is reached. <dl class="section note"><dt>Note</dt><dd>The preconditioner for the <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a> solver is taken from the <code><a class="el" href="group__lowlevel.html#ga06ce516b4837f5aafde50b7883c11b83" title="Construct a diagonal operator with inverse weights.">precond()</a></code> method in the <code>SymmetricOp</code> class</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymmetricOp</td><td>A class for which the <code>blas2::symv(Matrix&amp;, Vector1&amp;, Vector2&amp;)</code> function is callable with the <code>Container</code> type as argument. Also, The functions <code>inv_weights</code>() and <code>precond</code>() need to be callable and return inverse weights and the preconditioner for the conjugate gradient method. <code>SymmetricOp</code> is assumed to be linear, symmetric and positive definite! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>you can make your own <code>SymmetricOp</code> by providing the member function <code>void</code> <code>symv(const Container&amp;, Container&amp;)</code>; and specializing <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> with the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> as the <code>tensor_category</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerTypes</td><td>must be usable with <code>Container</code> in <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Index 0 is the <code>SymmetricOp</code> on the original grid, 1 on the half grid, 2 on the quarter grid, ... </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) contains initial guess on input and the solution on output </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side (will be multiplied by <code>weights</code>) </td></tr>
    <tr><td class="paramname">eps</td><td>the accuracy: iteration stops if \( ||b - Ax|| &lt; \epsilon( ||b|| + 1) \). If needed (and it is recommended to tune these values) the accuracy can be set for each stage separately. Per default the same accuracy is used at all stages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations in each of the stages beginning with the finest grid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the Macro <code>DG_BENCHMARK</code> is defined this function will write timings to <code>std::cout</code> </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a8f7b3467952a8b6c5bb85b24f2ac9c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7b3467952a8b6c5bb85b24f2ac9c1b">&#9670;&nbsp;</a></span>direct_solve_with_chebyshev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned&gt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::direct_solve_with_chebyshev </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SymmetricOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>num_cheby</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>EXPERIMENTAL Nested iterations with Chebyshev as preconditioner for <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function does the same as direct_solve but uses a <a class="el" href="structdg_1_1_chebyshev_preconditioner.html" title="Chebyshev Polynomial Preconditioner.">ChebyshevPreconditioner</a> (with <a class="el" href="classdg_1_1_e_v_e.html" title="The Eigen-Value-Estimator (EVE) finds largest Eigenvalue of.">EVE</a> to estimate the largest EV) at the coarse grid levels (but not the fine level). Equivalent to the following<ol type="1">
<li>Compute residual with given initial guess.</li>
<li>Project residual down to the coarsest grid.</li>
<li>Solve equation on the coarse grid.</li>
<li>interpolate solution up to next finer grid and repeat 3 and 4 until the original grid is reached. </li>
</ol>
</dd>
<dd>
The preconditioner for the <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a> solver is taken from the <code><a class="el" href="group__lowlevel.html#ga06ce516b4837f5aafde50b7883c11b83" title="Construct a diagonal operator with inverse weights.">precond()</a></code> method in the <code>SymmetricOp</code> class</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymmetricOp</td><td>A class for which the <code>blas2::symv(Matrix&amp;, Vector1&amp;, Vector2&amp;)</code> function is callable with the <code>Container</code> type as argument. Also, The functions <code>inv_weights</code>() and <code>precond</code>() need to be callable and return inverse weights and the preconditioner for the conjugate gradient method. <code>SymmetricOp</code> is assumed to be linear, symmetric and positive definite! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>you can make your own <code>SymmetricOp</code> by providing the member function <code>void</code> <code>symv(const Container&amp;, Container&amp;)</code>; and specializing <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> with the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> as the <code>tensor_category</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerTypes</td><td>must be usable with <code>Container</code> in <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Index 0 is the <code>SymmetricOp</code> on the original grid, 1 on the half grid, 2 on the quarter grid, ... </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) contains initial guess on input and the solution on output </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side (will be multiplied by <code>weights</code>) </td></tr>
    <tr><td class="paramname">eps</td><td>the accuracy: iteration stops if \( ||b - Ax|| &lt; \epsilon( ||b|| + 1) \). If needed (and it is recommended to tune these values) the accuracy can be set for each stage separately. Per default the same accuracy is used at all stages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations in each of the stages beginning with the finest grid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the Macro <code>DG_BENCHMARK</code> is defined this function will write timings to <code>std::cout</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_cheby</td><td>Number of chebyshev iterations. If needed can be set for each stage separately. Per default it is the same for all stages. The 0 stage does not use the Chebyshev preconditioner, therefore num_cheby[0] will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b656572ff3ce3406472887581084059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b656572ff3ce3406472887581084059">&#9670;&nbsp;</a></span>direct_solve_with_chebyshev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned&gt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::direct_solve_with_chebyshev </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SymmetricOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a>&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_cheby</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>EXPERIMENTAL Nested iterations with Chebyshev as preconditioner for <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function does the same as direct_solve but uses a <a class="el" href="structdg_1_1_chebyshev_preconditioner.html" title="Chebyshev Polynomial Preconditioner.">ChebyshevPreconditioner</a> (with <a class="el" href="classdg_1_1_e_v_e.html" title="The Eigen-Value-Estimator (EVE) finds largest Eigenvalue of.">EVE</a> to estimate the largest EV) at the coarse grid levels (but not the fine level). Equivalent to the following<ol type="1">
<li>Compute residual with given initial guess.</li>
<li>Project residual down to the coarsest grid.</li>
<li>Solve equation on the coarse grid.</li>
<li>interpolate solution up to next finer grid and repeat 3 and 4 until the original grid is reached. </li>
</ol>
</dd>
<dd>
The preconditioner for the <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a> solver is taken from the <code><a class="el" href="group__lowlevel.html#ga06ce516b4837f5aafde50b7883c11b83" title="Construct a diagonal operator with inverse weights.">precond()</a></code> method in the <code>SymmetricOp</code> class</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymmetricOp</td><td>A class for which the <code>blas2::symv(Matrix&amp;, Vector1&amp;, Vector2&amp;)</code> function is callable with the <code>Container</code> type as argument. Also, The functions <code>inv_weights</code>() and <code>precond</code>() need to be callable and return inverse weights and the preconditioner for the conjugate gradient method. <code>SymmetricOp</code> is assumed to be linear, symmetric and positive definite! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>you can make your own <code>SymmetricOp</code> by providing the member function <code>void</code> <code>symv(const Container&amp;, Container&amp;)</code>; and specializing <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> with the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> as the <code>tensor_category</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerTypes</td><td>must be usable with <code>Container</code> in <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Index 0 is the <code>SymmetricOp</code> on the original grid, 1 on the half grid, 2 on the quarter grid, ... </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) contains initial guess on input and the solution on output </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side (will be multiplied by <code>weights</code>) </td></tr>
    <tr><td class="paramname">eps</td><td>the accuracy: iteration stops if \( ||b - Ax|| &lt; \epsilon( ||b|| + 1) \). If needed (and it is recommended to tune these values) the accuracy can be set for each stage separately. Per default the same accuracy is used at all stages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations in each of the stages beginning with the finest grid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the Macro <code>DG_BENCHMARK</code> is defined this function will write timings to <code>std::cout</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_cheby</td><td>Number of chebyshev iterations. If needed can be set for each stage separately. Per default it is the same for all stages. The 0 stage does not use the Chebyshev preconditioner, therefore num_cheby[0] will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cbb59c01bddc244f83d12024b00b4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbb59c01bddc244f83d12024b00b4df">&#9670;&nbsp;</a></span>fmg_solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::fmg_solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SymmetricOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nu_pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nu_post</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a>&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>EXPERIMENTAL Full multigrid cycles (use at own risk) </p>
<ul>
<li>Compute residual with given initial guess.</li>
<li>If error larger than tolerance, do a full multigrid cycle with Chebeyshev iterations as smoother</li>
<li>repeat <dl class="section note"><dt>Note</dt><dd>The preconditioner for the <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a> solver is taken from the <code><a class="el" href="group__lowlevel.html#ga06ce516b4837f5aafde50b7883c11b83" title="Construct a diagonal operator with inverse weights.">precond()</a></code> method in the <code>SymmetricOp</code> class</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymmetricOp</td><td>A class for which the <code>blas2::symv(Matrix&amp;, Vector1&amp;, Vector2&amp;)</code> function is callable with the <code>Container</code> type as argument. Also, The functions <code>inv_weights</code>() and <code>precond</code>() need to be callable and return inverse weights and the preconditioner for the conjugate gradient method. <code>SymmetricOp</code> is assumed to be linear, symmetric and positive definite! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>you can make your own <code>SymmetricOp</code> by providing the member function <code>void</code> <code>symv(const Container&amp;, Container&amp;)</code>; and specializing <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> with the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> as the <code>tensor_category</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerTypes</td><td>must be usable with <code>Container</code> in <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Index 0 is the <code>SymmetricOp</code> on the original grid, 1 on the half grid, 2 on the quarter grid, ... </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) contains initial guess on input and the solution on output </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side (will be multiplied by <code>weights</code>) </td></tr>
    <tr><td class="paramname">ev</td><td>The estimate of the largest Eivenvalue for each stage </td></tr>
    <tr><td class="paramname">nu_pre</td><td>number of pre-smoothing steps (make it &gt;10) </td></tr>
    <tr><td class="paramname">nu_post</td><td>number of post-smoothing steps (make it &gt;10) </td></tr>
    <tr><td class="paramname">gamma</td><td>The shape of the multigrid ( 1 is usually ok) </td></tr>
    <tr><td class="paramname">eps</td><td>the accuracy: iteration stops if \( ||b - Ax|| &lt; \epsilon( ||b|| + 1) \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is rather unreliable, it only converges if the parameters are chosen correctly ( there need to be enough smooting steps for instance, and a large jump factor in the <a class="el" href="classdg_1_1_elliptic.html" title="A 2d negative elliptic differential operator .">Elliptic</a> class also seems to help) and otherwise just iterates to infinity. This behaviour is probably related to the use of the Chebyshev solver as a smoother </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ac08058a7c4d83d0414dbc1a682ac38cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08058a7c4d83d0414dbc1a682ac38cb">&#9670;&nbsp;</a></span>grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Geometry&amp; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::grid </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return the grid at given stage </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>must fulfill <code>0</code> &lt;= stage &lt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a7659e4d18315604a75b8f92f4266aba1">stages()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab94f4c33e61798f03fc0241e76c54efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94f4c33e61798f03fc0241e76c54efa">&#9670;&nbsp;</a></span>max_iter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::max_iter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After a call to a solution method returns the maximum number of iterations allowed at stage 0 (if the solution method returns this number, failure is indicated) </p>

</div>
</div>
<a id="adec75fbb948aa597f8d7c227a395028f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec75fbb948aa597f8d7c227a395028f">&#9670;&nbsp;</a></span>num_stages()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::num_stages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of stages (same as <code>stages</code>) </dd></dl>

</div>
</div>
<a id="aeeeb1224eebf10036ab940ec0edf396e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeeb1224eebf10036ab940ec0edf396e">&#9670;&nbsp;</a></span>pcg_solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class SymmetricOp , class ContainerType0 , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::pcg_solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SymmetricOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nu_pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nu_post</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_multigrid_c_g2d.html#a31cc3f8e39468ef4b723d00e11b48601">value_type</a>&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>EXPERIMENTAL A conjugate gradient with a full multigrid cycle as preconditioner (use at own risk) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymmetricOp</td><td>A class for which the <code>blas2::symv(Matrix&amp;, Vector1&amp;, Vector2&amp;)</code> function is callable with the <code>Container</code> type as argument. Also, The functions <code>inv_weights</code>() and <code>precond</code>() need to be callable and return inverse weights and the preconditioner for the conjugate gradient method. <code>SymmetricOp</code> is assumed to be linear, symmetric and positive definite! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>you can make your own <code>SymmetricOp</code> by providing the member function <code>void</code> <code>symv(const Container&amp;, Container&amp;)</code>; and specializing <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> with the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> as the <code>tensor_category</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerTypes</td><td>must be usable with <code>Container</code> in <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Index 0 is the <code>SymmetricOp</code> on the original grid, 1 on the half grid, 2 on the quarter grid, ... </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) contains initial guess on input and the solution on output </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side (will be multiplied by <code>weights</code>) </td></tr>
    <tr><td class="paramname">ev</td><td>The estimate of the largest Eivenvalue for each stage </td></tr>
    <tr><td class="paramname">nu_pre</td><td>number of pre-smoothing steps (make it &gt;10) </td></tr>
    <tr><td class="paramname">nu_post</td><td>number of post-smoothing steps (make it &gt;10) </td></tr>
    <tr><td class="paramname">gamma</td><td>The shape of the multigrid ( 1 is usually ok) </td></tr>
    <tr><td class="paramname">eps</td><td>the accuracy: iteration stops if \( ||b - Ax|| &lt; \epsilon( ||b|| + 1) \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is rather unreliable, it only converges if the parameters are chosen correctly ( there need to be enough smooting steps for instance, and a large jump factor in the <a class="el" href="classdg_1_1_elliptic.html" title="A 2d negative elliptic differential operator .">Elliptic</a> class also seems to help) and otherwise just iterates to infinity </dd></dl>

</div>
</div>
<a id="a0944d4eb8fc62b500ec8368ae6f5b9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0944d4eb8fc62b500ec8368ae6f5b9aa">&#9670;&nbsp;</a></span>project() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class ContainerType0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ContainerType0&gt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::project </td>
          <td>(</td>
          <td class="paramtype">const ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project vector to all involved grids (allocate memory version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input vector projected to all grids ( index 0 contains a copy of src, 1 is the projetion to the first coarse grid, 2 is the next coarser grid, ...) </dd></dl>

</div>
</div>
<a id="a2f373eb2c53b09484688dfb06e9b7b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f373eb2c53b09484688dfb06e9b7b33">&#9670;&nbsp;</a></span>project() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<div class="memtemplate">
template&lt;class ContainerType0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::project </td>
          <td>(</td>
          <td class="paramtype">const ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; ContainerType0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project vector to all involved grids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the input vector (may alias first element of out) </td></tr>
    <tr><td class="paramname">out</td><td>the input vector projected to all grids ( index 0 contains a copy of src, 1 is the projetion to the first coarse grid, 2 is the next coarser grid, ...) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>out</code> is not resized </dd></dl>

</div>
</div>
<a id="a7659e4d18315604a75b8f92f4266aba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7659e4d18315604a75b8f92f4266aba1">&#9670;&nbsp;</a></span>stages()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, Matrix, Container &gt;::stages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of stages (same as <code>num_stages</code>) </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="multigrid_8h_source.html">multigrid.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassdg_1_1_timer_html_ab3ff0dbe977c6151118227cfbd0aefb2"><div class="ttname"><a href="classdg_1_1_timer.html#ab3ff0dbe977c6151118227cfbd0aefb2">dg::Timer::tic</a></div><div class="ttdeci">void tic(MPI_Comm comm=MPI_COMM_WORLD)</div><div class="ttdef"><b>Definition:</b> timer.h:111</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">dg::coo2d::x</a></div><div class="ttdeci">@ x</div><div class="ttdoc">x direction</div></div>
<div class="ttc" id="astructdg_1_1_real_cartesian_grid2d_html"><div class="ttname"><a href="structdg_1_1_real_cartesian_grid2d.html">dg::RealCartesianGrid2d</a></div><div class="ttdoc">two-dimensional Grid with Cartesian metric</div><div class="ttdef"><b>Definition:</b> base_geometry.h:199</div></div>
<div class="ttc" id="agroup__evaluation_html_ga0d2da37399e38acb2b243f568d5e7443"><div class="ttname"><a href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a></div><div class="ttdeci">thrust::host_vector&lt; real_type &gt; evaluate(UnaryOp f, const RealGrid1d&lt; real_type &gt; &amp;g)</div><div class="ttdoc">Evaluate a 1d function on grid coordinates.</div><div class="ttdef"><b>Definition:</b> evaluation.h:67</div></div>
<div class="ttc" id="aclassdg_1_1_timer_html_a27a84dc8acb525e9617cd34d64aad4ed"><div class="ttname"><a href="classdg_1_1_timer.html#a27a84dc8acb525e9617cd34d64aad4ed">dg::Timer::diff</a></div><div class="ttdeci">double diff() const</div><div class="ttdef"><b>Definition:</b> timer.h:121</div></div>
<div class="ttc" id="agroup__creation_html_gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066"><div class="ttname"><a href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066">dg::not_normed</a></div><div class="ttdeci">@ not_normed</div><div class="ttdoc">indicates that normalisation weights (either T or V) are missing from output</div><div class="ttdef"><b>Definition:</b> enums.h:99</div></div>
<div class="ttc" id="aclassdg_1_1_timer_html_afbe78fc3702a5c3d4263c2941745b8a7"><div class="ttname"><a href="classdg_1_1_timer.html#afbe78fc3702a5c3d4263c2941745b8a7">dg::Timer::toc</a></div><div class="ttdeci">void toc(MPI_Comm comm=MPI_COMM_WORLD)</div><div class="ttdef"><b>Definition:</b> timer.h:116</div></div>
<div class="ttc" id="aclassdg_1_1_timer_html"><div class="ttname"><a href="classdg_1_1_timer.html">dg::Timer</a></div><div class="ttdef"><b>Definition:</b> timer.h:107</div></div>
<div class="ttc" id="agroup__creation_html_ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df"><div class="ttname"><a href="group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></div><div class="ttdeci">@ centered</div><div class="ttdoc">centered derivative (cell to the left and right and current cell)</div><div class="ttdef"><b>Definition:</b> enums.h:106</div></div>
<div class="ttc" id="astructdg_1_1_multigrid_c_g2d_html"><div class="ttname"><a href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a></div><div class="ttdoc">Solves the Equation.</div><div class="ttdef"><b>Definition:</b> multigrid.h:44</div></div>
<div class="ttc" id="astructdg_1_1_multigrid_c_g2d_html_ac08058a7c4d83d0414dbc1a682ac38cb"><div class="ttname"><a href="structdg_1_1_multigrid_c_g2d.html#ac08058a7c4d83d0414dbc1a682ac38cb">dg::MultigridCG2d::grid</a></div><div class="ttdeci">const Geometry &amp; grid(unsigned stage) const</div><div class="ttdef"><b>Definition:</b> multigrid.h:153</div></div>
<div class="ttc" id="agroup__typedefs_html_ga5bbe4ba51ef8ff8d506979d0beda25b8"><div class="ttname"><a href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a></div><div class="ttdeci">thrust::device_vector&lt; double &gt; DVec</div><div class="ttdoc">Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...</div><div class="ttdef"><b>Definition:</b> typedefs.h:23</div></div>
<div class="ttc" id="astructdg_1_1_multigrid_c_g2d_html_a7659e4d18315604a75b8f92f4266aba1"><div class="ttname"><a href="structdg_1_1_multigrid_c_g2d.html#a7659e4d18315604a75b8f92f4266aba1">dg::MultigridCG2d::stages</a></div><div class="ttdeci">unsigned stages() const</div><div class="ttdef"><b>Definition:</b> multigrid.h:147</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_multigrid_c_g2d.html">MultigridCG2d</a></li>
    <li class="footer">Generated on Tue Feb 16 2021 01:15:31 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
