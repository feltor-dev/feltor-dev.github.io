<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Discontinuous Galerkin Library: Interpolation and projection</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Container free algorithms and discontinuous Galerkin numerical methods in &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__interpolation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interpolation and projection<div class="ingroups"><a class="el" href="group__geo.html">Level 3: Topology and Geometry</a> &raquo; <a class="el" href="group__grid.html">Topological grids and operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>\( I \) and \( P = I^\dagger\)  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Interpolation and projection:</div>
<div class="dyncontent">
<div class="center"><img src="group__interpolation.png" border="0" usemap="#group____interpolation" alt=""/></div>
<map name="group____interpolation" id="group____interpolation">
<area shape="rect" title="and" alt="" coords="212,13,415,38"/>
<area shape="rect" href="group__grid.html" title=" " alt="" coords="5,5,164,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedg_1_1create"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1create.html">dg::create</a></td></tr>
<tr class="memdesc:namespacedg_1_1create"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functions used for matrix creation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga44df0ada6e430df227613080e6f6216a"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga44df0ada6e430df227613080e6f6216a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga44df0ada6e430df227613080e6f6216a">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx)</td></tr>
<tr class="memdesc:ga44df0ada6e430df227613080e6f6216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#ga44df0ada6e430df227613080e6f6216a">More...</a><br /></td></tr>
<tr class="separator:ga44df0ada6e430df227613080e6f6216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9e04b9cd34ab247b1ce8bee73d60f3"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaca9e04b9cd34ab247b1ce8bee73d60f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx, enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a> no=<a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a>)</td></tr>
<tr class="memdesc:gaca9e04b9cd34ab247b1ce8bee73d60f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton or interpolationT matrix for integer dividers.  <a href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3">More...</a><br /></td></tr>
<tr class="separator:gaca9e04b9cd34ab247b1ce8bee73d60f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf63c8c8bf30b8e1411c5938ba0fd772"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gadf63c8c8bf30b8e1411c5938ba0fd772"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gadf63c8c8bf30b8e1411c5938ba0fd772">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx, unsigned multiplyNy)</td></tr>
<tr class="memdesc:gadf63c8c8bf30b8e1411c5938ba0fd772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#gadf63c8c8bf30b8e1411c5938ba0fd772">More...</a><br /></td></tr>
<tr class="separator:gadf63c8c8bf30b8e1411c5938ba0fd772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac99948c709a3716e95bbcfa7520a9c97"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gac99948c709a3716e95bbcfa7520a9c97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gac99948c709a3716e95bbcfa7520a9c97">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx, unsigned divideNy, enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a> no=<a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a>)</td></tr>
<tr class="memdesc:gac99948c709a3716e95bbcfa7520a9c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton or interpolationT matrix for integer dividers.  <a href="group__interpolation.html#gac99948c709a3716e95bbcfa7520a9c97">More...</a><br /></td></tr>
<tr class="separator:gac99948c709a3716e95bbcfa7520a9c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc1ce716461e7c4da145383d5959857"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga3cc1ce716461e7c4da145383d5959857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga3cc1ce716461e7c4da145383d5959857">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx, unsigned multiplyNy)</td></tr>
<tr class="memdesc:ga3cc1ce716461e7c4da145383d5959857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#ga3cc1ce716461e7c4da145383d5959857">More...</a><br /></td></tr>
<tr class="separator:ga3cc1ce716461e7c4da145383d5959857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf5186e2b87a8ad6eca3812645eb537"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gadcf5186e2b87a8ad6eca3812645eb537"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gadcf5186e2b87a8ad6eca3812645eb537">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx, unsigned divideNy, enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a> no=<a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a>)</td></tr>
<tr class="memdesc:gadcf5186e2b87a8ad6eca3812645eb537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton or interpolationT matrix for integer dividers.  <a href="group__interpolation.html#gadcf5186e2b87a8ad6eca3812645eb537">More...</a><br /></td></tr>
<tr class="separator:gadcf5186e2b87a8ad6eca3812645eb537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbab33cc2fa5dcf8b738172da4cbd23d"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gacbab33cc2fa5dcf8b738172da4cbd23d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gacbab33cc2fa5dcf8b738172da4cbd23d">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx, unsigned multiplyNy)</td></tr>
<tr class="memdesc:gacbab33cc2fa5dcf8b738172da4cbd23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#gacbab33cc2fa5dcf8b738172da4cbd23d">More...</a><br /></td></tr>
<tr class="separator:gacbab33cc2fa5dcf8b738172da4cbd23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b86b70c6282f55cab3b8237245fa83"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad4b86b70c6282f55cab3b8237245fa83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad4b86b70c6282f55cab3b8237245fa83">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx, unsigned divideNy, enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a> no=<a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a>)</td></tr>
<tr class="memdesc:gad4b86b70c6282f55cab3b8237245fa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton or interpolationT matrix for integer dividers.  <a href="group__interpolation.html#gad4b86b70c6282f55cab3b8237245fa83">More...</a><br /></td></tr>
<tr class="separator:gad4b86b70c6282f55cab3b8237245fa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182d05c46ba2d0e035b46165c9a3d8af"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga182d05c46ba2d0e035b46165c9a3d8af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga182d05c46ba2d0e035b46165c9a3d8af">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx, unsigned multiplyNy)</td></tr>
<tr class="memdesc:ga182d05c46ba2d0e035b46165c9a3d8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#ga182d05c46ba2d0e035b46165c9a3d8af">More...</a><br /></td></tr>
<tr class="separator:ga182d05c46ba2d0e035b46165c9a3d8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad9adae9c8dbafe09301bda399381f3d"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaad9adae9c8dbafe09301bda399381f3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaad9adae9c8dbafe09301bda399381f3d">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx, unsigned divideNy, enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a> no=<a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a>)</td></tr>
<tr class="memdesc:gaad9adae9c8dbafe09301bda399381f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton or interpolationT matrix for integer dividers.  <a href="group__interpolation.html#gaad9adae9c8dbafe09301bda399381f3d">More...</a><br /></td></tr>
<tr class="separator:gaad9adae9c8dbafe09301bda399381f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc11151503ff95782b2bfcb7aa152e0f"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gafc11151503ff95782b2bfcb7aa152e0f"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gafc11151503ff95782b2bfcb7aa152e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">More...</a><br /></td></tr>
<tr class="separator:gafc11151503ff95782b2bfcb7aa152e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac238077768fe5fc49ab3cd4f94569ef4"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gac238077768fe5fc49ab3cd4f94569ef4"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gac238077768fe5fc49ab3cd4f94569ef4">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gac238077768fe5fc49ab3cd4f94569ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gac238077768fe5fc49ab3cd4f94569ef4">More...</a><br /></td></tr>
<tr class="separator:gac238077768fe5fc49ab3cd4f94569ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b02340419df7f0617886744cbf00bf"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga49b02340419df7f0617886744cbf00bf"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga49b02340419df7f0617886744cbf00bf">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const thrust::host_vector&lt; real_type &gt; &amp;z, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>)</td></tr>
<tr class="memdesc:ga49b02340419df7f0617886744cbf00bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga49b02340419df7f0617886744cbf00bf">More...</a><br /></td></tr>
<tr class="separator:ga49b02340419df7f0617886744cbf00bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43cb2b93b0c2c40e6694616bca9fc49b"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga43cb2b93b0c2c40e6694616bca9fc49b"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga43cb2b93b0c2c40e6694616bca9fc49b">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga43cb2b93b0c2c40e6694616bca9fc49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga43cb2b93b0c2c40e6694616bca9fc49b">More...</a><br /></td></tr>
<tr class="separator:ga43cb2b93b0c2c40e6694616bca9fc49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7615acf5b63591b625ef2a6a4d4bf575"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga7615acf5b63591b625ef2a6a4d4bf575"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga7615acf5b63591b625ef2a6a4d4bf575">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga7615acf5b63591b625ef2a6a4d4bf575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga7615acf5b63591b625ef2a6a4d4bf575">More...</a><br /></td></tr>
<tr class="separator:ga7615acf5b63591b625ef2a6a4d4bf575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga910bab705307590f6f2bff0220a2c103"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga910bab705307590f6f2bff0220a2c103"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga910bab705307590f6f2bff0220a2c103">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga910bab705307590f6f2bff0220a2c103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga910bab705307590f6f2bff0220a2c103">More...</a><br /></td></tr>
<tr class="separator:ga910bab705307590f6f2bff0220a2c103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c60049f9ef9047e326d1c69459a299a"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga8c60049f9ef9047e326d1c69459a299a"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga8c60049f9ef9047e326d1c69459a299a">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga8c60049f9ef9047e326d1c69459a299a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga8c60049f9ef9047e326d1c69459a299a">More...</a><br /></td></tr>
<tr class="separator:ga8c60049f9ef9047e326d1c69459a299a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1467be84fa682c8b300cd39db0492d9"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad1467be84fa682c8b300cd39db0492d9"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad1467be84fa682c8b300cd39db0492d9">dg::interpolate</a> (<a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a> sp, const thrust::host_vector&lt; real_type &gt; &amp;v, real_type x, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gad1467be84fa682c8b300cd39db0492d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector on a single point on a 1d Grid.  <a href="group__interpolation.html#gad1467be84fa682c8b300cd39db0492d9">More...</a><br /></td></tr>
<tr class="separator:gad1467be84fa682c8b300cd39db0492d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9fc6abad143444993021781bbed9b48"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaa9fc6abad143444993021781bbed9b48"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaa9fc6abad143444993021781bbed9b48">dg::interpolate</a> (<a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a> sp, const thrust::host_vector&lt; real_type &gt; &amp;v, real_type x, real_type y, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gaa9fc6abad143444993021781bbed9b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector on a single point on a 2d Grid.  <a href="group__interpolation.html#gaa9fc6abad143444993021781bbed9b48">More...</a><br /></td></tr>
<tr class="separator:gaa9fc6abad143444993021781bbed9b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b5393db21fa03f0c7738eb7dc2526b7"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga2b5393db21fa03f0c7738eb7dc2526b7"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga2b5393db21fa03f0c7738eb7dc2526b7">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g)</td></tr>
<tr class="memdesc:ga2b5393db21fa03f0c7738eb7dc2526b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga2b5393db21fa03f0c7738eb7dc2526b7">More...</a><br /></td></tr>
<tr class="separator:ga2b5393db21fa03f0c7738eb7dc2526b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269972b42917096fd1206a6be83d8665"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga269972b42917096fd1206a6be83d8665"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga269972b42917096fd1206a6be83d8665">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga269972b42917096fd1206a6be83d8665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga269972b42917096fd1206a6be83d8665">More...</a><br /></td></tr>
<tr class="separator:ga269972b42917096fd1206a6be83d8665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58179b948ca7bb7b2bab744c5ac3c599"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga58179b948ca7bb7b2bab744c5ac3c599"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga58179b948ca7bb7b2bab744c5ac3c599">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const thrust::host_vector&lt; real_type &gt; &amp;z, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga58179b948ca7bb7b2bab744c5ac3c599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga58179b948ca7bb7b2bab744c5ac3c599">More...</a><br /></td></tr>
<tr class="separator:ga58179b948ca7bb7b2bab744c5ac3c599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555e06c4b7779feba87d4329c3d03624"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga555e06c4b7779feba87d4329c3d03624"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga555e06c4b7779feba87d4329c3d03624">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga555e06c4b7779feba87d4329c3d03624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga555e06c4b7779feba87d4329c3d03624">More...</a><br /></td></tr>
<tr class="separator:ga555e06c4b7779feba87d4329c3d03624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827bd31c77f2d5641080b68edbdcfff1"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga827bd31c77f2d5641080b68edbdcfff1"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga827bd31c77f2d5641080b68edbdcfff1">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga827bd31c77f2d5641080b68edbdcfff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga827bd31c77f2d5641080b68edbdcfff1">More...</a><br /></td></tr>
<tr class="separator:ga827bd31c77f2d5641080b68edbdcfff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbcffe4d3860746df9e86f8e829ad457"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gafbcffe4d3860746df9e86f8e829ad457"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gafbcffe4d3860746df9e86f8e829ad457">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gafbcffe4d3860746df9e86f8e829ad457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gafbcffe4d3860746df9e86f8e829ad457">More...</a><br /></td></tr>
<tr class="separator:gafbcffe4d3860746df9e86f8e829ad457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga3f3b02e7ec191c8fcf1fc258599617f7">dg::interpolate</a> (<a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a> sp, const thrust::host_vector&lt; real_type &gt; &amp;v, real_type x, real_type y, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector on a single point on a 2d Grid.  <a href="group__interpolation.html#ga3f3b02e7ec191c8fcf1fc258599617f7">More...</a><br /></td></tr>
<tr class="separator:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga583c8076da6112ead68ad160501b9e56"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga583c8076da6112ead68ad160501b9e56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga583c8076da6112ead68ad160501b9e56">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga583c8076da6112ead68ad160501b9e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga583c8076da6112ead68ad160501b9e56">More...</a><br /></td></tr>
<tr class="separator:ga583c8076da6112ead68ad160501b9e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458385383d455bdeaf5903bfdc2f6298"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga458385383d455bdeaf5903bfdc2f6298"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga458385383d455bdeaf5903bfdc2f6298">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga458385383d455bdeaf5903bfdc2f6298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga458385383d455bdeaf5903bfdc2f6298">More...</a><br /></td></tr>
<tr class="separator:ga458385383d455bdeaf5903bfdc2f6298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78afd6d522434f0db61699794847ac33"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga78afd6d522434f0db61699794847ac33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga78afd6d522434f0db61699794847ac33">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga78afd6d522434f0db61699794847ac33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga78afd6d522434f0db61699794847ac33">More...</a><br /></td></tr>
<tr class="separator:ga78afd6d522434f0db61699794847ac33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e444a269192f31b7fe1756004d40137"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga0e444a269192f31b7fe1756004d40137"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga0e444a269192f31b7fe1756004d40137">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga0e444a269192f31b7fe1756004d40137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga0e444a269192f31b7fe1756004d40137">More...</a><br /></td></tr>
<tr class="separator:ga0e444a269192f31b7fe1756004d40137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31afc0c3b66dddf97332124ad79693a6"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga31afc0c3b66dddf97332124ad79693a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga31afc0c3b66dddf97332124ad79693a6">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga31afc0c3b66dddf97332124ad79693a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga31afc0c3b66dddf97332124ad79693a6">More...</a><br /></td></tr>
<tr class="separator:ga31afc0c3b66dddf97332124ad79693a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad12da07b80519780720ad3b3d33907d"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaad12da07b80519780720ad3b3d33907d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaad12da07b80519780720ad3b3d33907d">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gaad12da07b80519780720ad3b3d33907d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gaad12da07b80519780720ad3b3d33907d">More...</a><br /></td></tr>
<tr class="separator:gaad12da07b80519780720ad3b3d33907d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6210372beaaccb284f4b85c311e28b1f"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga6210372beaaccb284f4b85c311e28b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga6210372beaaccb284f4b85c311e28b1f">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga6210372beaaccb284f4b85c311e28b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga6210372beaaccb284f4b85c311e28b1f">More...</a><br /></td></tr>
<tr class="separator:ga6210372beaaccb284f4b85c311e28b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc02b4f371db3e204ec577c0f0133ad0"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gabc02b4f371db3e204ec577c0f0133ad0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gabc02b4f371db3e204ec577c0f0133ad0">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gabc02b4f371db3e204ec577c0f0133ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an MPI row distributed interpolation 2d matrix.  <a href="group__interpolation.html#gabc02b4f371db3e204ec577c0f0133ad0">More...</a><br /></td></tr>
<tr class="separator:gabc02b4f371db3e204ec577c0f0133ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf19348303106a90a0c591bf13ff9260"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gacf19348303106a90a0c591bf13ff9260"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gacf19348303106a90a0c591bf13ff9260">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const thrust::host_vector&lt; real_type &gt; &amp;z, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>)</td></tr>
<tr class="memdesc:gacf19348303106a90a0c591bf13ff9260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an MPI row distributed interpolation 3d matrix.  <a href="group__interpolation.html#gacf19348303106a90a0c591bf13ff9260">More...</a><br /></td></tr>
<tr class="separator:gacf19348303106a90a0c591bf13ff9260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20f69fb78f6536cff2fd882addb9ba78"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga20f69fb78f6536cff2fd882addb9ba78"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga20f69fb78f6536cff2fd882addb9ba78">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga20f69fb78f6536cff2fd882addb9ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga20f69fb78f6536cff2fd882addb9ba78">More...</a><br /></td></tr>
<tr class="separator:ga20f69fb78f6536cff2fd882addb9ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59fb7f0363347d566739cdd883ade47c"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga59fb7f0363347d566739cdd883ade47c"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga59fb7f0363347d566739cdd883ade47c">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga59fb7f0363347d566739cdd883ade47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga59fb7f0363347d566739cdd883ade47c">More...</a><br /></td></tr>
<tr class="separator:ga59fb7f0363347d566739cdd883ade47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd76425accf9b0f44fc99ee876dd66e5"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gabd76425accf9b0f44fc99ee876dd66e5"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gabd76425accf9b0f44fc99ee876dd66e5">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gabd76425accf9b0f44fc99ee876dd66e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gabd76425accf9b0f44fc99ee876dd66e5">More...</a><br /></td></tr>
<tr class="separator:gabd76425accf9b0f44fc99ee876dd66e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9cc0ad9d153866a5a98223a53e5d44"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gacd9cc0ad9d153866a5a98223a53e5d44"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gacd9cc0ad9d153866a5a98223a53e5d44">dg::create::projection</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gacd9cc0ad9d153866a5a98223a53e5d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gacd9cc0ad9d153866a5a98223a53e5d44">More...</a><br /></td></tr>
<tr class="separator:gacd9cc0ad9d153866a5a98223a53e5d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6943a7a544a577dae24c4ab10bf8117"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gac6943a7a544a577dae24c4ab10bf8117"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gac6943a7a544a577dae24c4ab10bf8117">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gac6943a7a544a577dae24c4ab10bf8117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gac6943a7a544a577dae24c4ab10bf8117">More...</a><br /></td></tr>
<tr class="separator:gac6943a7a544a577dae24c4ab10bf8117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga2ca23ae164ef6ff18fbdaf7ef9c02ca8">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga2ca23ae164ef6ff18fbdaf7ef9c02ca8">More...</a><br /></td></tr>
<tr class="separator:ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36df1674e2af618cccfc9198a9f40ec0"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga36df1674e2af618cccfc9198a9f40ec0"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0">dg::create::transformation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga36df1674e2af618cccfc9198a9f40ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0">More...</a><br /></td></tr>
<tr class="separator:ga36df1674e2af618cccfc9198a9f40ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083d44d4f7fe426731d083302c4a40e5"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga083d44d4f7fe426731d083302c4a40e5"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga083d44d4f7fe426731d083302c4a40e5">dg::create::transformation</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga083d44d4f7fe426731d083302c4a40e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#ga083d44d4f7fe426731d083302c4a40e5">More...</a><br /></td></tr>
<tr class="separator:ga083d44d4f7fe426731d083302c4a40e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad069ca6eb4b8294f47b8981db73ec303"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad069ca6eb4b8294f47b8981db73ec303"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad069ca6eb4b8294f47b8981db73ec303">dg::create::transformation</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gad069ca6eb4b8294f47b8981db73ec303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#gad069ca6eb4b8294f47b8981db73ec303">More...</a><br /></td></tr>
<tr class="separator:gad069ca6eb4b8294f47b8981db73ec303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85bb8ca428ec2ff85376c5a211f9c66d"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga85bb8ca428ec2ff85376c5a211f9c66d"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga85bb8ca428ec2ff85376c5a211f9c66d">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga85bb8ca428ec2ff85376c5a211f9c66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga85bb8ca428ec2ff85376c5a211f9c66d">More...</a><br /></td></tr>
<tr class="separator:ga85bb8ca428ec2ff85376c5a211f9c66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5568088cd5434971e71c6b748c067d1"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad5568088cd5434971e71c6b748c067d1"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad5568088cd5434971e71c6b748c067d1">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gad5568088cd5434971e71c6b748c067d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gad5568088cd5434971e71c6b748c067d1">More...</a><br /></td></tr>
<tr class="separator:gad5568088cd5434971e71c6b748c067d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c6214991f472f57f9dc782006f2130"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga12c6214991f472f57f9dc782006f2130"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga12c6214991f472f57f9dc782006f2130">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga12c6214991f472f57f9dc782006f2130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga12c6214991f472f57f9dc782006f2130">More...</a><br /></td></tr>
<tr class="separator:ga12c6214991f472f57f9dc782006f2130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e8c5ffd2fab9cd4e1b9b513c4a37492"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga6e8c5ffd2fab9cd4e1b9b513c4a37492"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga6e8c5ffd2fab9cd4e1b9b513c4a37492">dg::create::projection</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga6e8c5ffd2fab9cd4e1b9b513c4a37492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga6e8c5ffd2fab9cd4e1b9b513c4a37492">More...</a><br /></td></tr>
<tr class="separator:ga6e8c5ffd2fab9cd4e1b9b513c4a37492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c84ab3bbfb575eb3dd871ae22d32a7"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad1c84ab3bbfb575eb3dd871ae22d32a7"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad1c84ab3bbfb575eb3dd871ae22d32a7">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gad1c84ab3bbfb575eb3dd871ae22d32a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gad1c84ab3bbfb575eb3dd871ae22d32a7">More...</a><br /></td></tr>
<tr class="separator:gad1c84ab3bbfb575eb3dd871ae22d32a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7688622f75b7ad9a4f8d8ce914338fbf"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga7688622f75b7ad9a4f8d8ce914338fbf"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga7688622f75b7ad9a4f8d8ce914338fbf">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga7688622f75b7ad9a4f8d8ce914338fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga7688622f75b7ad9a4f8d8ce914338fbf">More...</a><br /></td></tr>
<tr class="separator:ga7688622f75b7ad9a4f8d8ce914338fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>\( I \) and \( P = I^\dagger\) </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacbab33cc2fa5dcf8b738172da4cbd23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbab33cc2fa5dcf8b738172da4cbd23d">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p>When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
    <tr><td class="paramname">multiplyNy</td><td>integer multiplier, the new grid has <code>Ny*multiplyNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga182d05c46ba2d0e035b46165c9a3d8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga182d05c46ba2d0e035b46165c9a3d8af">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p>When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
    <tr><td class="paramname">multiplyNy</td><td>integer multiplier, the new grid has <code>Ny*multiplyNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf63c8c8bf30b8e1411c5938ba0fd772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf63c8c8bf30b8e1411c5938ba0fd772">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p>When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
    <tr><td class="paramname">multiplyNy</td><td>integer multiplier, the new grid has <code>Ny*multiplyNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3cc1ce716461e7c4da145383d5959857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cc1ce716461e7c4da145383d5959857">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p>When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
    <tr><td class="paramname">multiplyNy</td><td>integer multiplier, the new grid has <code>Ny*multiplyNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44df0ada6e430df227613080e6f6216a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44df0ada6e430df227613080e6f6216a">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p>When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4b86b70c6282f55cab3b8237245fa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4b86b70c6282f55cab3b8237245fa83">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a>&#160;</td>
          <td class="paramname"><em>no</em> = <code><a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton or interpolationT matrix for integer dividers. </p>
<p>When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad12da07b80519780720ad3b3d33907d" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#ga0e444a269192f31b7fe1756004d40137" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
    <tr><td class="paramname">no</td><td>if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123" title="indicates that output is properly normalized">dg::normed</a> than a projection matrix is returned, if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066" title="indicates that normalisation weights (either T or V) are missing from output">dg::not_normed</a> the interpolationT is computed </td></tr>
    <tr><td class="paramname">divideNy</td><td>integer multiplier, the new grid has <code>Ny/divideNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad9adae9c8dbafe09301bda399381f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad9adae9c8dbafe09301bda399381f3d">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a>&#160;</td>
          <td class="paramname"><em>no</em> = <code><a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton or interpolationT matrix for integer dividers. </p>
<p>When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad12da07b80519780720ad3b3d33907d" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#ga0e444a269192f31b7fe1756004d40137" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
    <tr><td class="paramname">no</td><td>if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123" title="indicates that output is properly normalized">dg::normed</a> than a projection matrix is returned, if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066" title="indicates that normalisation weights (either T or V) are missing from output">dg::not_normed</a> the interpolationT is computed </td></tr>
    <tr><td class="paramname">divideNy</td><td>integer multiplier, the new grid has <code>Ny/divideNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac99948c709a3716e95bbcfa7520a9c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac99948c709a3716e95bbcfa7520a9c97">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a>&#160;</td>
          <td class="paramname"><em>no</em> = <code><a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton or interpolationT matrix for integer dividers. </p>
<p>When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad12da07b80519780720ad3b3d33907d" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#ga0e444a269192f31b7fe1756004d40137" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
    <tr><td class="paramname">no</td><td>if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123" title="indicates that output is properly normalized">dg::normed</a> than a projection matrix is returned, if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066" title="indicates that normalisation weights (either T or V) are missing from output">dg::not_normed</a> the interpolationT is computed </td></tr>
    <tr><td class="paramname">divideNy</td><td>integer multiplier, the new grid has <code>Ny/divideNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadcf5186e2b87a8ad6eca3812645eb537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcf5186e2b87a8ad6eca3812645eb537">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a>&#160;</td>
          <td class="paramname"><em>no</em> = <code><a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton or interpolationT matrix for integer dividers. </p>
<p>When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad12da07b80519780720ad3b3d33907d" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#ga0e444a269192f31b7fe1756004d40137" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
    <tr><td class="paramname">no</td><td>if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123" title="indicates that output is properly normalized">dg::normed</a> than a projection matrix is returned, if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066" title="indicates that normalisation weights (either T or V) are missing from output">dg::not_normed</a> the interpolationT is computed </td></tr>
    <tr><td class="paramname">divideNy</td><td>integer multiplier, the new grid has <code>Ny/divideNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca9e04b9cd34ab247b1ce8bee73d60f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca9e04b9cd34ab247b1ce8bee73d60f3">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt;real_type&gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt;real_type&gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a>&#160;</td>
          <td class="paramname"><em>no</em> = <code><a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123">normed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton or interpolationT matrix for integer dividers. </p>
<p>When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad12da07b80519780720ad3b3d33907d" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#ga0e444a269192f31b7fe1756004d40137" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
    <tr><td class="paramname">no</td><td>if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a3f222a3e51d054ebe21228c62569e123" title="indicates that output is properly normalized">dg::normed</a> than a projection matrix is returned, if <a class="el" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066" title="indicates that normalisation weights (either T or V) are missing from output">dg::not_normed</a> the interpolationT is computed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1467be84fa682c8b300cd39db0492d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1467be84fa682c8b300cd39db0492d9">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a>&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector on a single point on a 1d Grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>Indicate whether the elements of the vector v are in xspace (nodal values) or lspace (modal values) (choose <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> if you don't know what is going on here, It is faster to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> so consider transforming v using <a class="el" href="group__misc.html#ga14dec9882994e915b8e43fce95b2bee6" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> if you do it very many times) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate </td></tr>
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>

</div>
</div>
<a id="gaa9fc6abad143444993021781bbed9b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9fc6abad143444993021781bbed9b48">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a>&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector on a single point on a 2d Grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>Indicate whether the elements of the vector v are in xspace (nodal values) or lspace (modal values) (choose <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> if you don't know what is going on here, It is faster to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> so consider transforming v using <a class="el" href="group__misc.html#ga14dec9882994e915b8e43fce95b2bee6" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> if you do it very many times) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a>, or <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> s.a. <a class="el" href="group__misc.html#ga14dec9882994e915b8e43fce95b2bee6" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> </td></tr>
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>

</div>
</div>
<a id="ga3f3b02e7ec191c8fcf1fc258599617f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3b02e7ec191c8fcf1fc258599617f7">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a>&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector on a single point on a 2d Grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>Indicate whether the elements of the vector v are in xspace or lspace (choose <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> if you don't know what is going on here, It is faster to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> so consider transforming v using <a class="el" href="group__misc.html#ga14dec9882994e915b8e43fce95b2bee6" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> if you do it very many times) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a>, or <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> s.a. <a class="el" href="group__misc.html#ga14dec9882994e915b8e43fce95b2bee6" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> </td></tr>
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>g.contains(x,y)</code> must return true </dd></dl>

</div>
</div>
<a id="ga583c8076da6112ead68ad160501b9e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga583c8076da6112ead68ad160501b9e56">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt;real_type&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want to consider the <a class="el" href="group__interpolation.html#ga44df0ada6e430df227613080e6f6216a" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga78afd6d522434f0db61699794847ac33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78afd6d522434f0db61699794847ac33">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt;real_type&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want to consider the <a class="el" href="group__interpolation.html#ga44df0ada6e430df227613080e6f6216a" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga458385383d455bdeaf5903bfdc2f6298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga458385383d455bdeaf5903bfdc2f6298">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt;real_type&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want to consider the <a class="el" href="group__interpolation.html#ga44df0ada6e430df227613080e6f6216a" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga7615acf5b63591b625ef2a6a4d4bf575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7615acf5b63591b625ef2a6a4d4bf575">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want to consider the <a class="el" href="group__interpolation.html#ga44df0ada6e430df227613080e6f6216a" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga8c60049f9ef9047e326d1c69459a299a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c60049f9ef9047e326d1c69459a299a">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want to consider the <a class="el" href="group__interpolation.html#ga44df0ada6e430df227613080e6f6216a" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga910bab705307590f6f2bff0220a2c103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga910bab705307590f6f2bff0220a2c103">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want to consider the <a class="el" href="group__interpolation.html#ga44df0ada6e430df227613080e6f6216a" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga827bd31c77f2d5641080b68edbdcfff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga827bd31c77f2d5641080b68edbdcfff1">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gafbcffe4d3860746df9e86f8e829ad457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbcffe4d3860746df9e86f8e829ad457">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga43cb2b93b0c2c40e6694616bca9fc49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43cb2b93b0c2c40e6694616bca9fc49b">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want to consider the <a class="el" href="group__interpolation.html#ga44df0ada6e430df227613080e6f6216a" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga555e06c4b7779feba87d4329c3d03624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555e06c4b7779feba87d4329c3d03624">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gafc11151503ff95782b2bfcb7aa152e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc11151503ff95782b2bfcb7aa152e0f">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="ga2b5393db21fa03f0c7738eb7dc2526b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b5393db21fa03f0c7738eb7dc2526b7">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="gabc02b4f371db3e204ec577c0f0133ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc02b4f371db3e204ec577c0f0133ad0">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt;real_type&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an MPI row distributed interpolation 2d matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div>
<div class="line">    thrust::host_vector&lt;double&gt; <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x);</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//intentionally set values outside the grid domain</span></div>
<div class="line">            <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[i*g.Nx()*g.n() + j] =</div>
<div class="line">                    g.x0() + g.lx() + (j+0.5)*g.hx()/(double)(g.n());</div>
<div class="line">            <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[i*g.Nx()*g.n() + j] =</div>
<div class="line">                    g.y0() + 2*g.ly() + (i+0.5)*g.hy()/(double)(g.n());</div>
<div class="line">        }</div>
<div class="line">    <span class="comment">//use DIR because the coo.2d is zero on the right boundary</span></div>
<div class="line">    Matrix B = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( x, y, g, <a class="code" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>);</div>
<div class="line">    <span class="comment">//values outside the grid are mirrored back in</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g);</div>
<div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">    <a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
<div class="line">    <span class="comment">//inter now contains the values of vec interpolated at equidistant points</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="gac238077768fe5fc49ab3cd4f94569ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac238077768fe5fc49ab3cd4f94569ef4">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div>
<div class="line">    thrust::host_vector&lt;double&gt; <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x);</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//intentionally set values outside the grid domain</span></div>
<div class="line">            <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[i*g.Nx()*g.n() + j] =</div>
<div class="line">                    g.x0() + g.lx() + (j+0.5)*g.hx()/(double)(g.n());</div>
<div class="line">            <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[i*g.Nx()*g.n() + j] =</div>
<div class="line">                    g.y0() + 2*g.ly() + (i+0.5)*g.hy()/(double)(g.n());</div>
<div class="line">        }</div>
<div class="line">    <span class="comment">//use DIR because the coo.2d is zero on the right boundary</span></div>
<div class="line">    Matrix B = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( x, y, g, <a class="code" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>);</div>
<div class="line">    <span class="comment">//values outside the grid are mirrored back in</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g);</div>
<div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">    <a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
<div class="line">    <span class="comment">//inter now contains the values of vec interpolated at equidistant points</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="ga269972b42917096fd1206a6be83d8665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga269972b42917096fd1206a6be83d8665">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>globalbcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>NEU for common interpolation. DIR for zeros at Box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="gacf19348303106a90a0c591bf13ff9260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf19348303106a90a0c591bf13ff9260">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt;real_type&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an MPI row distributed interpolation 3d matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div>
<div class="line">    thrust::host_vector&lt;double&gt; <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x), <a class="code" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>(x);</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;g.Nz(); k++)</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] =</div>
<div class="line">                        g.x0() + (j+0.5)*g.hx()/(double)(g.n());</div>
<div class="line">                <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] =</div>
<div class="line">                        g.y0() + (i+0.5)*g.hy()/(double)(g.n());</div>
<div class="line">                <a class="code" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] =</div>
<div class="line">                        g.z0() + (k+0.5)*g.hz();</div>
<div class="line">            }</div>
<div class="line">    Matrix B = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( x, y, z, g);</div>
<div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g);</div>
<div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">    <a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points (<code>z.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">bcz</td><td>analogous to <code>bcx</code>, applies to z direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>all points (x, y, z) must lie within or on the boundaries of g </dd></dl>

</div>
</div>
<a id="ga49b02340419df7f0617886744cbf00bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49b02340419df7f0617886744cbf00bf">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div>
<div class="line">    thrust::host_vector&lt;double&gt; <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x), <a class="code" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>(x);</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;g.Nz(); k++)</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] =</div>
<div class="line">                        g.x0() + (j+0.5)*g.hx()/(double)(g.n());</div>
<div class="line">                <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] =</div>
<div class="line">                        g.y0() + (i+0.5)*g.hy()/(double)(g.n());</div>
<div class="line">                <a class="code" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] =</div>
<div class="line">                        g.z0() + (k+0.5)*g.hz();</div>
<div class="line">            }</div>
<div class="line">    Matrix B = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( x, y, z, g);</div>
<div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g);</div>
<div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">    <a class="code" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points (<code>z.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">bcz</td><td>analogous to <code>bcx</code>, applies to z direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>all points (x, y, z) must lie within or on the boundaries of g </dd></dl>

</div>
</div>
<a id="ga58179b948ca7bb7b2bab744c5ac3c599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58179b948ca7bb7b2bab744c5ac3c599">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>globalbcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates. In z-direction only a nearest neighbor interpolation is used </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>determines what to do if values lie exactly on the boundary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The values of x, y and z must lie within the boundaries of g </dd></dl>

</div>
</div>
<a id="ga0e444a269192f31b7fe1756004d40137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e444a269192f31b7fe1756004d40137">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt;real_type&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga31afc0c3b66dddf97332124ad79693a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31afc0c3b66dddf97332124ad79693a6">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt;real_type&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga59fb7f0363347d566739cdd883ade47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59fb7f0363347d566739cdd883ade47c">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gabd76425accf9b0f44fc99ee876dd66e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd76425accf9b0f44fc99ee876dd66e5">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gad5568088cd5434971e71c6b748c067d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5568088cd5434971e71c6b748c067d1">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga12c6214991f472f57f9dc782006f2130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c6214991f472f57f9dc782006f2130">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga20f69fb78f6536cff2fd882addb9ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20f69fb78f6536cff2fd882addb9ba78">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga85bb8ca428ec2ff85376c5a211f9c66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85bb8ca428ec2ff85376c5a211f9c66d">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gaad12da07b80519780720ad3b3d33907d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad12da07b80519780720ad3b3d33907d">&#9670;&nbsp;</a></span>projection() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt;real_type&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want to consider the <a class="el" href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3" title="Create projecton or interpolationT matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga6210372beaaccb284f4b85c311e28b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6210372beaaccb284f4b85c311e28b1f">&#9670;&nbsp;</a></span>projection() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt;real_type&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want to consider the <a class="el" href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3" title="Create projecton or interpolationT matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gac6943a7a544a577dae24c4ab10bf8117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6943a7a544a577dae24c4ab10bf8117">&#9670;&nbsp;</a></span>projection() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want to consider the <a class="el" href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3" title="Create projecton or interpolationT matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ca23ae164ef6ff18fbdaf7ef9c02ca8">&#9670;&nbsp;</a></span>projection() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want to consider the <a class="el" href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3" title="Create projecton or interpolationT matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gad1c84ab3bbfb575eb3dd871ae22d32a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1c84ab3bbfb575eb3dd871ae22d32a7">&#9670;&nbsp;</a></span>projection() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want to consider the <a class="el" href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3" title="Create projecton or interpolationT matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga7688622f75b7ad9a4f8d8ce914338fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7688622f75b7ad9a4f8d8ce914338fbf">&#9670;&nbsp;</a></span>projection() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want to consider the <a class="el" href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3" title="Create projecton or interpolationT matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gacd9cc0ad9d153866a5a98223a53e5d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd9cc0ad9d153866a5a98223a53e5d44">&#9670;&nbsp;</a></span>projection() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want to consider the <a class="el" href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3" title="Create projecton or interpolationT matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>
<p>!! cusp::multiply removes explicit zeros in the output</p>

</div>
</div>
<a id="ga6e8c5ffd2fab9cd4e1b9b513c4a37492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e8c5ffd2fab9cd4e1b9b513c4a37492">&#9670;&nbsp;</a></span>projection() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want to consider the <a class="el" href="group__interpolation.html#gaca9e04b9cd34ab247b1ce8bee73d60f3" title="Create projecton or interpolationT matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga083d44d4f7fe426731d083302c4a40e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga083d44d4f7fe426731d083302c4a40e5">&#9670;&nbsp;</a></span>transformation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
<a id="ga36df1674e2af618cccfc9198a9f40ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36df1674e2af618cccfc9198a9f40ec0">&#9670;&nbsp;</a></span>transformation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
<a id="gad069ca6eb4b8294f47b8981db73ec303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad069ca6eb4b8294f47b8981db73ec303">&#9670;&nbsp;</a></span>transformation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__creation_html_gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7"><div class="ttname"><a href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">dg::coo3d::z</a></div><div class="ttdeci">@ z</div><div class="ttdoc">z direction</div></div>
<div class="ttc" id="agroup__interpolation_html_gafc11151503ff95782b2bfcb7aa152e0f"><div class="ttname"><a href="group__interpolation.html#gafc11151503ff95782b2bfcb7aa152e0f">dg::create::interpolation</a></div><div class="ttdeci">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; interpolation(const thrust::host_vector&lt; real_type &gt; &amp;x, const RealGrid1d&lt; real_type &gt; &amp;g, dg::bc bcx=dg::NEU)</div><div class="ttdoc">Create interpolation matrix.</div><div class="ttdef"><b>Definition:</b> interpolation.h:105</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">dg::coo2d::x</a></div><div class="ttdeci">@ x</div><div class="ttdoc">x direction</div></div>
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6"><div class="ttname"><a href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a></div><div class="ttdeci">@ DIR</div><div class="ttdoc">homogeneous dirichlet boundaries</div><div class="ttdef"><b>Definition:</b> enums.h:17</div></div>
<div class="ttc" id="agroup__blas2_html_gac3840941bd2bb1d64c6ca3fef1f1b960"><div class="ttname"><a href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a></div><div class="ttdeci">void symv(MatrixType &amp;&amp;M, const ContainerType1 &amp;x, ContainerType2 &amp;y)</div><div class="ttdef"><b>Definition:</b> blas2.h:222</div></div>
<div class="ttc" id="agroup__evaluation_html_ga0d2da37399e38acb2b243f568d5e7443"><div class="ttname"><a href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a></div><div class="ttdeci">thrust::host_vector&lt; real_type &gt; evaluate(UnaryOp f, const RealGrid1d&lt; real_type &gt; &amp;g)</div><div class="ttdoc">Evaluate a 1d function on grid coordinates.</div><div class="ttdef"><b>Definition:</b> evaluation.h:67</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">dg::coo2d::y</a></div><div class="ttdeci">@ y</div><div class="ttdoc">y direction</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 23 2021 15:27:09 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
