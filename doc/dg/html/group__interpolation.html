<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Discontinuous Galerkin Library: Interpolation and projection</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dG</a></li>
    <li><a href="../../geometries/html/modules.html">geometries</a></li>
    <li><a href="../../file/html/namespacefile.html">file</a></li>
    <li><a href="../../exblas/html/namespaceexblas.html">exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Discontinuous Galerkin numerical methods and container free numerical algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__interpolation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interpolation and projection<div class="ingroups"><a class="el" href="group__geo.html">Level 3: Topology and Geometry</a> &raquo; <a class="el" href="group__grid.html">Topological grids and operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Interpolation and projection:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__interpolation.png" border="0" alt="" usemap="#group____interpolation"/>
<map name="group____interpolation" id="group____interpolation">
<area shape="rect" id="node2" href="group__grid.html" title="Topological grids and\l operations" alt="" coords="5,5,151,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedg_1_1create"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1create.html">dg::create</a></td></tr>
<tr class="memdesc:namespacedg_1_1create"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functions used for matrix creation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab5f0376b6886e47e4f72c922cfc0c7a7"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gab5f0376b6886e47e4f72c922cfc0c7a7"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g)</td></tr>
<tr class="memdesc:gab5f0376b6886e47e4f72c922cfc0c7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">More...</a><br /></td></tr>
<tr class="separator:gab5f0376b6886e47e4f72c922cfc0c7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac238077768fe5fc49ab3cd4f94569ef4"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gac238077768fe5fc49ab3cd4f94569ef4"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gac238077768fe5fc49ab3cd4f94569ef4">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gac238077768fe5fc49ab3cd4f94569ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gac238077768fe5fc49ab3cd4f94569ef4">More...</a><br /></td></tr>
<tr class="separator:gac238077768fe5fc49ab3cd4f94569ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac940cc53d90e88a3c88a4f235ff20409"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gac940cc53d90e88a3c88a4f235ff20409"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gac940cc53d90e88a3c88a4f235ff20409">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const thrust::host_vector&lt; real_type &gt; &amp;z, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gac940cc53d90e88a3c88a4f235ff20409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gac940cc53d90e88a3c88a4f235ff20409">More...</a><br /></td></tr>
<tr class="separator:gac940cc53d90e88a3c88a4f235ff20409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43cb2b93b0c2c40e6694616bca9fc49b"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga43cb2b93b0c2c40e6694616bca9fc49b"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga43cb2b93b0c2c40e6694616bca9fc49b">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga43cb2b93b0c2c40e6694616bca9fc49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga43cb2b93b0c2c40e6694616bca9fc49b">More...</a><br /></td></tr>
<tr class="separator:ga43cb2b93b0c2c40e6694616bca9fc49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7615acf5b63591b625ef2a6a4d4bf575"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga7615acf5b63591b625ef2a6a4d4bf575"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga7615acf5b63591b625ef2a6a4d4bf575">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga7615acf5b63591b625ef2a6a4d4bf575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga7615acf5b63591b625ef2a6a4d4bf575">More...</a><br /></td></tr>
<tr class="separator:ga7615acf5b63591b625ef2a6a4d4bf575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga910bab705307590f6f2bff0220a2c103"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga910bab705307590f6f2bff0220a2c103"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga910bab705307590f6f2bff0220a2c103">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga910bab705307590f6f2bff0220a2c103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga910bab705307590f6f2bff0220a2c103">More...</a><br /></td></tr>
<tr class="separator:ga910bab705307590f6f2bff0220a2c103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b64dbb139c1f3cf64bdf63eb84c20e0"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga3b64dbb139c1f3cf64bdf63eb84c20e0"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga3b64dbb139c1f3cf64bdf63eb84c20e0">dg::interpolate</a> (real_type x, real_type y, const thrust::host_vector&lt; real_type &gt; &amp;v, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g)</td></tr>
<tr class="memdesc:ga3b64dbb139c1f3cf64bdf63eb84c20e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a single point.  <a href="group__interpolation.html#ga3b64dbb139c1f3cf64bdf63eb84c20e0">More...</a><br /></td></tr>
<tr class="separator:ga3b64dbb139c1f3cf64bdf63eb84c20e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b5393db21fa03f0c7738eb7dc2526b7"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga2b5393db21fa03f0c7738eb7dc2526b7"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga2b5393db21fa03f0c7738eb7dc2526b7">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g)</td></tr>
<tr class="memdesc:ga2b5393db21fa03f0c7738eb7dc2526b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga2b5393db21fa03f0c7738eb7dc2526b7">More...</a><br /></td></tr>
<tr class="separator:ga2b5393db21fa03f0c7738eb7dc2526b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269972b42917096fd1206a6be83d8665"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga269972b42917096fd1206a6be83d8665"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga269972b42917096fd1206a6be83d8665">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga269972b42917096fd1206a6be83d8665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga269972b42917096fd1206a6be83d8665">More...</a><br /></td></tr>
<tr class="separator:ga269972b42917096fd1206a6be83d8665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58179b948ca7bb7b2bab744c5ac3c599"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga58179b948ca7bb7b2bab744c5ac3c599"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga58179b948ca7bb7b2bab744c5ac3c599">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const thrust::host_vector&lt; real_type &gt; &amp;z, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga58179b948ca7bb7b2bab744c5ac3c599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga58179b948ca7bb7b2bab744c5ac3c599">More...</a><br /></td></tr>
<tr class="separator:ga58179b948ca7bb7b2bab744c5ac3c599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555e06c4b7779feba87d4329c3d03624"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga555e06c4b7779feba87d4329c3d03624"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga555e06c4b7779feba87d4329c3d03624">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga555e06c4b7779feba87d4329c3d03624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga555e06c4b7779feba87d4329c3d03624">More...</a><br /></td></tr>
<tr class="separator:ga555e06c4b7779feba87d4329c3d03624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827bd31c77f2d5641080b68edbdcfff1"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga827bd31c77f2d5641080b68edbdcfff1"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga827bd31c77f2d5641080b68edbdcfff1">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga827bd31c77f2d5641080b68edbdcfff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga827bd31c77f2d5641080b68edbdcfff1">More...</a><br /></td></tr>
<tr class="separator:ga827bd31c77f2d5641080b68edbdcfff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbcffe4d3860746df9e86f8e829ad457"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gafbcffe4d3860746df9e86f8e829ad457"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gafbcffe4d3860746df9e86f8e829ad457">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gafbcffe4d3860746df9e86f8e829ad457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gafbcffe4d3860746df9e86f8e829ad457">More...</a><br /></td></tr>
<tr class="separator:gafbcffe4d3860746df9e86f8e829ad457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf868a30b376e9fef78f58592d37d61ca"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaf868a30b376e9fef78f58592d37d61ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaf868a30b376e9fef78f58592d37d61ca">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gaf868a30b376e9fef78f58592d37d61ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gaf868a30b376e9fef78f58592d37d61ca">More...</a><br /></td></tr>
<tr class="separator:gaf868a30b376e9fef78f58592d37d61ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad3681c543cdcd1fa4fdd0e784610afd"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaad3681c543cdcd1fa4fdd0e784610afd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaad3681c543cdcd1fa4fdd0e784610afd">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gaad3681c543cdcd1fa4fdd0e784610afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gaad3681c543cdcd1fa4fdd0e784610afd">More...</a><br /></td></tr>
<tr class="separator:gaad3681c543cdcd1fa4fdd0e784610afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714c25738e9890edd270e74e3e1bc80f"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga714c25738e9890edd270e74e3e1bc80f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga714c25738e9890edd270e74e3e1bc80f">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga714c25738e9890edd270e74e3e1bc80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga714c25738e9890edd270e74e3e1bc80f">More...</a><br /></td></tr>
<tr class="separator:ga714c25738e9890edd270e74e3e1bc80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad013f68ac363a5f90252e864d04814cb"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad013f68ac363a5f90252e864d04814cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad013f68ac363a5f90252e864d04814cb">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gad013f68ac363a5f90252e864d04814cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gad013f68ac363a5f90252e864d04814cb">More...</a><br /></td></tr>
<tr class="separator:gad013f68ac363a5f90252e864d04814cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85040fab4d55bc0d1f8f4b04632d06ce"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga85040fab4d55bc0d1f8f4b04632d06ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga85040fab4d55bc0d1f8f4b04632d06ce">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga85040fab4d55bc0d1f8f4b04632d06ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga85040fab4d55bc0d1f8f4b04632d06ce">More...</a><br /></td></tr>
<tr class="separator:ga85040fab4d55bc0d1f8f4b04632d06ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fcd75e352138c84a0fe43aa66c15dd"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga37fcd75e352138c84a0fe43aa66c15dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga37fcd75e352138c84a0fe43aa66c15dd">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga37fcd75e352138c84a0fe43aa66c15dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga37fcd75e352138c84a0fe43aa66c15dd">More...</a><br /></td></tr>
<tr class="separator:ga37fcd75e352138c84a0fe43aa66c15dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd441ee788e536ebf699bd7b28d132b"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaedd441ee788e536ebf699bd7b28d132b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaedd441ee788e536ebf699bd7b28d132b">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gaedd441ee788e536ebf699bd7b28d132b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an MPI row distributed interpolation matrix.  <a href="group__interpolation.html#gaedd441ee788e536ebf699bd7b28d132b">More...</a><br /></td></tr>
<tr class="separator:gaedd441ee788e536ebf699bd7b28d132b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20f69fb78f6536cff2fd882addb9ba78"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga20f69fb78f6536cff2fd882addb9ba78"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga20f69fb78f6536cff2fd882addb9ba78">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga20f69fb78f6536cff2fd882addb9ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga20f69fb78f6536cff2fd882addb9ba78">More...</a><br /></td></tr>
<tr class="separator:ga20f69fb78f6536cff2fd882addb9ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59fb7f0363347d566739cdd883ade47c"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga59fb7f0363347d566739cdd883ade47c"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga59fb7f0363347d566739cdd883ade47c">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga59fb7f0363347d566739cdd883ade47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga59fb7f0363347d566739cdd883ade47c">More...</a><br /></td></tr>
<tr class="separator:ga59fb7f0363347d566739cdd883ade47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd76425accf9b0f44fc99ee876dd66e5"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gabd76425accf9b0f44fc99ee876dd66e5"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gabd76425accf9b0f44fc99ee876dd66e5">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gabd76425accf9b0f44fc99ee876dd66e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gabd76425accf9b0f44fc99ee876dd66e5">More...</a><br /></td></tr>
<tr class="separator:gabd76425accf9b0f44fc99ee876dd66e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9cc0ad9d153866a5a98223a53e5d44"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gacd9cc0ad9d153866a5a98223a53e5d44"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gacd9cc0ad9d153866a5a98223a53e5d44">dg::create::projection</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gacd9cc0ad9d153866a5a98223a53e5d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gacd9cc0ad9d153866a5a98223a53e5d44">More...</a><br /></td></tr>
<tr class="separator:gacd9cc0ad9d153866a5a98223a53e5d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6943a7a544a577dae24c4ab10bf8117"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gac6943a7a544a577dae24c4ab10bf8117"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gac6943a7a544a577dae24c4ab10bf8117">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gac6943a7a544a577dae24c4ab10bf8117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gac6943a7a544a577dae24c4ab10bf8117">More...</a><br /></td></tr>
<tr class="separator:gac6943a7a544a577dae24c4ab10bf8117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga2ca23ae164ef6ff18fbdaf7ef9c02ca8">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga2ca23ae164ef6ff18fbdaf7ef9c02ca8">More...</a><br /></td></tr>
<tr class="separator:ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36df1674e2af618cccfc9198a9f40ec0"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga36df1674e2af618cccfc9198a9f40ec0"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0">dg::create::transformation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga36df1674e2af618cccfc9198a9f40ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0">More...</a><br /></td></tr>
<tr class="separator:ga36df1674e2af618cccfc9198a9f40ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083d44d4f7fe426731d083302c4a40e5"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga083d44d4f7fe426731d083302c4a40e5"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga083d44d4f7fe426731d083302c4a40e5">dg::create::transformation</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga083d44d4f7fe426731d083302c4a40e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#ga083d44d4f7fe426731d083302c4a40e5">More...</a><br /></td></tr>
<tr class="separator:ga083d44d4f7fe426731d083302c4a40e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad069ca6eb4b8294f47b8981db73ec303"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad069ca6eb4b8294f47b8981db73ec303"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad069ca6eb4b8294f47b8981db73ec303">dg::create::transformation</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gad069ca6eb4b8294f47b8981db73ec303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#gad069ca6eb4b8294f47b8981db73ec303">More...</a><br /></td></tr>
<tr class="separator:gad069ca6eb4b8294f47b8981db73ec303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85bb8ca428ec2ff85376c5a211f9c66d"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga85bb8ca428ec2ff85376c5a211f9c66d"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga85bb8ca428ec2ff85376c5a211f9c66d">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga85bb8ca428ec2ff85376c5a211f9c66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga85bb8ca428ec2ff85376c5a211f9c66d">More...</a><br /></td></tr>
<tr class="separator:ga85bb8ca428ec2ff85376c5a211f9c66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5568088cd5434971e71c6b748c067d1"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad5568088cd5434971e71c6b748c067d1"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad5568088cd5434971e71c6b748c067d1">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gad5568088cd5434971e71c6b748c067d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gad5568088cd5434971e71c6b748c067d1">More...</a><br /></td></tr>
<tr class="separator:gad5568088cd5434971e71c6b748c067d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c6214991f472f57f9dc782006f2130"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga12c6214991f472f57f9dc782006f2130"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga12c6214991f472f57f9dc782006f2130">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga12c6214991f472f57f9dc782006f2130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga12c6214991f472f57f9dc782006f2130">More...</a><br /></td></tr>
<tr class="separator:ga12c6214991f472f57f9dc782006f2130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e8c5ffd2fab9cd4e1b9b513c4a37492"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga6e8c5ffd2fab9cd4e1b9b513c4a37492"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga6e8c5ffd2fab9cd4e1b9b513c4a37492">dg::create::projection</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga6e8c5ffd2fab9cd4e1b9b513c4a37492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga6e8c5ffd2fab9cd4e1b9b513c4a37492">More...</a><br /></td></tr>
<tr class="separator:ga6e8c5ffd2fab9cd4e1b9b513c4a37492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c84ab3bbfb575eb3dd871ae22d32a7"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad1c84ab3bbfb575eb3dd871ae22d32a7"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad1c84ab3bbfb575eb3dd871ae22d32a7">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gad1c84ab3bbfb575eb3dd871ae22d32a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gad1c84ab3bbfb575eb3dd871ae22d32a7">More...</a><br /></td></tr>
<tr class="separator:gad1c84ab3bbfb575eb3dd871ae22d32a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7688622f75b7ad9a4f8d8ce914338fbf"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga7688622f75b7ad9a4f8d8ce914338fbf"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga7688622f75b7ad9a4f8d8ce914338fbf">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga7688622f75b7ad9a4f8d8ce914338fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga7688622f75b7ad9a4f8d8ce914338fbf">More...</a><br /></td></tr>
<tr class="separator:ga7688622f75b7ad9a4f8d8ce914338fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3b64dbb139c1f3cf64bdf63eb84c20e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b64dbb139c1f3cf64bdf63eb84c20e0">&#9670;&nbsp;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a single point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate in LSPACE, s.a. <a class="el" href="group__misc.html#gaf590d88107541b2b65dbb4cc70163067" title="Transform a vector from XSPACE to LSPACE. ">dg::forward_transform( )</a> </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>g.contains(x,y)</code> must return true </dd></dl>

</div>
</div>
<a id="ga2b5393db21fa03f0c7738eb7dc2526b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b5393db21fa03f0c7738eb7dc2526b7">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="ga269972b42917096fd1206a6be83d8665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga269972b42917096fd1206a6be83d8665">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>globalbcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>NEU for common interpolation. DIR for zeros at Box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="ga58179b948ca7bb7b2bab744c5ac3c599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58179b948ca7bb7b2bab744c5ac3c599">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>globalbcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates. In z-direction only a nearest neighbor interpolation is used </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>determines what to do if values lie exactly on the boundary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The values of x, y and z must lie within the boundaries of g </dd></dl>

</div>
</div>
<a id="ga555e06c4b7779feba87d4329c3d03624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555e06c4b7779feba87d4329c3d03624">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gab5f0376b6886e47e4f72c922cfc0c7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5f0376b6886e47e4f72c922cfc0c7a7">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="ga827bd31c77f2d5641080b68edbdcfff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga827bd31c77f2d5641080b68edbdcfff1">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gaf868a30b376e9fef78f58592d37d61ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf868a30b376e9fef78f58592d37d61ca">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt;real_type&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="gafbcffe4d3860746df9e86f8e829ad457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbcffe4d3860746df9e86f8e829ad457">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gaad3681c543cdcd1fa4fdd0e784610afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad3681c543cdcd1fa4fdd0e784610afd">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt;real_type&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="gac238077768fe5fc49ab3cd4f94569ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac238077768fe5fc49ab3cd4f94569ef4">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div><div class="line">    thrust::host_vector&lt;double&gt; x( g.size()), y(x);</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div><div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div><div class="line">        {</div><div class="line">            x[i*g.Nx()*g.n() + j] =</div><div class="line">                    g.x0() + (j+0.5)*g.hx()/(double)(g.n());</div><div class="line">            y[i*g.Nx()*g.n() + j] =</div><div class="line">                    g.y0() + (i+0.5)*g.hy()/(double)(g.n());</div><div class="line">        }</div><div class="line">    <span class="comment">//typedef cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; Matrix;</span></div><div class="line">    Matrix B = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( x, y, g);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g);</div><div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div><div class="line">    <a class="code" href="group__blas2.html#ga9bd2015d31362b25d61110f91cf3b0b9">dg::blas2::symv</a>( B, vec, inter);</div><div class="line">    <span class="comment">//inter now contains the values of vec interpolated at equidistant points</span></div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points ( has to have equal size as x) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies exactly on the boundary in x: DIR generates zeroes in the interpolation matrix, NEU and PER interpolate the inner side polynomial. (DIR_NEU and NEU_DIR apply NEU / DIR to the respective left or right boundary ) </td></tr>
    <tr><td class="paramname">bcy</td><td>determines what to do when a point lies exactly on the boundary in y. Behaviour correponds to bcx.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>all points (x,y) must lie within or on the boundaries of g. </dd></dl>

</div>
</div>
<a id="gaedd441ee788e536ebf699bd7b28d132b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedd441ee788e536ebf699bd7b28d132b">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt;real_type&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an MPI row distributed interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div><div class="line">    thrust::host_vector&lt;double&gt; x( g.size()), y(x);</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div><div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div><div class="line">        {</div><div class="line">            x[i*g.Nx()*g.n() + j] =</div><div class="line">                    g.x0() + (j+0.5)*g.hx()/(double)(g.n());</div><div class="line">            y[i*g.Nx()*g.n() + j] =</div><div class="line">                    g.y0() + (i+0.5)*g.hy()/(double)(g.n());</div><div class="line">        }</div><div class="line">    <span class="comment">//typedef cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; Matrix;</span></div><div class="line">    Matrix B = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( x, y, g);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g);</div><div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div><div class="line">    <a class="code" href="group__blas2.html#ga9bd2015d31362b25d61110f91cf3b0b9">dg::blas2::symv</a>( B, vec, inter);</div><div class="line">    <span class="comment">//inter now contains the values of vec interpolated at equidistant points</span></div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points ( has to have equal size as x) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies exactly on the boundary in x: DIR generates zeroes in the interpolation matrix, NEU and PER interpolate the inner side polynomial. (DIR_NEU and NEU_DIR apply NEU / DIR to the respective left or right boundary ) </td></tr>
    <tr><td class="paramname">bcy</td><td>determines what to do when a point lies exactly on the boundary in y. Behaviour correponds to bcx.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>all points (x,y) must lie within or on the boundaries of g. </dd></dl>

</div>
</div>
<a id="gac940cc53d90e88a3c88a4f235ff20409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac940cc53d90e88a3c88a4f235ff20409">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div><div class="line">    thrust::host_vector&lt;double&gt; x( g.size()), y(x), z(x);</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;g.Nz(); k++)</div><div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div><div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div><div class="line">            {</div><div class="line">                x[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] =</div><div class="line">                        g.x0() + (j+0.5)*g.hx()/(double)(g.n());</div><div class="line">                y[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] =</div><div class="line">                        g.y0() + (i+0.5)*g.hy()/(double)(g.n());</div><div class="line">                z[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] =</div><div class="line">                        g.z0() + (k+0.5)*g.hz();</div><div class="line">            }</div><div class="line">    <span class="comment">//typedef cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; Matrix;</span></div><div class="line">    Matrix B = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( x, y, z, g);</div><div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga0d2da37399e38acb2b243f568d5e7443">dg::evaluate</a>( <span class="keyword">function</span>, g);</div><div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div><div class="line">    <a class="code" href="group__blas2.html#ga9bd2015d31362b25d61110f91cf3b0b9">dg::blas2::symv</a>( B, vec, inter);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies exactly on the boundary in x: DIR generates zeroes in the interpolation matrix, NEU and PER interpolate the inner side polynomial. (DIR_NEU and NEU_DIR apply NEU / DIR to the respective left or right boundary ) </td></tr>
    <tr><td class="paramname">bcy</td><td>determines what to do when a point lies exactly on the boundary in y. Behaviour correponds to bcx.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>all points (x, y, z) must lie within or on the boundaries of g </dd></dl>

</div>
</div>
<a id="ga43cb2b93b0c2c40e6694616bca9fc49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43cb2b93b0c2c40e6694616bca9fc49b">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga7615acf5b63591b625ef2a6a4d4bf575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7615acf5b63591b625ef2a6a4d4bf575">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga910bab705307590f6f2bff0220a2c103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga910bab705307590f6f2bff0220a2c103">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga85bb8ca428ec2ff85376c5a211f9c66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85bb8ca428ec2ff85376c5a211f9c66d">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gad5568088cd5434971e71c6b748c067d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5568088cd5434971e71c6b748c067d1">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga12c6214991f472f57f9dc782006f2130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c6214991f472f57f9dc782006f2130">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga20f69fb78f6536cff2fd882addb9ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20f69fb78f6536cff2fd882addb9ba78">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga59fb7f0363347d566739cdd883ade47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59fb7f0363347d566739cdd883ade47c">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gabd76425accf9b0f44fc99ee876dd66e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd76425accf9b0f44fc99ee876dd66e5">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, real_type, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga714c25738e9890edd270e74e3e1bc80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga714c25738e9890edd270e74e3e1bc80f">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt;real_type&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gad013f68ac363a5f90252e864d04814cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad013f68ac363a5f90252e864d04814cb">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt;real_type&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#gab5f0376b6886e47e4f72c922cfc0c7a7">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga6e8c5ffd2fab9cd4e1b9b513c4a37492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e8c5ffd2fab9cd4e1b9b513c4a37492">&#9670;&nbsp;</a></span>projection() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gad1c84ab3bbfb575eb3dd871ae22d32a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1c84ab3bbfb575eb3dd871ae22d32a7">&#9670;&nbsp;</a></span>projection() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga7688622f75b7ad9a4f8d8ce914338fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7688622f75b7ad9a4f8d8ce914338fbf">&#9670;&nbsp;</a></span>projection() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gacd9cc0ad9d153866a5a98223a53e5d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd9cc0ad9d153866a5a98223a53e5d44">&#9670;&nbsp;</a></span>projection() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga85040fab4d55bc0d1f8f4b04632d06ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85040fab4d55bc0d1f8f4b04632d06ce">&#9670;&nbsp;</a></span>projection() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt;real_type&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gac6943a7a544a577dae24c4ab10bf8117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6943a7a544a577dae24c4ab10bf8117">&#9670;&nbsp;</a></span>projection() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga37fcd75e352138c84a0fe43aa66c15dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fcd75e352138c84a0fe43aa66c15dd">&#9670;&nbsp;</a></span>projection() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gac256ed27ac25d8bc36b9f59c5a447c2a">dg::tMIHMatrix</a>&lt;real_type&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga2ca23ae164ef6ff18fbdaf7ef9c02ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ca23ae164ef6ff18fbdaf7ef9c02ca8">&#9670;&nbsp;</a></span>projection() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga36df1674e2af618cccfc9198a9f40ec0" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga36df1674e2af618cccfc9198a9f40ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36df1674e2af618cccfc9198a9f40ec0">&#9670;&nbsp;</a></span>transformation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
<a id="ga083d44d4f7fe426731d083302c4a40e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga083d44d4f7fe426731d083302c4a40e5">&#9670;&nbsp;</a></span>transformation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
<a id="gad069ca6eb4b8294f47b8981db73ec303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad069ca6eb4b8294f47b8981db73ec303">&#9670;&nbsp;</a></span>transformation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory&gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 28 2018 23:02:49 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
