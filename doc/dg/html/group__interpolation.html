<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Discontinuous Galerkin Library: Interpolation and projection</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="tablist"> 
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dG</a></li>
    <li><a href="../../geometries/html/modules.html">geometry</a></li>
    <li><a href="../../file/html/namespacefile.html">file</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Discontinuous Galerkin numerical methods and container free numerical algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__interpolation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interpolation and projection<div class="ingroups"><a class="el" href="group__geo.html">Level 3: Topology and Geometry</a> &raquo; <a class="el" href="group__grid.html">Topological grids and operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Interpolation and projection:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__interpolation.png" border="0" alt="" usemap="#group____interpolation"/>
<map name="group____interpolation" id="group____interpolation">
<area shape="rect" id="node2" href="group__grid.html" title="Topological grids and\l operations" alt="" coords="5,5,151,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedg_1_1create"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1create.html">dg::create</a></td></tr>
<tr class="memdesc:namespacedg_1_1create"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functions used for matrix creation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga833bce88eabd2cd111e3912d9331cf95"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a> (const thrust::host_vector&lt; double &gt; &amp;x, const Grid1d &amp;g)</td></tr>
<tr class="memdesc:ga833bce88eabd2cd111e3912d9331cf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">More...</a><br /></td></tr>
<tr class="separator:ga833bce88eabd2cd111e3912d9331cf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaefc47ad1d778cea972f7a5964019a8"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaeaefc47ad1d778cea972f7a5964019a8">dg::create::interpolation</a> (const thrust::host_vector&lt; double &gt; &amp;x, const thrust::host_vector&lt; double &gt; &amp;y, const aTopology2d &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gaeaefc47ad1d778cea972f7a5964019a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gaeaefc47ad1d778cea972f7a5964019a8">More...</a><br /></td></tr>
<tr class="separator:gaeaefc47ad1d778cea972f7a5964019a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c69c71c0b79097f978c7ec52142299"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gac8c69c71c0b79097f978c7ec52142299">dg::create::interpolation</a> (const thrust::host_vector&lt; double &gt; &amp;x, const thrust::host_vector&lt; double &gt; &amp;y, const thrust::host_vector&lt; double &gt; &amp;z, const aTopology3d &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gac8c69c71c0b79097f978c7ec52142299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gac8c69c71c0b79097f978c7ec52142299">More...</a><br /></td></tr>
<tr class="separator:gac8c69c71c0b79097f978c7ec52142299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56fafc7fdcadcb06e4dbe1af9d87d8ad"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga56fafc7fdcadcb06e4dbe1af9d87d8ad">dg::create::interpolation</a> (const Grid1d &amp;g_new, const Grid1d &amp;g_old)</td></tr>
<tr class="memdesc:ga56fafc7fdcadcb06e4dbe1af9d87d8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga56fafc7fdcadcb06e4dbe1af9d87d8ad">More...</a><br /></td></tr>
<tr class="separator:ga56fafc7fdcadcb06e4dbe1af9d87d8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7eab0e43c90abb89692de214c90865d"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad7eab0e43c90abb89692de214c90865d">dg::create::interpolation</a> (const aTopology2d &amp;g_new, const aTopology2d &amp;g_old)</td></tr>
<tr class="memdesc:gad7eab0e43c90abb89692de214c90865d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gad7eab0e43c90abb89692de214c90865d">More...</a><br /></td></tr>
<tr class="separator:gad7eab0e43c90abb89692de214c90865d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c60df5718d1300c0888f5bdb9614ae7"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga3c60df5718d1300c0888f5bdb9614ae7">dg::create::interpolation</a> (const aTopology3d &amp;g_new, const aTopology3d &amp;g_old)</td></tr>
<tr class="memdesc:ga3c60df5718d1300c0888f5bdb9614ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga3c60df5718d1300c0888f5bdb9614ae7">More...</a><br /></td></tr>
<tr class="separator:ga3c60df5718d1300c0888f5bdb9614ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad36778cefc40882a4777f8d7ac5f4c7d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad36778cefc40882a4777f8d7ac5f4c7d">dg::interpolate</a> (double x, double y, const thrust::host_vector&lt; double &gt; &amp;v, const aTopology2d &amp;g)</td></tr>
<tr class="memdesc:gad36778cefc40882a4777f8d7ac5f4c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a single point.  <a href="group__interpolation.html#gad36778cefc40882a4777f8d7ac5f4c7d">More...</a><br /></td></tr>
<tr class="separator:gad36778cefc40882a4777f8d7ac5f4c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8473267baa8b7a77128afb90bea2b047"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga8473267baa8b7a77128afb90bea2b047">dg::create::interpolation</a> (const thrust::host_vector&lt; double &gt; &amp;x, const GridX1d &amp;g)</td></tr>
<tr class="memdesc:ga8473267baa8b7a77128afb90bea2b047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga8473267baa8b7a77128afb90bea2b047">More...</a><br /></td></tr>
<tr class="separator:ga8473267baa8b7a77128afb90bea2b047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7df3bdd69b62fe28b54eaeaaabc5c42"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gac7df3bdd69b62fe28b54eaeaaabc5c42">dg::create::interpolation</a> (const thrust::host_vector&lt; double &gt; &amp;x, const thrust::host_vector&lt; double &gt; &amp;y, const aTopologyX2d &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gac7df3bdd69b62fe28b54eaeaaabc5c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gac7df3bdd69b62fe28b54eaeaaabc5c42">More...</a><br /></td></tr>
<tr class="separator:gac7df3bdd69b62fe28b54eaeaaabc5c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621972e2ec713500691574c6b95d32b3"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga621972e2ec713500691574c6b95d32b3">dg::create::interpolation</a> (const thrust::host_vector&lt; double &gt; &amp;x, const thrust::host_vector&lt; double &gt; &amp;y, const thrust::host_vector&lt; double &gt; &amp;z, const aTopologyX3d &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga621972e2ec713500691574c6b95d32b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga621972e2ec713500691574c6b95d32b3">More...</a><br /></td></tr>
<tr class="separator:ga621972e2ec713500691574c6b95d32b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27511f07efe1e8fede2ccb4430b7f98"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad27511f07efe1e8fede2ccb4430b7f98">dg::create::interpolation</a> (const GridX1d &amp;g_new, const GridX1d &amp;g_old)</td></tr>
<tr class="memdesc:gad27511f07efe1e8fede2ccb4430b7f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gad27511f07efe1e8fede2ccb4430b7f98">More...</a><br /></td></tr>
<tr class="separator:gad27511f07efe1e8fede2ccb4430b7f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4052b736bc1b2c2f41c61e521cc83306"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga4052b736bc1b2c2f41c61e521cc83306">dg::create::interpolation</a> (const aTopologyX2d &amp;g_new, const aTopologyX2d &amp;g_old)</td></tr>
<tr class="memdesc:ga4052b736bc1b2c2f41c61e521cc83306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga4052b736bc1b2c2f41c61e521cc83306">More...</a><br /></td></tr>
<tr class="separator:ga4052b736bc1b2c2f41c61e521cc83306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba04814d2ff2b9079ef0d181d5e90ead"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaba04814d2ff2b9079ef0d181d5e90ead">dg::create::interpolation</a> (const aTopologyX3d &amp;g_new, const aTopologyX3d &amp;g_old)</td></tr>
<tr class="memdesc:gaba04814d2ff2b9079ef0d181d5e90ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gaba04814d2ff2b9079ef0d181d5e90ead">More...</a><br /></td></tr>
<tr class="separator:gaba04814d2ff2b9079ef0d181d5e90ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c81a9d854a5904782dcf09c3bbd361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga51c81a9d854a5904782dcf09c3bbd361">dg::create::interpolation</a> (const aMPITopology2d &amp;g_new, const aMPITopology2d &amp;g_old)</td></tr>
<tr class="memdesc:ga51c81a9d854a5904782dcf09c3bbd361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga51c81a9d854a5904782dcf09c3bbd361">More...</a><br /></td></tr>
<tr class="separator:ga51c81a9d854a5904782dcf09c3bbd361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35fce3278a36fab0802963bdc5967df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga35fce3278a36fab0802963bdc5967df1">dg::create::interpolation</a> (const aMPITopology3d &amp;g_new, const aMPITopology3d &amp;g_old)</td></tr>
<tr class="memdesc:ga35fce3278a36fab0802963bdc5967df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga35fce3278a36fab0802963bdc5967df1">More...</a><br /></td></tr>
<tr class="separator:ga35fce3278a36fab0802963bdc5967df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2bdf111af9570239b7803ec96bd7c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gabd2bdf111af9570239b7803ec96bd7c8">dg::create::interpolationT</a> (const aMPITopology2d &amp;g_new, const aMPITopology2d &amp;g_old)</td></tr>
<tr class="memdesc:gabd2bdf111af9570239b7803ec96bd7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gabd2bdf111af9570239b7803ec96bd7c8">More...</a><br /></td></tr>
<tr class="separator:gabd2bdf111af9570239b7803ec96bd7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a66c8e73ce7f018d987a0bc8192d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga70a66c8e73ce7f018d987a0bc8192d9b">dg::create::interpolationT</a> (const aMPITopology3d &amp;g_new, const aMPITopology3d &amp;g_old)</td></tr>
<tr class="memdesc:ga70a66c8e73ce7f018d987a0bc8192d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga70a66c8e73ce7f018d987a0bc8192d9b">More...</a><br /></td></tr>
<tr class="separator:ga70a66c8e73ce7f018d987a0bc8192d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335de04041bed42673e0b00b18ebff73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga335de04041bed42673e0b00b18ebff73">dg::create::projection</a> (const aMPITopology2d &amp;g_new, const aMPITopology2d &amp;g_old)</td></tr>
<tr class="memdesc:ga335de04041bed42673e0b00b18ebff73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga335de04041bed42673e0b00b18ebff73">More...</a><br /></td></tr>
<tr class="separator:ga335de04041bed42673e0b00b18ebff73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbcdbaa6ad92679aa4b43f6409788640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gabbcdbaa6ad92679aa4b43f6409788640">dg::create::projection</a> (const aMPITopology3d &amp;g_new, const aMPITopology3d &amp;g_old)</td></tr>
<tr class="memdesc:gabbcdbaa6ad92679aa4b43f6409788640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gabbcdbaa6ad92679aa4b43f6409788640">More...</a><br /></td></tr>
<tr class="separator:gabbcdbaa6ad92679aa4b43f6409788640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798f01f262b3516bb653e35318a69df6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga798f01f262b3516bb653e35318a69df6">dg::create::interpolation</a> (const <a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a">dg::HVec</a> &amp;x, const <a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a">dg::HVec</a> &amp;y, const aMPITopology2d &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga798f01f262b3516bb653e35318a69df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an MPI row distributed interpolation matrix.  <a href="group__interpolation.html#ga798f01f262b3516bb653e35318a69df6">More...</a><br /></td></tr>
<tr class="separator:ga798f01f262b3516bb653e35318a69df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadf1d53a4c123d7d262f025b640e60a"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gadadf1d53a4c123d7d262f025b640e60a">dg::create::interpolationT</a> (const Grid1d &amp;g_new, const Grid1d &amp;g_old)</td></tr>
<tr class="memdesc:gadadf1d53a4c123d7d262f025b640e60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gadadf1d53a4c123d7d262f025b640e60a">More...</a><br /></td></tr>
<tr class="separator:gadadf1d53a4c123d7d262f025b640e60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab03bef308c6520f80e2eb3178645b9ba"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gab03bef308c6520f80e2eb3178645b9ba">dg::create::interpolationT</a> (const aTopology2d &amp;g_new, const aTopology2d &amp;g_old)</td></tr>
<tr class="memdesc:gab03bef308c6520f80e2eb3178645b9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gab03bef308c6520f80e2eb3178645b9ba">More...</a><br /></td></tr>
<tr class="separator:gab03bef308c6520f80e2eb3178645b9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d89432baa99836d5be9daab02a894ad"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga7d89432baa99836d5be9daab02a894ad">dg::create::interpolationT</a> (const aTopology3d &amp;g_new, const aTopology3d &amp;g_old)</td></tr>
<tr class="memdesc:ga7d89432baa99836d5be9daab02a894ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga7d89432baa99836d5be9daab02a894ad">More...</a><br /></td></tr>
<tr class="separator:ga7d89432baa99836d5be9daab02a894ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06712951dc902031061a3ed5b1ab8a6"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaa06712951dc902031061a3ed5b1ab8a6">dg::create::projection</a> (const Grid1d &amp;g_new, const Grid1d &amp;g_old)</td></tr>
<tr class="memdesc:gaa06712951dc902031061a3ed5b1ab8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gaa06712951dc902031061a3ed5b1ab8a6">More...</a><br /></td></tr>
<tr class="separator:gaa06712951dc902031061a3ed5b1ab8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84082a7da5857b096b62de96847b11be"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga84082a7da5857b096b62de96847b11be">dg::create::projection</a> (const aTopology2d &amp;g_new, const aTopology2d &amp;g_old)</td></tr>
<tr class="memdesc:ga84082a7da5857b096b62de96847b11be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga84082a7da5857b096b62de96847b11be">More...</a><br /></td></tr>
<tr class="separator:ga84082a7da5857b096b62de96847b11be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc723c30214fc2e20c76dec82cc913e"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga9fc723c30214fc2e20c76dec82cc913e">dg::create::projection</a> (const aTopology3d &amp;g_new, const aTopology3d &amp;g_old)</td></tr>
<tr class="memdesc:ga9fc723c30214fc2e20c76dec82cc913e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga9fc723c30214fc2e20c76dec82cc913e">More...</a><br /></td></tr>
<tr class="separator:ga9fc723c30214fc2e20c76dec82cc913e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9eb1e78b21ee9d5ce6c19c88c247498"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498">dg::create::transformation</a> (const aTopology3d &amp;g_new, const aTopology3d &amp;g_old)</td></tr>
<tr class="memdesc:gad9eb1e78b21ee9d5ce6c19c88c247498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498">More...</a><br /></td></tr>
<tr class="separator:gad9eb1e78b21ee9d5ce6c19c88c247498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240b8e3776ec1cbd34d36ea29e1004a1"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga240b8e3776ec1cbd34d36ea29e1004a1">dg::create::transformation</a> (const aTopology2d &amp;g_new, const aTopology2d &amp;g_old)</td></tr>
<tr class="memdesc:ga240b8e3776ec1cbd34d36ea29e1004a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#ga240b8e3776ec1cbd34d36ea29e1004a1">More...</a><br /></td></tr>
<tr class="separator:ga240b8e3776ec1cbd34d36ea29e1004a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga127b484762ffdd319d4ca32763a7b1d0"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga127b484762ffdd319d4ca32763a7b1d0">dg::create::transformation</a> (const Grid1d &amp;g_new, const Grid1d &amp;g_old)</td></tr>
<tr class="memdesc:ga127b484762ffdd319d4ca32763a7b1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#ga127b484762ffdd319d4ca32763a7b1d0">More...</a><br /></td></tr>
<tr class="separator:ga127b484762ffdd319d4ca32763a7b1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac758f716648b670dba9d3120b18eae09"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gac758f716648b670dba9d3120b18eae09">dg::create::interpolationT</a> (const GridX1d &amp;g_new, const GridX1d &amp;g_old)</td></tr>
<tr class="memdesc:gac758f716648b670dba9d3120b18eae09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gac758f716648b670dba9d3120b18eae09">More...</a><br /></td></tr>
<tr class="separator:gac758f716648b670dba9d3120b18eae09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9d5e83476e162f0a4ffaa0cafc10888"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaa9d5e83476e162f0a4ffaa0cafc10888">dg::create::interpolationT</a> (const aTopologyX2d &amp;g_new, const aTopologyX2d &amp;g_old)</td></tr>
<tr class="memdesc:gaa9d5e83476e162f0a4ffaa0cafc10888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gaa9d5e83476e162f0a4ffaa0cafc10888">More...</a><br /></td></tr>
<tr class="separator:gaa9d5e83476e162f0a4ffaa0cafc10888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa38b730c61dd118823dfd3a6b803287f"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaa38b730c61dd118823dfd3a6b803287f">dg::create::interpolationT</a> (const aTopologyX3d &amp;g_new, const aTopologyX3d &amp;g_old)</td></tr>
<tr class="memdesc:gaa38b730c61dd118823dfd3a6b803287f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gaa38b730c61dd118823dfd3a6b803287f">More...</a><br /></td></tr>
<tr class="separator:gaa38b730c61dd118823dfd3a6b803287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17548d4a00606d68272b3ccc7e1ce34d"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga17548d4a00606d68272b3ccc7e1ce34d">dg::create::projection</a> (const GridX1d &amp;g_new, const GridX1d &amp;g_old)</td></tr>
<tr class="memdesc:ga17548d4a00606d68272b3ccc7e1ce34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga17548d4a00606d68272b3ccc7e1ce34d">More...</a><br /></td></tr>
<tr class="separator:ga17548d4a00606d68272b3ccc7e1ce34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0bfe9526a6b7005b286ccd4cb0ba3b"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga6f0bfe9526a6b7005b286ccd4cb0ba3b">dg::create::projection</a> (const aTopologyX2d &amp;g_new, const aTopologyX2d &amp;g_old)</td></tr>
<tr class="memdesc:ga6f0bfe9526a6b7005b286ccd4cb0ba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga6f0bfe9526a6b7005b286ccd4cb0ba3b">More...</a><br /></td></tr>
<tr class="separator:ga6f0bfe9526a6b7005b286ccd4cb0ba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93e540e256ef0c4f8f6fdf8343be773"><td class="memItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, double, cusp::host_memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gab93e540e256ef0c4f8f6fdf8343be773">dg::create::projection</a> (const aTopologyX3d &amp;g_new, const aTopologyX3d &amp;g_old)</td></tr>
<tr class="memdesc:gab93e540e256ef0c4f8f6fdf8343be773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gab93e540e256ef0c4f8f6fdf8343be773">More...</a><br /></td></tr>
<tr class="separator:gab93e540e256ef0c4f8f6fdf8343be773"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad36778cefc40882a4777f8d7ac5f4c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dg::interpolate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a single point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate in LSPACE, s.a. <a class="el" href="group__misc.html#ga54cdfb388de1fa32de687cc98cacc8e9" title="Transform a vector from XSPACE to LSPACE. ">dg::forward_transform( )</a> </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>g.contains(x,y)</code> must return true </dd></dl>

</div>
</div>
<a class="anchor" id="ga8473267baa8b7a77128afb90bea2b047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid_x1d.html">GridX1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a class="anchor" id="gac7df3bdd69b62fe28b54eaeaaabc5c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x2d.html">aTopologyX2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>globalbcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>NEU for common interpolation. DIR for zeros at Box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a class="anchor" id="ga621972e2ec713500691574c6b95d32b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x3d.html">aTopologyX3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>globalbcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates. In z-direction only a nearest neighbor interpolation is used </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>determines what to do if values lie exactly on the boundary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The values of x, y and z must lie within the boundaries of g </dd></dl>

</div>
</div>
<a class="anchor" id="gad27511f07efe1e8fede2ccb4430b7f98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid_x1d.html">GridX1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid_x1d.html">GridX1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga833bce88eabd2cd111e3912d9331cf95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid1d.html">Grid1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a class="anchor" id="ga4052b736bc1b2c2f41c61e521cc83306"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x2d.html">aTopologyX2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x2d.html">aTopologyX2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga51c81a9d854a5904782dcf09c3bbd361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a> dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology2d.html">aMPITopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology2d.html">aMPITopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a class="anchor" id="gaba04814d2ff2b9079ef0d181d5e90ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x3d.html">aTopologyX3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x3d.html">aTopologyX3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga35fce3278a36fab0802963bdc5967df1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a> dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology3d.html">aMPITopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology3d.html">aMPITopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaefc47ad1d778cea972f7a5964019a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div><div class="line">    thrust::host_vector&lt;double&gt; x( g.size()), y(x);</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div><div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div><div class="line">        {</div><div class="line">            x[i*g.Nx()*g.n() + j] = </div><div class="line">                    g.x0() + (j+0.5)*g.hx()/(double)(g.n());</div><div class="line">            y[i*g.Nx()*g.n() + j] = </div><div class="line">                    g.y0() + (i+0.5)*g.hy()/(double)(g.n());</div><div class="line">        }</div><div class="line">    <span class="comment">//typedef cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; Matrix;</span></div><div class="line">    Matrix B = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( x, y, g);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga7521f4acb4edaf2d7896d99f97e1ed9d">dg::evaluate</a>( <span class="keyword">function</span>, g); </div><div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div><div class="line">    <a class="code" href="group__blas2.html#gab1885f3913f72b7ea380d58f40c04656">dg::blas2::symv</a>( B, vec, inter);</div><div class="line">    <span class="comment">//inter now contains the values of vec interpolated at equidistant points</span></div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points ( has to have equal size as x) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies exactly on the boundary in x: DIR generates zeroes in the interpolation matrix, NEU and PER interpolate the inner side polynomial. (DIR_NEU and NEU_DIR apply NEU / DIR to the respective left or right boundary ) </td></tr>
    <tr><td class="paramname">bcy</td><td>determines what to do when a point lies exactly on the boundary in y. Behaviour correponds to bcx.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>all points (x,y) must lie within or on the boundaries of g. </dd></dl>

</div>
</div>
<a class="anchor" id="ga798f01f262b3516bb653e35318a69df6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a> dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a">dg::HVec</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a">dg::HVec</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology2d.html">aMPITopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an MPI row distributed interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div><div class="line">    thrust::host_vector&lt;double&gt; x( g.size()), y(x);</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div><div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div><div class="line">        {</div><div class="line">            x[i*g.Nx()*g.n() + j] = </div><div class="line">                    g.x0() + (j+0.5)*g.hx()/(double)(g.n());</div><div class="line">            y[i*g.Nx()*g.n() + j] = </div><div class="line">                    g.y0() + (i+0.5)*g.hy()/(double)(g.n());</div><div class="line">        }</div><div class="line">    <span class="comment">//typedef cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; Matrix;</span></div><div class="line">    Matrix B = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( x, y, g);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga7521f4acb4edaf2d7896d99f97e1ed9d">dg::evaluate</a>( <span class="keyword">function</span>, g); </div><div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div><div class="line">    <a class="code" href="group__blas2.html#gab1885f3913f72b7ea380d58f40c04656">dg::blas2::symv</a>( B, vec, inter);</div><div class="line">    <span class="comment">//inter now contains the values of vec interpolated at equidistant points</span></div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points ( has to have equal size as x) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies exactly on the boundary in x: DIR generates zeroes in the interpolation matrix, NEU and PER interpolate the inner side polynomial. (DIR_NEU and NEU_DIR apply NEU / DIR to the respective left or right boundary ) </td></tr>
    <tr><td class="paramname">bcy</td><td>determines what to do when a point lies exactly on the boundary in y. Behaviour correponds to bcx.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>all points (x,y) must lie within or on the boundaries of g. </dd></dl>

</div>
</div>
<a class="anchor" id="gac8c69c71c0b79097f978c7ec52142299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology3d.html">aTopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. It uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div><div class="line">    std::vector&lt;double&gt; x( g.size()), y(x), z(x);</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;g.Nz(); k++)</div><div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.n(); i++)</div><div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.n(); j++)</div><div class="line">            {</div><div class="line">                x[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] = </div><div class="line">                        g.x0() + (j+0.5)*g.hx()/(double)(g.n());</div><div class="line">                y[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] = </div><div class="line">                        g.y0() + (i+0.5)*g.hy()/(double)(g.n());</div><div class="line">                z[(k*g.Ny()*g.n() + i)*g.Nx()*g.n() + j] = </div><div class="line">                        g.z0() + (k+0.5)*g.hz();</div><div class="line">            }</div><div class="line">    <span class="comment">//typedef cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; Matrix;</span></div><div class="line">    Matrix B = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( x, y, z, g);</div><div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code" href="group__evaluation.html#ga7521f4acb4edaf2d7896d99f97e1ed9d">dg::evaluate</a>( <span class="keyword">function</span>, g); </div><div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div><div class="line">    <a class="code" href="group__blas2.html#gab1885f3913f72b7ea380d58f40c04656">dg::blas2::symv</a>( B, vec, inter);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies exactly on the boundary in x: DIR generates zeroes in the interpolation matrix, NEU and PER interpolate the inner side polynomial. (DIR_NEU and NEU_DIR apply NEU / DIR to the respective left or right boundary ) </td></tr>
    <tr><td class="paramname">bcy</td><td>determines what to do when a point lies exactly on the boundary in y. Behaviour correponds to bcx.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>all points (x, y, z) must lie within or on the boundaries of g </dd></dl>

</div>
</div>
<a class="anchor" id="ga56fafc7fdcadcb06e4dbe1af9d87d8ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid1d.html">Grid1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid1d.html">Grid1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a class="anchor" id="gad7eab0e43c90abb89692de214c90865d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c60df5718d1300c0888f5bdb9614ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology3d.html">aTopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology3d.html">aTopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a class="anchor" id="gac758f716648b670dba9d3120b18eae09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid_x1d.html">GridX1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid_x1d.html">GridX1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9d5e83476e162f0a4ffaa0cafc10888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x2d.html">aTopologyX2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x2d.html">aTopologyX2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="gaa38b730c61dd118823dfd3a6b803287f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x3d.html">aTopologyX3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x3d.html">aTopologyX3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="gadadf1d53a4c123d7d262f025b640e60a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid1d.html">Grid1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid1d.html">Grid1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="gab03bef308c6520f80e2eb3178645b9ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d89432baa99836d5be9daab02a894ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt;int, double, cusp::host_memory&gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology3d.html">aTopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology3d.html">aTopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="gabd2bdf111af9570239b7803ec96bd7c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a> dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology2d.html">aMPITopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology2d.html">aMPITopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga70a66c8e73ce7f018d987a0bc8192d9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a> dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology3d.html">aMPITopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology3d.html">aMPITopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p>Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code" href="group__interpolation.html#ga833bce88eabd2cd111e3912d9331cf95">dg::create::interpolation</a>( g_old, g_new);</div><div class="line"><span class="keywordflow">return</span> A.transpose();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga17548d4a00606d68272b3ccc7e1ce34d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, double, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid_x1d.html">GridX1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid_x1d.html">GridX1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f0bfe9526a6b7005b286ccd4cb0ba3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, double, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x2d.html">aTopologyX2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x2d.html">aTopologyX2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a class="anchor" id="gab93e540e256ef0c4f8f6fdf8343be773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, double, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x3d.html">aTopologyX3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology_x3d.html">aTopologyX3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a class="anchor" id="gaa06712951dc902031061a3ed5b1ab8a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, double, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid1d.html">Grid1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid1d.html">Grid1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga335de04041bed42673e0b00b18ebff73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a> dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology2d.html">aMPITopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology2d.html">aMPITopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a class="anchor" id="gabbcdbaa6ad92679aa4b43f6409788640"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#gabf22476aa30d9a5d7d52a81f97078590">dg::MIHMatrix</a> dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology3d.html">aMPITopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_m_p_i_topology3d.html">aMPITopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga84082a7da5857b096b62de96847b11be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, double, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fc723c30214fc2e20c76dec82cc913e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, double, cusp::host_memory&gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology3d.html">aTopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology3d.html">aTopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#gad9eb1e78b21ee9d5ce6c19c88c247498" title="Create a transformation matrix between two grids. ">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a class="anchor" id="gad9eb1e78b21ee9d5ce6c19c88c247498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, double, cusp::host_memory&gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology3d.html">aTopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology3d.html">aTopology3d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
<a class="anchor" id="ga240b8e3776ec1cbd34d36ea29e1004a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, double, cusp::host_memory&gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_topology2d.html">aTopology2d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
<a class="anchor" id="ga127b484762ffdd319d4ca32763a7b1d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, double, cusp::host_memory&gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid1d.html">Grid1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_grid1d.html">Grid1d</a> &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="./dg_introduction.pdf" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Nov 15 2017 10:37:28 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
