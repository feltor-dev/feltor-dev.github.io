<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: Interpolation and projection</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__interpolation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Interpolation and projection<div class="ingroups"><a class="el" href="group__geo.html">Level 3: Topology and Geometry</a> &raquo; <a class="el" href="group__grid.html">Topological grids and operations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>\( I \) and \( P = I^\dagger\)  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Interpolation and projection:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__interpolation.svg" width="382" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedg_1_1create"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1create.html">dg::create</a></td></tr>
<tr class="memdesc:namespacedg_1_1create"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functions used for matrix creation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga621387b87a7e2cec71d90335fb7895c5"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga621387b87a7e2cec71d90335fb7895c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga621387b87a7e2cec71d90335fb7895c5">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx)</td></tr>
<tr class="memdesc:ga621387b87a7e2cec71d90335fb7895c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#ga621387b87a7e2cec71d90335fb7895c5">More...</a><br /></td></tr>
<tr class="separator:ga621387b87a7e2cec71d90335fb7895c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87f53479753dfeaefe8d077ca1ce701c"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga87f53479753dfeaefe8d077ca1ce701c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx)</td></tr>
<tr class="memdesc:ga87f53479753dfeaefe8d077ca1ce701c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton matrix for integer dividers.  <a href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c">More...</a><br /></td></tr>
<tr class="separator:ga87f53479753dfeaefe8d077ca1ce701c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785b43476bffe07f9d8205c4a338e5bd"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga785b43476bffe07f9d8205c4a338e5bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga785b43476bffe07f9d8205c4a338e5bd">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx, unsigned multiplyNy)</td></tr>
<tr class="memdesc:ga785b43476bffe07f9d8205c4a338e5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#ga785b43476bffe07f9d8205c4a338e5bd">More...</a><br /></td></tr>
<tr class="separator:ga785b43476bffe07f9d8205c4a338e5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f97dac91462d3cb532a995b09618af6"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga7f97dac91462d3cb532a995b09618af6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga7f97dac91462d3cb532a995b09618af6">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx, unsigned divideNy)</td></tr>
<tr class="memdesc:ga7f97dac91462d3cb532a995b09618af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton matrix for integer dividers.  <a href="group__interpolation.html#ga7f97dac91462d3cb532a995b09618af6">More...</a><br /></td></tr>
<tr class="separator:ga7f97dac91462d3cb532a995b09618af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa02e4a2695590e7bcabe826ef6f8a8"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga7aa02e4a2695590e7bcabe826ef6f8a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga7aa02e4a2695590e7bcabe826ef6f8a8">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx, unsigned multiplyNy)</td></tr>
<tr class="memdesc:ga7aa02e4a2695590e7bcabe826ef6f8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#ga7aa02e4a2695590e7bcabe826ef6f8a8">More...</a><br /></td></tr>
<tr class="separator:ga7aa02e4a2695590e7bcabe826ef6f8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb29f3360826c45d07c59513a9bddac6"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gacb29f3360826c45d07c59513a9bddac6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gacb29f3360826c45d07c59513a9bddac6">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx, unsigned divideNy)</td></tr>
<tr class="memdesc:gacb29f3360826c45d07c59513a9bddac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton matrix for integer dividers.  <a href="group__interpolation.html#gacb29f3360826c45d07c59513a9bddac6">More...</a><br /></td></tr>
<tr class="separator:gacb29f3360826c45d07c59513a9bddac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7926270db9b02e44bc3645d68b5ec9e1"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga7926270db9b02e44bc3645d68b5ec9e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga7926270db9b02e44bc3645d68b5ec9e1">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx, unsigned multiplyNy)</td></tr>
<tr class="memdesc:ga7926270db9b02e44bc3645d68b5ec9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#ga7926270db9b02e44bc3645d68b5ec9e1">More...</a><br /></td></tr>
<tr class="separator:ga7926270db9b02e44bc3645d68b5ec9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f3ef89ce146edd954349ace5779131"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga98f3ef89ce146edd954349ace5779131"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga98f3ef89ce146edd954349ace5779131">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx, unsigned divideNy)</td></tr>
<tr class="memdesc:ga98f3ef89ce146edd954349ace5779131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton matrix for integer dividers.  <a href="group__interpolation.html#ga98f3ef89ce146edd954349ace5779131">More...</a><br /></td></tr>
<tr class="separator:ga98f3ef89ce146edd954349ace5779131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf449bb543688950ec22ba67f462305"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga5bf449bb543688950ec22ba67f462305"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga5bf449bb543688950ec22ba67f462305">dg::create::fast_interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;t, unsigned multiplyn, unsigned multiplyNx, unsigned multiplyNy)</td></tr>
<tr class="memdesc:ga5bf449bb543688950ec22ba67f462305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix for integer multipliers.  <a href="group__interpolation.html#ga5bf449bb543688950ec22ba67f462305">More...</a><br /></td></tr>
<tr class="separator:ga5bf449bb543688950ec22ba67f462305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7543b99295dc07d745e2c1306ae6b2f"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad7543b99295dc07d745e2c1306ae6b2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad7543b99295dc07d745e2c1306ae6b2f">dg::create::fast_projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;t, unsigned dividen, unsigned divideNx, unsigned divideNy)</td></tr>
<tr class="memdesc:gad7543b99295dc07d745e2c1306ae6b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create projecton matrix for integer dividers.  <a href="group__interpolation.html#gad7543b99295dc07d745e2c1306ae6b2f">More...</a><br /></td></tr>
<tr class="separator:gad7543b99295dc07d745e2c1306ae6b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555f0315380f4e488298b970fe99bb43"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga555f0315380f4e488298b970fe99bb43"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga555f0315380f4e488298b970fe99bb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">More...</a><br /></td></tr>
<tr class="separator:ga555f0315380f4e488298b970fe99bb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabccfc4cf8551380841951e9e3d4ea6eb"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gabccfc4cf8551380841951e9e3d4ea6eb"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gabccfc4cf8551380841951e9e3d4ea6eb">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:gabccfc4cf8551380841951e9e3d4ea6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gabccfc4cf8551380841951e9e3d4ea6eb">More...</a><br /></td></tr>
<tr class="separator:gabccfc4cf8551380841951e9e3d4ea6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32a8cf8b0401350e0436d695b37b967"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaa32a8cf8b0401350e0436d695b37b967"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaa32a8cf8b0401350e0436d695b37b967">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const thrust::host_vector&lt; real_type &gt; &amp;z, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:gaa32a8cf8b0401350e0436d695b37b967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#gaa32a8cf8b0401350e0436d695b37b967">More...</a><br /></td></tr>
<tr class="separator:gaa32a8cf8b0401350e0436d695b37b967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe66d320d0965e44cf7b7b68d95db7a9"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gafe66d320d0965e44cf7b7b68d95db7a9"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gafe66d320d0965e44cf7b7b68d95db7a9">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gafe66d320d0965e44cf7b7b68d95db7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gafe66d320d0965e44cf7b7b68d95db7a9">More...</a><br /></td></tr>
<tr class="separator:gafe66d320d0965e44cf7b7b68d95db7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6059cfabf62ce2523321f816fb59ecb"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gab6059cfabf62ce2523321f816fb59ecb"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gab6059cfabf62ce2523321f816fb59ecb">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gab6059cfabf62ce2523321f816fb59ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gab6059cfabf62ce2523321f816fb59ecb">More...</a><br /></td></tr>
<tr class="separator:gab6059cfabf62ce2523321f816fb59ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga255cdb85967dee679b05899d86d12785"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga255cdb85967dee679b05899d86d12785"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga255cdb85967dee679b05899d86d12785">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga255cdb85967dee679b05899d86d12785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga255cdb85967dee679b05899d86d12785">More...</a><br /></td></tr>
<tr class="separator:ga255cdb85967dee679b05899d86d12785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf634652de6df95398e91477aaed0927"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaaf634652de6df95398e91477aaed0927"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaaf634652de6df95398e91477aaed0927">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gaaf634652de6df95398e91477aaed0927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gaaf634652de6df95398e91477aaed0927">More...</a><br /></td></tr>
<tr class="separator:gaaf634652de6df95398e91477aaed0927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1467be84fa682c8b300cd39db0492d9"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad1467be84fa682c8b300cd39db0492d9"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad1467be84fa682c8b300cd39db0492d9">dg::interpolate</a> (<a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a> sp, const thrust::host_vector&lt; real_type &gt; &amp;v, real_type x, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gad1467be84fa682c8b300cd39db0492d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector on a single point on a 1d Grid.  <a href="group__interpolation.html#gad1467be84fa682c8b300cd39db0492d9">More...</a><br /></td></tr>
<tr class="separator:gad1467be84fa682c8b300cd39db0492d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9fc6abad143444993021781bbed9b48"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaa9fc6abad143444993021781bbed9b48"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaa9fc6abad143444993021781bbed9b48">dg::interpolate</a> (<a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a> sp, const thrust::host_vector&lt; real_type &gt; &amp;v, real_type x, real_type y, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gaa9fc6abad143444993021781bbed9b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector on a single point on a 2d Grid.  <a href="group__interpolation.html#gaa9fc6abad143444993021781bbed9b48">More...</a><br /></td></tr>
<tr class="separator:gaa9fc6abad143444993021781bbed9b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc621634c9540012006c75e4061d0be"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga9bc621634c9540012006c75e4061d0be"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga9bc621634c9540012006c75e4061d0be">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g)</td></tr>
<tr class="memdesc:ga9bc621634c9540012006c75e4061d0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga9bc621634c9540012006c75e4061d0be">More...</a><br /></td></tr>
<tr class="separator:ga9bc621634c9540012006c75e4061d0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a625727a3335b7d0c7a7104a147cd8"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga00a625727a3335b7d0c7a7104a147cd8"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga00a625727a3335b7d0c7a7104a147cd8">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga00a625727a3335b7d0c7a7104a147cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga00a625727a3335b7d0c7a7104a147cd8">More...</a><br /></td></tr>
<tr class="separator:ga00a625727a3335b7d0c7a7104a147cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d44cf23c5474123a4c1f7d381166341"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga6d44cf23c5474123a4c1f7d381166341"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga6d44cf23c5474123a4c1f7d381166341">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const thrust::host_vector&lt; real_type &gt; &amp;z, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga6d44cf23c5474123a4c1f7d381166341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <a href="group__interpolation.html#ga6d44cf23c5474123a4c1f7d381166341">More...</a><br /></td></tr>
<tr class="separator:ga6d44cf23c5474123a4c1f7d381166341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5675778c919151412ef727e7739fd7e3"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga5675778c919151412ef727e7739fd7e3"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga5675778c919151412ef727e7739fd7e3">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga5675778c919151412ef727e7739fd7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga5675778c919151412ef727e7739fd7e3">More...</a><br /></td></tr>
<tr class="separator:ga5675778c919151412ef727e7739fd7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e75013511a6bf3864f6d68d782294d5"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga5e75013511a6bf3864f6d68d782294d5"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga5e75013511a6bf3864f6d68d782294d5">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga5e75013511a6bf3864f6d68d782294d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga5e75013511a6bf3864f6d68d782294d5">More...</a><br /></td></tr>
<tr class="separator:ga5e75013511a6bf3864f6d68d782294d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15dd892625959c7bcd49b24b90d263af"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga15dd892625959c7bcd49b24b90d263af"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga15dd892625959c7bcd49b24b90d263af">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga15dd892625959c7bcd49b24b90d263af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga15dd892625959c7bcd49b24b90d263af">More...</a><br /></td></tr>
<tr class="separator:ga15dd892625959c7bcd49b24b90d263af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga3f3b02e7ec191c8fcf1fc258599617f7">dg::interpolate</a> (<a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a> sp, const thrust::host_vector&lt; real_type &gt; &amp;v, real_type x, real_type y, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector on a single point on a 2d Grid.  <a href="group__interpolation.html#ga3f3b02e7ec191c8fcf1fc258599617f7">More...</a><br /></td></tr>
<tr class="separator:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31346299065b7b13d2ff3ff801d7fc9d"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga31346299065b7b13d2ff3ff801d7fc9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga31346299065b7b13d2ff3ff801d7fc9d">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga31346299065b7b13d2ff3ff801d7fc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga31346299065b7b13d2ff3ff801d7fc9d">More...</a><br /></td></tr>
<tr class="separator:ga31346299065b7b13d2ff3ff801d7fc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29fd1af674975ffac83505d1a75d9295"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga29fd1af674975ffac83505d1a75d9295"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga29fd1af674975ffac83505d1a75d9295">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga29fd1af674975ffac83505d1a75d9295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#ga29fd1af674975ffac83505d1a75d9295">More...</a><br /></td></tr>
<tr class="separator:ga29fd1af674975ffac83505d1a75d9295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2b8878b6c870ca9868827e6cb196b6"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gafd2b8878b6c870ca9868827e6cb196b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gafd2b8878b6c870ca9868827e6cb196b6">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gafd2b8878b6c870ca9868827e6cb196b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <a href="group__interpolation.html#gafd2b8878b6c870ca9868827e6cb196b6">More...</a><br /></td></tr>
<tr class="separator:gafd2b8878b6c870ca9868827e6cb196b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7f2cd44a012d7898ca27b11f4962bd"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaec7f2cd44a012d7898ca27b11f4962bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaec7f2cd44a012d7898ca27b11f4962bd">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gaec7f2cd44a012d7898ca27b11f4962bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gaec7f2cd44a012d7898ca27b11f4962bd">More...</a><br /></td></tr>
<tr class="separator:gaec7f2cd44a012d7898ca27b11f4962bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a0c4a258ad384e1c174a068e06537d"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gae1a0c4a258ad384e1c174a068e06537d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gae1a0c4a258ad384e1c174a068e06537d">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gae1a0c4a258ad384e1c174a068e06537d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#gae1a0c4a258ad384e1c174a068e06537d">More...</a><br /></td></tr>
<tr class="separator:gae1a0c4a258ad384e1c174a068e06537d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad425185a1a42e48ee2785c1a1bf2629"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaad425185a1a42e48ee2785c1a1bf2629"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gaad425185a1a42e48ee2785c1a1bf2629">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gaad425185a1a42e48ee2785c1a1bf2629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gaad425185a1a42e48ee2785c1a1bf2629">More...</a><br /></td></tr>
<tr class="separator:gaad425185a1a42e48ee2785c1a1bf2629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bb2ee2164fcf188a5825f83877ce5e6"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga6bb2ee2164fcf188a5825f83877ce5e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga6bb2ee2164fcf188a5825f83877ce5e6">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga6bb2ee2164fcf188a5825f83877ce5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga6bb2ee2164fcf188a5825f83877ce5e6">More...</a><br /></td></tr>
<tr class="separator:ga6bb2ee2164fcf188a5825f83877ce5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242fe992f5f60ebd05b9d60dd800e725"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga242fe992f5f60ebd05b9d60dd800e725"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga242fe992f5f60ebd05b9d60dd800e725">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga242fe992f5f60ebd05b9d60dd800e725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an MPI row distributed interpolation 2d matrix.  <a href="group__interpolation.html#ga242fe992f5f60ebd05b9d60dd800e725">More...</a><br /></td></tr>
<tr class="separator:ga242fe992f5f60ebd05b9d60dd800e725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc58c92d669aea984f9f5a6b5129190e"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gabc58c92d669aea984f9f5a6b5129190e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gabc58c92d669aea984f9f5a6b5129190e">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;y, const thrust::host_vector&lt; real_type &gt; &amp;z, const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>, std::string method=&quot;linear&quot;)</td></tr>
<tr class="memdesc:gabc58c92d669aea984f9f5a6b5129190e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an MPI row distributed interpolation 3d matrix.  <a href="group__interpolation.html#gabc58c92d669aea984f9f5a6b5129190e">More...</a><br /></td></tr>
<tr class="separator:gabc58c92d669aea984f9f5a6b5129190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga960c598e8d895bc725aca898addf3ad4"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga960c598e8d895bc725aca898addf3ad4"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga960c598e8d895bc725aca898addf3ad4">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga960c598e8d895bc725aca898addf3ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga960c598e8d895bc725aca898addf3ad4">More...</a><br /></td></tr>
<tr class="separator:ga960c598e8d895bc725aca898addf3ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47227ef2f447fcd96c64119676b370a8"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga47227ef2f447fcd96c64119676b370a8"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga47227ef2f447fcd96c64119676b370a8">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga47227ef2f447fcd96c64119676b370a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga47227ef2f447fcd96c64119676b370a8">More...</a><br /></td></tr>
<tr class="separator:ga47227ef2f447fcd96c64119676b370a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cc266e144f7c72cd40809727ee970fe"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga8cc266e144f7c72cd40809727ee970fe"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga8cc266e144f7c72cd40809727ee970fe">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga8cc266e144f7c72cd40809727ee970fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga8cc266e144f7c72cd40809727ee970fe">More...</a><br /></td></tr>
<tr class="separator:ga8cc266e144f7c72cd40809727ee970fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c6f55f5cdacb323a66a4ef99c4aa849"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga2c6f55f5cdacb323a66a4ef99c4aa849"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga2c6f55f5cdacb323a66a4ef99c4aa849">dg::create::diagonal</a> (const thrust::host_vector&lt; real_type &gt; &amp;diagonal)</td></tr>
<tr class="memdesc:ga2c6f55f5cdacb323a66a4ef99c4aa849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a diagonal matrix.  <a href="group__interpolation.html#ga2c6f55f5cdacb323a66a4ef99c4aa849">More...</a><br /></td></tr>
<tr class="separator:ga2c6f55f5cdacb323a66a4ef99c4aa849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1acd5229e37e86c014468f8a7029abf"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gae1acd5229e37e86c014468f8a7029abf"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gae1acd5229e37e86c014468f8a7029abf">dg::create::projection</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gae1acd5229e37e86c014468f8a7029abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gae1acd5229e37e86c014468f8a7029abf">More...</a><br /></td></tr>
<tr class="separator:gae1acd5229e37e86c014468f8a7029abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20d227f6c8cb2547e757852413dbe7b"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad20d227f6c8cb2547e757852413dbe7b"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad20d227f6c8cb2547e757852413dbe7b">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gad20d227f6c8cb2547e757852413dbe7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gad20d227f6c8cb2547e757852413dbe7b">More...</a><br /></td></tr>
<tr class="separator:gad20d227f6c8cb2547e757852413dbe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad77a4a2cbeabce81c6a7bfdbfd5871cc"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gad77a4a2cbeabce81c6a7bfdbfd5871cc"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gad77a4a2cbeabce81c6a7bfdbfd5871cc">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gad77a4a2cbeabce81c6a7bfdbfd5871cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gad77a4a2cbeabce81c6a7bfdbfd5871cc">More...</a><br /></td></tr>
<tr class="separator:gad77a4a2cbeabce81c6a7bfdbfd5871cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b8bdd9c1752a8d88a683f816f182f3d"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga6b8bdd9c1752a8d88a683f816f182f3d"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d">dg::create::transformation</a> (const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga6b8bdd9c1752a8d88a683f816f182f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d">More...</a><br /></td></tr>
<tr class="separator:ga6b8bdd9c1752a8d88a683f816f182f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b6355e9c86c83ee4555781daa429cf"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gab4b6355e9c86c83ee4555781daa429cf"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gab4b6355e9c86c83ee4555781daa429cf">dg::create::transformation</a> (const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gab4b6355e9c86c83ee4555781daa429cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#gab4b6355e9c86c83ee4555781daa429cf">More...</a><br /></td></tr>
<tr class="separator:gab4b6355e9c86c83ee4555781daa429cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ae54a688a91889650a636f7245b6cd"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga69ae54a688a91889650a636f7245b6cd"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga69ae54a688a91889650a636f7245b6cd">dg::create::transformation</a> (const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga69ae54a688a91889650a636f7245b6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <a href="group__interpolation.html#ga69ae54a688a91889650a636f7245b6cd">More...</a><br /></td></tr>
<tr class="separator:ga69ae54a688a91889650a636f7245b6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd81655e5b3de445bfc3fee6caa9b95"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga8cd81655e5b3de445bfc3fee6caa9b95"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga8cd81655e5b3de445bfc3fee6caa9b95">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga8cd81655e5b3de445bfc3fee6caa9b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga8cd81655e5b3de445bfc3fee6caa9b95">More...</a><br /></td></tr>
<tr class="separator:ga8cd81655e5b3de445bfc3fee6caa9b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095fd7d647e30d3cd9abc9b3fbe0cca1"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga095fd7d647e30d3cd9abc9b3fbe0cca1"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga095fd7d647e30d3cd9abc9b3fbe0cca1">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga095fd7d647e30d3cd9abc9b3fbe0cca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga095fd7d647e30d3cd9abc9b3fbe0cca1">More...</a><br /></td></tr>
<tr class="separator:ga095fd7d647e30d3cd9abc9b3fbe0cca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70308c71453e2014553163b5c097ce12"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga70308c71453e2014553163b5c097ce12"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga70308c71453e2014553163b5c097ce12">dg::create::interpolationT</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga70308c71453e2014553163b5c097ce12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the transpose of the interpolation matrix from new to old.  <a href="group__interpolation.html#ga70308c71453e2014553163b5c097ce12">More...</a><br /></td></tr>
<tr class="separator:ga70308c71453e2014553163b5c097ce12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51d004fa4abfa57f13502617ba184c6"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gae51d004fa4abfa57f13502617ba184c6"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gae51d004fa4abfa57f13502617ba184c6">dg::create::projection</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gae51d004fa4abfa57f13502617ba184c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gae51d004fa4abfa57f13502617ba184c6">More...</a><br /></td></tr>
<tr class="separator:gae51d004fa4abfa57f13502617ba184c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e117be1d538fffb647d858e1325cdf6"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga5e117be1d538fffb647d858e1325cdf6"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#ga5e117be1d538fffb647d858e1325cdf6">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga5e117be1d538fffb647d858e1325cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#ga5e117be1d538fffb647d858e1325cdf6">More...</a><br /></td></tr>
<tr class="separator:ga5e117be1d538fffb647d858e1325cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb82763a4a75e035022ae1d0ee6fe55c"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gafb82763a4a75e035022ae1d0ee6fe55c"><td class="memTemplItemLeft" align="right" valign="top">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interpolation.html#gafb82763a4a75e035022ae1d0ee6fe55c">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gafb82763a4a75e035022ae1d0ee6fe55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <a href="group__interpolation.html#gafb82763a4a75e035022ae1d0ee6fe55c">More...</a><br /></td></tr>
<tr class="separator:gafb82763a4a75e035022ae1d0ee6fe55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >\( I \) and \( P = I^\dagger\) </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2c6f55f5cdacb323a66a4ef99c4aa849" name="ga2c6f55f5cdacb323a66a4ef99c4aa849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c6f55f5cdacb323a66a4ef99c4aa849">&#9670;&nbsp;</a></span>diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::diagonal </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a diagonal matrix. </p>
<p >This matrix is given by \( D_{ij} = d_i \delta_{ij}\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagonal</td><td>The diagonal elements d_i </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>diagonal matrix </dd></dl>

</div>
</div>
<a id="ga7926270db9b02e44bc3645d68b5ec9e1" name="ga7926270db9b02e44bc3645d68b5ec9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7926270db9b02e44bc3645d68b5ec9e1">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p >When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
    <tr><td class="paramname">multiplyNy</td><td>integer multiplier, the new grid has <code>Ny*multiplyNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5bf449bb543688950ec22ba67f462305" name="ga5bf449bb543688950ec22ba67f462305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bf449bb543688950ec22ba67f462305">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p >When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
    <tr><td class="paramname">multiplyNy</td><td>integer multiplier, the new grid has <code>Ny*multiplyNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga785b43476bffe07f9d8205c4a338e5bd" name="ga785b43476bffe07f9d8205c4a338e5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga785b43476bffe07f9d8205c4a338e5bd">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p >When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
    <tr><td class="paramname">multiplyNy</td><td>integer multiplier, the new grid has <code>Ny*multiplyNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7aa02e4a2695590e7bcabe826ef6f8a8" name="ga7aa02e4a2695590e7bcabe826ef6f8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aa02e4a2695590e7bcabe826ef6f8a8">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p >When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
    <tr><td class="paramname">multiplyNy</td><td>integer multiplier, the new grid has <code>Ny*multiplyNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga621387b87a7e2cec71d90335fb7895c5" name="ga621387b87a7e2cec71d90335fb7895c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga621387b87a7e2cec71d90335fb7895c5">&#9670;&nbsp;</a></span>fast_interpolation() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplyNx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix for integer multipliers. </p>
<p >When creating an interpolation from a given dg grid to one that has an integer multiple of cells and/or polynomial coefficients, the resulting interpolation matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose interpolation function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43" title="Create interpolation matrix.">dg::create::interpolation</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/coarse) grid </td></tr>
    <tr><td class="paramname">multiplyn</td><td>integer multiplier, the new grid has <code>n*multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">multiplyNx</td><td>integer multiplier, the new grid has <code>Nx*multiplyNx</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98f3ef89ce146edd954349ace5779131" name="ga98f3ef89ce146edd954349ace5779131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98f3ef89ce146edd954349ace5779131">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton matrix for integer dividers. </p>
<p >When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad425185a1a42e48ee2785c1a1bf2629" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#gaec7f2cd44a012d7898ca27b11f4962bd" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
    <tr><td class="paramname">divideNy</td><td>integer multiplier, the new grid has <code>Ny/divideNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad7543b99295dc07d745e2c1306ae6b2f" name="gad7543b99295dc07d745e2c1306ae6b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7543b99295dc07d745e2c1306ae6b2f">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#ga756b7cfbae82f9b5ea00613fb0f58dc1">MHMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga67290cbd3eb84059299270977b69652e">MHVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton matrix for integer dividers. </p>
<p >When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad425185a1a42e48ee2785c1a1bf2629" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#gaec7f2cd44a012d7898ca27b11f4962bd" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
    <tr><td class="paramname">divideNy</td><td>integer multiplier, the new grid has <code>Ny/divideNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f97dac91462d3cb532a995b09618af6" name="ga7f97dac91462d3cb532a995b09618af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f97dac91462d3cb532a995b09618af6">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton matrix for integer dividers. </p>
<p >When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad425185a1a42e48ee2785c1a1bf2629" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#gaec7f2cd44a012d7898ca27b11f4962bd" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
    <tr><td class="paramname">divideNy</td><td>integer multiplier, the new grid has <code>Ny/divideNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb29f3360826c45d07c59513a9bddac6" name="gacb29f3360826c45d07c59513a9bddac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb29f3360826c45d07c59513a9bddac6">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton matrix for integer dividers. </p>
<p >When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad425185a1a42e48ee2785c1a1bf2629" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#gaec7f2cd44a012d7898ca27b11f4962bd" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
    <tr><td class="paramname">divideNy</td><td>integer multiplier, the new grid has <code>Ny/divideNy</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87f53479753dfeaefe8d077ca1ce701c" name="ga87f53479753dfeaefe8d077ca1ce701c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87f53479753dfeaefe8d077ca1ce701c">&#9670;&nbsp;</a></span>fast_projection() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multi_matrix.html">MultiMatrix</a>&lt; <a class="el" href="group__typedefs.html#gae32e68aa84de32e2bd1cc52a7b291328">dg::HMatrix_t</a>&lt; real_type &gt;, <a class="el" href="group__typedefs.html#ga0adc266f31294130dbaa806586409995">dg::HVec_t</a>&lt; real_type &gt; &gt; dg::create::fast_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dividen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divideNx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create projecton matrix for integer dividers. </p>
<p >When creating a projection from a given dg grid to one that has an integer division of cells and/or polynomial coefficients, the resulting projection matrix fits into our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">dg::EllSparseBlockMat</a></code> format, which is much faster to apply than the full sparse matrix format from the general purpose projection function, especially since it requires no communication from neighboring cells </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interpolation.html#gaad425185a1a42e48ee2785c1a1bf2629" title="Create a projection between two grids.">dg::create::projection</a> <a class="el" href="group__interpolation.html#gaec7f2cd44a012d7898ca27b11f4962bd" title="Create the transpose of the interpolation matrix from new to old.">dg::create::interpolationT</a> </dd>
<dd>
For a derivation of the coefficients consult the dg manual <a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>a floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix that when applied to vectors on the old grid produces a vector on the new grid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The existing (old/fine) grid </td></tr>
    <tr><td class="paramname">dividen</td><td>integer divisor, the new grid has <code>n/multiplyn</code> polynomial coefficients </td></tr>
    <tr><td class="paramname">divideNx</td><td>integer divisor, the new grid has <code>Nx/multiplyNx</code> points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1467be84fa682c8b300cd39db0492d9" name="gad1467be84fa682c8b300cd39db0492d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1467be84fa682c8b300cd39db0492d9">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a>&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector on a single point on a 1d Grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>Indicate whether the elements of the vector v are in xspace (nodal values) or lspace (modal values) (choose <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> if you don't know what is going on here, It is faster to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> so consider transforming v using <a class="el" href="group__misc.html#gad09541da41129a4ccdb3623deaa5f364" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> if you do it very many times) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate </td></tr>
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>

</div>
</div>
<a id="gaa9fc6abad143444993021781bbed9b48" name="gaa9fc6abad143444993021781bbed9b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9fc6abad143444993021781bbed9b48">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a>&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector on a single point on a 2d Grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>Indicate whether the elements of the vector v are in xspace (nodal values) or lspace (modal values) (choose <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> if you don't know what is going on here, It is faster to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> so consider transforming v using <a class="el" href="group__misc.html#gad09541da41129a4ccdb3623deaa5f364" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> if you do it very many times) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a>, or <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> s.a. <a class="el" href="group__misc.html#gad09541da41129a4ccdb3623deaa5f364" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> </td></tr>
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>

</div>
</div>
<a id="ga3f3b02e7ec191c8fcf1fc258599617f7" name="ga3f3b02e7ec191c8fcf1fc258599617f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3b02e7ec191c8fcf1fc258599617f7">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a>&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector on a single point on a 2d Grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>Indicate whether the elements of the vector v are in xspace or lspace (choose <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> if you don't know what is going on here, It is faster to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> so consider transforming v using <a class="el" href="group__misc.html#gad09541da41129a4ccdb3623deaa5f364" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> if you do it very many times) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a>, or <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> s.a. <a class="el" href="group__misc.html#gad09541da41129a4ccdb3623deaa5f364" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> </td></tr>
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>g.contains(x,y)</code> must return true </dd></dl>

</div>
</div>
<a id="ga31346299065b7b13d2ff3ff801d7fc9d" name="ga31346299065b7b13d2ff3ff801d7fc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31346299065b7b13d2ff3ff801d7fc9d">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga621387b87a7e2cec71d90335fb7895c5" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The 1d version does <b>not</b> remove explicit zeros from the interpolation matrix, but the 2d and 3d versions do </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="gafd2b8878b6c870ca9868827e6cb196b6" name="gafd2b8878b6c870ca9868827e6cb196b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd2b8878b6c870ca9868827e6cb196b6">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga621387b87a7e2cec71d90335fb7895c5" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The 1d version does <b>not</b> remove explicit zeros from the interpolation matrix, but the 2d and 3d versions do </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga29fd1af674975ffac83505d1a75d9295" name="ga29fd1af674975ffac83505d1a75d9295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29fd1af674975ffac83505d1a75d9295">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga621387b87a7e2cec71d90335fb7895c5" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The 1d version does <b>not</b> remove explicit zeros from the interpolation matrix, but the 2d and 3d versions do </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="gab6059cfabf62ce2523321f816fb59ecb" name="gab6059cfabf62ce2523321f816fb59ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6059cfabf62ce2523321f816fb59ecb">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga621387b87a7e2cec71d90335fb7895c5" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The 1d version does <b>not</b> remove explicit zeros from the interpolation matrix, but the 2d and 3d versions do </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="gaaf634652de6df95398e91477aaed0927" name="gaaf634652de6df95398e91477aaed0927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf634652de6df95398e91477aaed0927">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga621387b87a7e2cec71d90335fb7895c5" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The 1d version does <b>not</b> remove explicit zeros from the interpolation matrix, but the 2d and 3d versions do </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga255cdb85967dee679b05899d86d12785" name="ga255cdb85967dee679b05899d86d12785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga255cdb85967dee679b05899d86d12785">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga621387b87a7e2cec71d90335fb7895c5" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The 1d version does <b>not</b> remove explicit zeros from the interpolation matrix, but the 2d and 3d versions do </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga5e75013511a6bf3864f6d68d782294d5" name="ga5e75013511a6bf3864f6d68d782294d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e75013511a6bf3864f6d68d782294d5">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga15dd892625959c7bcd49b24b90d263af" name="ga15dd892625959c7bcd49b24b90d263af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15dd892625959c7bcd49b24b90d263af">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gafe66d320d0965e44cf7b7b68d95db7a9" name="gafe66d320d0965e44cf7b7b68d95db7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe66d320d0965e44cf7b7b68d95db7a9">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga621387b87a7e2cec71d90335fb7895c5" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The 1d version does <b>not</b> remove explicit zeros from the interpolation matrix, but the 2d and 3d versions do </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
When interpolating a 2d grid to a 3d grid the third coordinate is simply ignored, i.e. the 2d vector will be trivially copied Nz times into the 3d vector </dd>
<dd>
also check the transformation matrix, which is the more general solution </dd></dl>

</div>
</div>
<a id="ga5675778c919151412ef727e7739fd7e3" name="ga5675778c919151412ef727e7739fd7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5675778c919151412ef727e7739fd7e3">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p >This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga555f0315380f4e488298b970fe99bb43" name="ga555f0315380f4e488298b970fe99bb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555f0315380f4e488298b970fe99bb43">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;dg&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p >The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.</td></tr>
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>does <b>not</b> remove explicit zeros in the interpolation matrix </dd></dl>

</div>
</div>
<a id="ga9bc621634c9540012006c75e4061d0be" name="ga9bc621634c9540012006c75e4061d0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bc621634c9540012006c75e4061d0be">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p >The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="ga242fe992f5f60ebd05b9d60dd800e725" name="ga242fe992f5f60ebd05b9d60dd800e725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242fe992f5f60ebd05b9d60dd800e725">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;dg&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an MPI row distributed interpolation 2d matrix. </p>
<p >The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div>
<div class="line">    thrust::host_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x);</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.ny(); i++)</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.nx(); j++)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//intentionally set values outside the grid domain</span></div>
<div class="line">            <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[i*g.Nx()*g.nx() + j] =</div>
<div class="line">                    g.x0() + g.lx() + (j+0.5)*g.hx()/(double)(g.nx());</div>
<div class="line">            <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[i*g.Nx()*g.ny() + j] =</div>
<div class="line">                    g.y0() + 2*g.ly() + (i+0.5)*g.hy()/(double)(g.ny());</div>
<div class="line">        }</div>
<div class="line">    <span class="comment">//use DIR because the coo.2d is zero on the right boundary</span></div>
<div class="line">    Matrix B = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( x, y, g, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <span class="stringliteral">&quot;dg&quot;</span>);</div>
<div class="line">    <span class="comment">//values outside the grid are mirrored back in</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code hl_function" href="group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">dg::evaluate</a>( function, g);</div>
<div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">    <a class="code hl_function" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
<div class="ttc" id="agroup__blas2_html_gac3840941bd2bb1d64c6ca3fef1f1b960"><div class="ttname"><a href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a></div><div class="ttdeci">void symv(MatrixType &amp;&amp;M, const ContainerType1 &amp;x, ContainerType2 &amp;y)</div><div class="ttdef"><b>Definition:</b> blas2.h:264</div></div>
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6"><div class="ttname"><a href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a></div><div class="ttdeci">@ DIR</div><div class="ttdoc">homogeneous dirichlet boundaries</div><div class="ttdef"><b>Definition:</b> enums.h:17</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">dg::coo2d::y</a></div><div class="ttdeci">@ y</div><div class="ttdoc">y direction</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">dg::coo2d::x</a></div><div class="ttdeci">@ x</div><div class="ttdoc">x direction</div></div>
<div class="ttc" id="agroup__evaluation_html_gac802d2b4de66df9ce2282e378461ce28"><div class="ttname"><a href="group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">dg::evaluate</a></div><div class="ttdeci">thrust::host_vector&lt; real_type &gt; evaluate(UnaryOp f, const RealGrid1d&lt; real_type &gt; &amp;g)</div><div class="ttdoc">Evaluate a 1d function on grid coordinates.</div><div class="ttdef"><b>Definition:</b> evaluation.h:67</div></div>
<div class="ttc" id="agroup__interpolation_html_ga555f0315380f4e488298b970fe99bb43"><div class="ttname"><a href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a></div><div class="ttdeci">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; interpolation(const thrust::host_vector&lt; real_type &gt; &amp;x, const RealGrid1d&lt; real_type &gt; &amp;g, dg::bc bcx=dg::NEU, std::string method=&quot;dg&quot;)</div><div class="ttdoc">Create interpolation matrix.</div><div class="ttdef"><b>Definition:</b> interpolation.h:275</div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros in the interpolation matrix </dd></dl>

</div>
</div>
<a id="gabccfc4cf8551380841951e9e3d4ea6eb" name="gabccfc4cf8551380841951e9e3d4ea6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabccfc4cf8551380841951e9e3d4ea6eb">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;dg&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p >The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div>
<div class="line">    thrust::host_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x);</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.ny(); i++)</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.nx(); j++)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//intentionally set values outside the grid domain</span></div>
<div class="line">            <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[i*g.Nx()*g.nx() + j] =</div>
<div class="line">                    g.x0() + g.lx() + (j+0.5)*g.hx()/(double)(g.nx());</div>
<div class="line">            <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[i*g.Nx()*g.ny() + j] =</div>
<div class="line">                    g.y0() + 2*g.ly() + (i+0.5)*g.hy()/(double)(g.ny());</div>
<div class="line">        }</div>
<div class="line">    <span class="comment">//use DIR because the coo.2d is zero on the right boundary</span></div>
<div class="line">    Matrix B = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( x, y, g, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <span class="stringliteral">&quot;dg&quot;</span>);</div>
<div class="line">    <span class="comment">//values outside the grid are mirrored back in</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code hl_function" href="group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">dg::evaluate</a>( function, g);</div>
<div class="line">    thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">    <a class="code hl_function" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros in the interpolation matrix </dd></dl>

</div>
</div>
<a id="ga00a625727a3335b7d0c7a7104a147cd8" name="ga00a625727a3335b7d0c7a7104a147cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00a625727a3335b7d0c7a7104a147cd8">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>globalbcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p >The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>NEU for common interpolation. DIR for zeros at Box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="gabc58c92d669aea984f9f5a6b5129190e" name="gabc58c92d669aea984f9f5a6b5129190e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc58c92d669aea984f9f5a6b5129190e">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an MPI row distributed interpolation 3d matrix. </p>
<p >The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div>
<div class="line">    thrust::host_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x), <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>(x);</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;g.nz()*g.Nz(); k++)</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.ny(); i++)</div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.nx(); j++)</div>
<div class="line">            {</div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                        g.x0() + (j+0.5)*g.hx()/(double)(g.nx());</div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                        g.y0() + (i+0.5)*g.hy()/(double)(g.ny());</div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                        g.z0() + (k+0.5)*g.hz()/(double)(g.nz());</div>
<div class="line">            }</div>
<div class="line">    std::vector&lt;std::string&gt; methods = {<span class="stringliteral">&quot;nearest&quot;</span>, <span class="stringliteral">&quot;linear&quot;</span>, <span class="stringliteral">&quot;dg&quot;</span>, <span class="stringliteral">&quot;cubic&quot;</span>};</div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keyword">auto</span> method : methods)</div>
<div class="line">    {</div>
<div class="line">        Matrix B = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( x, y, z, g, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>,</div>
<div class="line">                method);</div>
<div class="line">        <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code hl_function" href="group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">dg::evaluate</a>( function, g);</div>
<div class="line">        thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">        <a class="code hl_function" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
<div class="ttc" id="agroup__creation_html_gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7"><div class="ttname"><a href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">dg::coo3d::z</a></div><div class="ttdeci">@ z</div><div class="ttdoc">z direction</div></div>
<div class="ttc" id="agroup__creation_html_gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3"><div class="ttname"><a href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></div><div class="ttdeci">@ PER</div><div class="ttdoc">periodic boundaries</div><div class="ttdef"><b>Definition:</b> enums.h:16</div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points (<code>z.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">bcz</td><td>analogous to <code>bcx</code>, applies to z direction</td></tr>
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros from the interpolation matrix </dd>
<dd>
all points (x, y, z) must lie within or on the boundaries of g </dd></dl>

</div>
</div>
<a id="gaa32a8cf8b0401350e0436d695b37b967" name="gaa32a8cf8b0401350e0436d695b37b967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa32a8cf8b0401350e0436d695b37b967">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcx</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcy</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>bcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;dg&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p >The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">    <span class="comment">//create equidistant values</span></div>
<div class="line">    thrust::host_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x), <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>(x);</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;g.nz()*g.Nz(); k++)</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.ny(); i++)</div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.nx(); j++)</div>
<div class="line">            {</div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                        g.x0() + (j+0.5)*g.hx()/(double)(g.nx());</div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                        g.y0() + (i+0.5)*g.hy()/(double)(g.ny());</div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                        g.z0() + (k+0.5)*g.hz()/(double)(g.nz());</div>
<div class="line">            }</div>
<div class="line">    std::vector&lt;std::string&gt; methods = {<span class="stringliteral">&quot;nearest&quot;</span>, <span class="stringliteral">&quot;linear&quot;</span>, <span class="stringliteral">&quot;dg&quot;</span>, <span class="stringliteral">&quot;cubic&quot;</span>};</div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keyword">auto</span> method : methods)</div>
<div class="line">    {</div>
<div class="line">        Matrix B = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( x, y, z, g, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>,</div>
<div class="line">                method);</div>
<div class="line">        <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code hl_function" href="group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">dg::evaluate</a>( function, g);</div>
<div class="line">        thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">        <a class="code hl_function" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points (<code>z.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">bcz</td><td>analogous to <code>bcx</code>, applies to z direction</td></tr>
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros from the interpolation matrix </dd>
<dd>
all points (x, y, z) must lie within or on the boundaries of g </dd></dl>

</div>
</div>
<a id="ga6d44cf23c5474123a4c1f7d381166341" name="ga6d44cf23c5474123a4c1f7d381166341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d44cf23c5474123a4c1f7d381166341">&#9670;&nbsp;</a></span>interpolation() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>&#160;</td>
          <td class="paramname"><em>globalbcz</em> = <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p >The matrix, when applied to a vector, interpolates its values to the given coordinates. In z-direction only a nearest neighbor interpolation is used </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>determines what to do if values lie exactly on the boundary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The values of x, y and z must lie within the boundaries of g </dd></dl>

</div>
</div>
<a id="gaec7f2cd44a012d7898ca27b11f4962bd" name="gaec7f2cd44a012d7898ca27b11f4962bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec7f2cd44a012d7898ca27b11f4962bd">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p >Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gae1a0c4a258ad384e1c174a068e06537d" name="gae1a0c4a258ad384e1c174a068e06537d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1a0c4a258ad384e1c174a068e06537d">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p >Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga47227ef2f447fcd96c64119676b370a8" name="ga47227ef2f447fcd96c64119676b370a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47227ef2f447fcd96c64119676b370a8">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p >Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga8cc266e144f7c72cd40809727ee970fe" name="ga8cc266e144f7c72cd40809727ee970fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cc266e144f7c72cd40809727ee970fe">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p >Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga095fd7d647e30d3cd9abc9b3fbe0cca1" name="ga095fd7d647e30d3cd9abc9b3fbe0cca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga095fd7d647e30d3cd9abc9b3fbe0cca1">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p >Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga70308c71453e2014553163b5c097ce12" name="ga70308c71453e2014553163b5c097ce12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70308c71453e2014553163b5c097ce12">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p >Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga960c598e8d895bc725aca898addf3ad4" name="ga960c598e8d895bc725aca898addf3ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga960c598e8d895bc725aca898addf3ad4">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p >Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga8cd81655e5b3de445bfc3fee6caa9b95" name="ga8cd81655e5b3de445bfc3fee6caa9b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cd81655e5b3de445bfc3fee6caa9b95">&#9670;&nbsp;</a></span>interpolationT() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::interpolationT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the transpose of the interpolation matrix from new to old. </p>
<p >Does the equivalent of the following </p><div class="fragment"><div class="line">Matrix A = <a class="code hl_function" href="group__interpolation.html#ga555f0315380f4e488298b970fe99bb43">dg::create::interpolation</a>( g_old, g_new);</div>
<div class="line"><span class="keywordflow">return</span> A.transpose();</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposed interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gaad425185a1a42e48ee2785c1a1bf2629" name="gaad425185a1a42e48ee2785c1a1bf2629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad425185a1a42e48ee2785c1a1bf2629">&#9670;&nbsp;</a></span>projection() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology2d.html">aRealMPITopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p >This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga6bb2ee2164fcf188a5825f83877ce5e6" name="ga6bb2ee2164fcf188a5825f83877ce5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bb2ee2164fcf188a5825f83877ce5e6">&#9670;&nbsp;</a></span>projection() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga383790a28074c1998e9abef496429b99">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology3d.html">aRealMPITopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p >This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gad20d227f6c8cb2547e757852413dbe7b" name="gad20d227f6c8cb2547e757852413dbe7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad20d227f6c8cb2547e757852413dbe7b">&#9670;&nbsp;</a></span>projection() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p >This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gad77a4a2cbeabce81c6a7bfdbfd5871cc" name="gad77a4a2cbeabce81c6a7bfdbfd5871cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad77a4a2cbeabce81c6a7bfdbfd5871cc">&#9670;&nbsp;</a></span>projection() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p >This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="ga5e117be1d538fffb647d858e1325cdf6" name="ga5e117be1d538fffb647d858e1325cdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e117be1d538fffb647d858e1325cdf6">&#9670;&nbsp;</a></span>projection() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p >This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gafb82763a4a75e035022ae1d0ee6fe55c" name="gafb82763a4a75e035022ae1d0ee6fe55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb82763a4a75e035022ae1d0ee6fe55c">&#9670;&nbsp;</a></span>projection() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p >This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gae1acd5229e37e86c014468f8a7029abf" name="gae1acd5229e37e86c014468f8a7029abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1acd5229e37e86c014468f8a7029abf">&#9670;&nbsp;</a></span>projection() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p >This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>
<p >!! cusp::multiply removes explicit zeros in the output</p>

</div>
</div>
<a id="gae51d004fa4abfa57f13502617ba184c6" name="gae51d004fa4abfa57f13502617ba184c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae51d004fa4abfa57f13502617ba184c6">&#9670;&nbsp;</a></span>projection() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p >This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__interpolation.html#ga87f53479753dfeaefe8d077ca1ce701c" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="group__interpolation.html#ga6b8bdd9c1752a8d88a683f816f182f3d" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid </dd></dl>

</div>
</div>
<a id="gab4b6355e9c86c83ee4555781daa429cf" name="gab4b6355e9c86c83ee4555781daa429cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4b6355e9c86c83ee4555781daa429cf">&#9670;&nbsp;</a></span>transformation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology2d.html">aRealTopology2d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p >The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
<a id="ga6b8bdd9c1752a8d88a683f816f182f3d" name="ga6b8bdd9c1752a8d88a683f816f182f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b8bdd9c1752a8d88a683f816f182f3d">&#9670;&nbsp;</a></span>transformation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology3d.html">aRealTopology3d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p >The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
<a id="ga69ae54a688a91889650a636f7245b6cd" name="ga69ae54a688a91889650a636f7245b6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69ae54a688a91889650a636f7245b6cd">&#9670;&nbsp;</a></span>transformation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cusp::coo_matrix&lt; int, real_type, cusp::host_memory &gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid1d.html">RealGrid1d</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p >The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have </p><p class="formulaDsp">
\[ \mathcal T = P Q \]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 28 2022 17:46:20 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
