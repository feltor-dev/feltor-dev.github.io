<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Discontinuous Galerkin Library: dg::ImExMultistep&lt; ContainerType, SolverType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Container free algorithms and discontinuous Galerkin numerical methods in &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structdg_1_1_im_ex_multistep.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_im_ex_multistep-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::ImExMultistep&lt; ContainerType, SolverType &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__numerical0.html">Level 2: Basic numerical algorithms</a> &raquo; <a class="el" href="group__time.html">Time integrators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Semi-implicit multistep time-integration.  
 <a href="structdg_1_1_im_ex_multistep.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="multistep_8h_source.html">multistep.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad5be9d9dd7333da6012f5db9bac7937f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a> = <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt; ContainerType &gt;</td></tr>
<tr class="memdesc:ad5be9d9dd7333da6012f5db9bac7937f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the value type of the time variable (float or double)  <a href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">More...</a><br /></td></tr>
<tr class="separator:ad5be9d9dd7333da6012f5db9bac7937f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af2296141c2cd38b7a535405870ed02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#a5af2296141c2cd38b7a535405870ed02">container_type</a> = ContainerType</td></tr>
<tr class="separator:a5af2296141c2cd38b7a535405870ed02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a36b8363e4fea0ac33afd43d440b0ca26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#a36b8363e4fea0ac33afd43d440b0ca26">ImExMultistep</a> ()</td></tr>
<tr class="memdesc:a36b8363e4fea0ac33afd43d440b0ca26"><td class="mdescLeft">&#160;</td><td class="mdescRight">No memory allocation, Call <code>construct</code> before using the object.  <a href="structdg_1_1_im_ex_multistep.html#a36b8363e4fea0ac33afd43d440b0ca26">More...</a><br /></td></tr>
<tr class="separator:a36b8363e4fea0ac33afd43d440b0ca26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b3656c36e6f91fd71272633226ac02"><td class="memTemplParams" colspan="2">template&lt;class ... SolverParams&gt; </td></tr>
<tr class="memitem:af1b3656c36e6f91fd71272633226ac02"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#af1b3656c36e6f91fd71272633226ac02">ImExMultistep</a> (<a class="el" href="structdg_1_1_converts_to_multistep_tableau.html">ConvertsToMultistepTableau</a>&lt; <a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a> &gt; tableau, SolverParams &amp;&amp;...ps)</td></tr>
<tr class="memdesc:af1b3656c36e6f91fd71272633226ac02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for integration and construct Solver.  <a href="structdg_1_1_im_ex_multistep.html#af1b3656c36e6f91fd71272633226ac02">More...</a><br /></td></tr>
<tr class="separator:af1b3656c36e6f91fd71272633226ac02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2946052092e3cad9daf2d0271436c380"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:a2946052092e3cad9daf2d0271436c380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#a2946052092e3cad9daf2d0271436c380">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:a2946052092e3cad9daf2d0271436c380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.  <a href="structdg_1_1_im_ex_multistep.html#a2946052092e3cad9daf2d0271436c380">More...</a><br /></td></tr>
<tr class="separator:a2946052092e3cad9daf2d0271436c380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a998d04c186653868ce8b4dbc09b3d"><td class="memItemLeft" align="right" valign="top">const ContainerType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#ab9a998d04c186653868ce8b4dbc09b3d">copyable</a> () const</td></tr>
<tr class="memdesc:ab9a998d04c186653868ce8b4dbc09b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an object of same size as the object used for construction.  <a href="structdg_1_1_im_ex_multistep.html#ab9a998d04c186653868ce8b4dbc09b3d">More...</a><br /></td></tr>
<tr class="separator:ab9a998d04c186653868ce8b4dbc09b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c60d82ed9afc388c387b4840304b5"><td class="memItemLeft" align="right" valign="top">SolverType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#ac44c60d82ed9afc388c387b4840304b5">solver</a> ()</td></tr>
<tr class="memdesc:ac44c60d82ed9afc388c387b4840304b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write access to the internal solver for the implicit part.  <a href="structdg_1_1_im_ex_multistep.html#ac44c60d82ed9afc388c387b4840304b5">More...</a><br /></td></tr>
<tr class="separator:ac44c60d82ed9afc388c387b4840304b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4e10ae02a7fdcabc35bc652aa04e8"><td class="memItemLeft" align="right" valign="top">const SolverType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#a61a4e10ae02a7fdcabc35bc652aa04e8">solver</a> () const</td></tr>
<tr class="memdesc:a61a4e10ae02a7fdcabc35bc652aa04e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to the internal solver for the implicit part.  <a href="structdg_1_1_im_ex_multistep.html#a61a4e10ae02a7fdcabc35bc652aa04e8">More...</a><br /></td></tr>
<tr class="separator:a61a4e10ae02a7fdcabc35bc652aa04e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82439b884ca1d48b7eb71ffaf4263547"><td class="memTemplParams" colspan="2">template&lt;class Explicit , class Implicit &gt; </td></tr>
<tr class="memitem:a82439b884ca1d48b7eb71ffaf4263547"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#a82439b884ca1d48b7eb71ffaf4263547">init</a> (Explicit &amp;ex, Implicit &amp;im, <a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a> t0, const ContainerType &amp;u0, <a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a> dt)</td></tr>
<tr class="memdesc:a82439b884ca1d48b7eb71ffaf4263547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize timestepper. Call before using the step function.  <a href="structdg_1_1_im_ex_multistep.html#a82439b884ca1d48b7eb71ffaf4263547">More...</a><br /></td></tr>
<tr class="separator:a82439b884ca1d48b7eb71ffaf4263547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a262a6c7ede7d62a501eaf9f0ce0302"><td class="memTemplParams" colspan="2">template&lt;class Explicit , class Implicit &gt; </td></tr>
<tr class="memitem:a1a262a6c7ede7d62a501eaf9f0ce0302"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdg_1_1_im_ex_multistep.html#a1a262a6c7ede7d62a501eaf9f0ce0302">step</a> (Explicit &amp;ex, Implicit &amp;im, <a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a> &amp;t, ContainerType &amp;u)</td></tr>
<tr class="memdesc:a1a262a6c7ede7d62a501eaf9f0ce0302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance one timestep.  <a href="structdg_1_1_im_ex_multistep.html#a1a262a6c7ede7d62a501eaf9f0ce0302">More...</a><br /></td></tr>
<tr class="separator:a1a262a6c7ede7d62a501eaf9f0ce0302"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ContainerType, class SolverType = dg::DefaultSolver&lt;ContainerType&gt;&gt;<br />
struct dg::ImExMultistep&lt; ContainerType, SolverType &gt;</h3>

<p>Semi-implicit multistep time-integration. </p>
<p class="formulaDsp">
\[ \begin{align} v^{n+1} = \sum_{q=0}^{s-1} a_q v^{n-q} + \Delta t\left[\left(\sum_{q=0}^{s-1}b_q \hat E(t^{n}-q\Delta t, v^{n-q}) + \sum_{q=1}^{s} c_q \hat I( t^n - q\Delta t, v^{n-q})\right) + c_0\hat I(t^{n}+\Delta t, v^{n+1})\right] \end{align} \]
</p>
<p> which discretizes </p><p class="formulaDsp">
\[ \frac{\partial v}{\partial t} = \hat E(t,v) + \hat I(t,v) \]
</p>
<p> where \( \hat E \) contains the explicit and \( \hat I \) the implicit part of the equations. As an example, the coefficients for the 3-step, 3rd order "Karniadakis" scheme are </p><p class="formulaDsp">
\[ a_0 = \frac{18}{11}\ a_1 = -\frac{9}{11}\ a_2 = \frac{2}{11} \\ b_0 = \frac{18}{11}\ b_1 = -\frac{18}{11}\ b_2 = \frac{6}{11} \\ c_0 = \frac{6}{11}\quad c_1 = c_2 = c_3 = 0 \\ \]
</p>
<p> You can use your own coefficients defined as a <code><a class="el" href="structdg_1_1_multistep_tableau.html" title="Manage coefficients of Multistep methods.">dg::MultistepTableau</a></code> or use one of the predefined coefficients in</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name </th><th class="markdownTableHeadNone">Identifier </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ImEx-Euler-1-1 </td><td class="markdownTableBodyNone"><a class="el" href="group__time__utils.html#ggaac3c0875ffdfb49fd06757312d1a599aaa269d9523f1c0f2858ee7b2da2ddc005">dg::IMEX_EULER_1_1</a> </td><td class="markdownTableBodyNone">Explicit Euler combined with Implicit Euler  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Euler </td><td class="markdownTableBodyNone"><a class="el" href="group__time__utils.html#ggaac3c0875ffdfb49fd06757312d1a599aaa269d9523f1c0f2858ee7b2da2ddc005">dg::IMEX_EULER_1_1</a> </td><td class="markdownTableBodyNone">For convenience  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ImEx-Koto-2-2 </td><td class="markdownTableBodyNone"><a class="el" href="group__time__utils.html#ggaac3c0875ffdfb49fd06757312d1a599aa34804fa61f76b9679a882c928f3462d6">dg::IMEX_KOTO_2_2</a> </td><td class="markdownTableBodyNone"><a href="https://dx.doi.org/10.1007/s11464-009-0005-9">Koto T. Front. Math. China 2009, 4(1): 113-129</a> A stabilized 2nd order scheme with a large region of stability  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ImEx-Adams-X-X </td><td class="markdownTableBodyNone">dg::IMEX_ADAMS_X_X </td><td class="markdownTableBodyNone"><a href="https://dx.doi.org/10.1016/j.jcp.2007.03.003">Hundsdorfer and Ruuth, Journal of Computational Physics 225 (2007)</a> <dl class="section note"><dt>Note</dt><dd><b>Possible values for X: 2 (C=0.44), 3 (C=0.16)</b>  </dd></dl>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ImEx-BDF-X-X </td><td class="markdownTableBodyNone">dg::IMEX_BDF_X_X </td><td class="markdownTableBodyNone">The family of schems described in <a href="https://dx.doi.org/10.1016/j.jcp.2007.03.003">Hundsdorfer and Ruuth, Journal of Computational Physics 225 (2007)</a> <br  />
The implicit part is a normal BDF scheme <a href="https://en.wikipedia.org/wiki/Backward_differentiation_formula">https://en.wikipedia.org/wiki/Backward_differentiation_formula</a> while the explicit part equals the Minimal Projecting method by <a href="https://www.ams.org/journals/mcom/1979-33-148/S0025-5718-1979-0537965-0/S0025-5718-1979-0537965-0.pdf">Alfeld, P., Math. Comput. 33.148 1195-1212 (1979)</a> or <b>extrapolated BDF</b> in <a href="https://doi.org/10.1137/S0036142902406326">Hundsdorfer, W., Ruuth, S. J., &amp; Spiteri, R. J. (2003). Monotonicity-preserving linear multistep methods. SIAM Journal on Numerical Analysis, 41(2), 605-623 </a> <br  />
 <dl class="section note"><dt>Note</dt><dd>Possible values for <b>X: 1 (C=1.00), 2 (C=0.63), 3 (C=0.39), 4 (C=0.22), 5 (C=0.09), 6</b> <br  />
 Note that X=3 is identical to the "Karniadakis" scheme  </dd></dl>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structdg_1_1_karniadakis.html" title="DEPRECATED (use ImExMultistep and select &quot;Karniadakis&quot; from the multistep tableaus)">Karniadakis</a> </td><td class="markdownTableBodyNone"><a class="el" href="group__time__utils.html#ggaac3c0875ffdfb49fd06757312d1a599aaf44dc27d112d9de8bd859ba62e38677c">dg::IMEX_BDF_3_3</a> </td><td class="markdownTableBodyNone">The ImEx-BDF-3-3 scheme is identical to the widely used "Karniadakis" scheme <a href="https://dx.doi.org/10.1016/0021-9991(91)90007-8">Karniadakis, et al. J. Comput. Phys. 97 (1991)</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ImEx-TVB-X-X </td><td class="markdownTableBodyNone">dg::IMEX_TVB_X_X </td><td class="markdownTableBodyNone">The family of schems described in &lt; <a href="https://dx.doi.org/10.1016/j.jcp.2007.03.003">Hundsdorfer and Ruuth, Journal of Computational Physics 225 (2007)</a> <br  />
 The explicit part is a TVB scheme while the implicit part is optimized to maximize damping of high wavelength <br  />
 <dl class="section note"><dt>Note</dt><dd>Possible values for <b>X: 3 (C=0.54), 4 (C=0.46), 5 (C=0.38)</b>  </dd></dl>
</td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>the CFL coefficient C is given relative to the forward Euler method: \( \Delta t &lt; C \Delta t_{FE}\). </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The coefficient C is the one that ensures the TVD property of the scheme and is <b>not</b> directly related to the stability region of the scheme</dd></dl>
<p>The necessary Inversion in the implicit part is provided by the <code>SolverType</code> class. Per Default, a conjugate gradient method is used (therefore \( \hat I(t,v)\) must be linear in \( v\)).</p>
<p>The following code example demonstrates how to implement the method of manufactured solutions on a 2d partial differential equation with the dg library: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Explicit</div>
<div class="line">{</div>
<div class="line">    Explicit( <span class="keywordtype">double</span> nu): m_nu( nu) {}</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">double</span> t, <span class="keyword">const</span> std::array&lt;double,2&gt;&amp; T, std::array&lt;double,2&gt;&amp; Tp)</div>
<div class="line">    {</div>
<div class="line">        Tp[0] = m_nu*cos(t) - sin(t);</div>
<div class="line">        Tp[1] = m_nu*sin(t) + cos(t);</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> m_nu;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">//the implicit part contains  Tp = -nu T</span></div>
<div class="line"><span class="keyword">struct </span>Implicit</div>
<div class="line">{</div>
<div class="line">    Implicit( <span class="keywordtype">double</span> nu): m_nu(nu) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">double</span> t, <span class="keyword">const</span> std::array&lt;double,2&gt;&amp; T, std::array&lt;double,2&gt;&amp; Tp)</div>
<div class="line">    {</div>
<div class="line">        Tp[0] = -m_nu*T[0];</div>
<div class="line">        Tp[1] = -m_nu*T[1];</div>
<div class="line">    }</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">double</span> m_nu;</div>
<div class="line">};</div>
<div class="line"><span class="comment">// solve y + alpha I(t,y)  = rhs</span></div>
<div class="line"><span class="keyword">struct </span>ImplicitSolver</div>
<div class="line">{</div>
<div class="line">    ImplicitSolver( <span class="keywordtype">double</span> nu): m_nu(nu) { }</div>
<div class="line">    std::array&lt;double,2&gt; <a class="code" href="structdg_1_1_im_ex_multistep.html#ab9a998d04c186653868ce8b4dbc09b3d">copyable</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> {0,0};}</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Implicit&gt;</div>
<div class="line">    <span class="keywordtype">void</span> solve( <span class="keywordtype">double</span> alpha, Implicit&amp; im, <span class="keywordtype">double</span> t, std::array&lt;double,2&gt;&amp; y, <span class="keyword">const</span> std::array&lt;double,2&gt;&amp; rhs)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[0] = rhs[0]/(1-alpha*m_nu);</div>
<div class="line">        <a class="code" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[1] = rhs[1]/(1-alpha*m_nu);</div>
<div class="line">    }</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">double</span> m_nu;</div>
<div class="line">};</div>
<div class="line"> </div>
</div><!-- fragment --><p> In the main function: </p><div class="fragment"><div class="line">        <span class="comment">//construct time stepper</span></div>
<div class="line">        <a class="code" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep&lt; std::array&lt;double,2&gt;</a>, ImplicitSolver &gt; imex( name, nu);</div>
<div class="line">        time = 0., y0 = <a class="code" href="structdg_1_1_im_ex_multistep.html#a82439b884ca1d48b7eb71ffaf4263547">init</a>; <span class="comment">//y0 and init are of type std::array&lt;double,2&gt; and contain the initial condition</span></div>
<div class="line">        <span class="comment">//initialize the timestepper (ex and im are objects of type Explicit and Implicit defined above)</span></div>
<div class="line">        imex.init( ex, im, time, y0, dt);</div>
<div class="line">        <span class="comment">//main time loop (NT = 20)</span></div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;NT; k++)</div>
<div class="line">            imex.step( ex, im, time, y0); <span class="comment">//inplace step</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In our experience the implicit treatment of diffusive or hyperdiffusive terms may significantly reduce the required number of time steps. This outweighs the increased computational cost of the additional matrix inversions. However, each PDE is different and general statements like this one should be treated with care.</dd>
<dd>
Uses only <code><a class="el" href="group__blas1.html#ga5c7ddbf70dd74867e45c9d4f40b36cf7">blas1::axpby</a></code> routines to integrate one step. </dd>
<dd>
The difference between a multistep and a single step method like <a class="el" href="structdg_1_1_runge_kutta.html" title="Runge-Kutta fixed-step explicit time-integration.">RungeKutta</a> is that the multistep only takes one right-hand-side evaluation per step. This is advantageous if the right hand side is expensive to evaluate. Even though Runge Kutta methods can have a larger absolute timestep, if the effective timestep per rhs evaluation is compared, multistep methods generally win. </dd>
<dd>
a disadvantage of multistep is that timestep adaption is not easily done.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SolverType</td><td>The task of this class is to solve the equation \( (y+\alpha\hat I(t,y)) = \rho\) for the given implicit part I, parameter alpha, time t and right hand side rho. For example <code><a class="el" href="structdg_1_1_default_solver.html" title="Default Solver class for solving.">dg::DefaultSolver</a></code> or <code><a class="el" href="structdg_1_1_fixed_point_solver.html" title="Fixed point iterator for solving.">dg::FixedPointSolver</a></code> If you write your own class: it must have a solve method of type: <code>void</code> <code>solve( value_type alpha, Implicit im, value_type t, ContainerType&amp; y, const ContainerType&amp; rhs)</code>; The <code> const ContainerType&amp; <a class="el" href="structdg_1_1_im_ex_multistep.html#ab9a998d04c186653868ce8b4dbc09b3d" title="Return an object of same size as the object used for construction.">copyable() const</a>; </code> member must return a container of the size that is later used in <code>solve</code> (it does not matter what values <code>copyable</code> contains, but its size is important; the <code>solve</code> method will be called with vectors of this size)</td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; (vector of shared device vectors), std::array&lt;double, 4&gt; (array of 4 doubles)</code></li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="index.html#dispatch">The Level 1 dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5af2296141c2cd38b7a535405870ed02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af2296141c2cd38b7a535405870ed02">&#9670;&nbsp;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::<a class="el" href="structdg_1_1_im_ex_multistep.html#a5af2296141c2cd38b7a535405870ed02">container_type</a> =  ContainerType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the type of the vector class in use </p>

</div>
</div>
<a id="ad5be9d9dd7333da6012f5db9bac7937f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5be9d9dd7333da6012f5db9bac7937f">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::<a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a> =  <a class="el" href="group__dispatch.html#gaed462ca0faf1fc38350080acc788f533">get_value_type</a>&lt;ContainerType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the value type of the time variable (float or double) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a36b8363e4fea0ac33afd43d440b0ca26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b8363e4fea0ac33afd43d440b0ca26">&#9670;&nbsp;</a></span>ImExMultistep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::<a class="el" href="structdg_1_1_im_ex_multistep.html">ImExMultistep</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No memory allocation, Call <code>construct</code> before using the object. </p>

</div>
</div>
<a id="af1b3656c36e6f91fd71272633226ac02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b3656c36e6f91fd71272633226ac02">&#9670;&nbsp;</a></span>ImExMultistep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... SolverParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::<a class="el" href="structdg_1_1_im_ex_multistep.html">ImExMultistep</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdg_1_1_converts_to_multistep_tableau.html">ConvertsToMultistepTableau</a>&lt; <a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverParams &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve memory for integration and construct Solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableau</td><td>Tableau, name or identifier that <code><a class="el" href="structdg_1_1_converts_to_multistep_tableau.html" title="Convert identifiers to their corresponding dg::MultistepTableau.">ConvertsToMultistepTableau</a></code> </td></tr>
    <tr><td class="paramname">ps</td><td>Parameters that are forwarded to the constructor of <code>SolverType</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SolverParams</td><td>Type of parameters (deduced by the compiler) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2946052092e3cad9daf2d0271436c380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2946052092e3cad9daf2d0271436c380">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9a998d04c186653868ce8b4dbc09b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a998d04c186653868ce8b4dbc09b3d">&#9670;&nbsp;</a></span>copyable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ContainerType&amp; <a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::copyable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an object of same size as the object used for construction. </p>
<dl class="section return"><dt>Returns</dt><dd>A copyable object; what it contains is undefined, its size is important </dd></dl>

</div>
</div>
<a id="a82439b884ca1d48b7eb71ffaf4263547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82439b884ca1d48b7eb71ffaf4263547">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Explicit , class Implicit &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::init </td>
          <td>(</td>
          <td class="paramtype">Explicit &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Implicit &amp;&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a>&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a>&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize timestepper. Call before using the step function. </p>
<p>This routine has to be called before the first timestep is made.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Explicit</td><td>The explicit part of the right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = f(t, y) translates to f(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. </td></tr>
    <tr><td class="paramname">Implicit</td><td>The implicit part of the right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = f(t, y) translates to f(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. Furthermore, if the <code><a class="el" href="structdg_1_1_default_solver.html" title="Default Solver class for solving.">DefaultSolver</a></code> is used, the routines weights(), inv_weights() and precond() must be callable and return diagonal weights, inverse weights and the preconditioner for the conjugate gradient method. The return type of these member functions must be useable in <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions together with the ContainerType type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>explic part </td></tr>
    <tr><td class="paramname">im</td><td>implicit part ( must be linear in its second argument and symmetric up to weights) </td></tr>
    <tr><td class="paramname">t0</td><td>The intital time corresponding to u0 </td></tr>
    <tr><td class="paramname">u0</td><td>The initial value of the integration </td></tr>
    <tr><td class="paramname">dt</td><td>The timestep saved for later use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the implementation is such that on output the last call to the explicit part <code>ex</code> is at <code></code>(t0,u0). This might be interesting if the call to <code>ex</code> changes its state. </dd></dl>

</div>
</div>
<a id="ac44c60d82ed9afc388c387b4840304b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44c60d82ed9afc388c387b4840304b5">&#9670;&nbsp;</a></span>solver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SolverType&amp; <a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write access to the internal solver for the implicit part. </p>

</div>
</div>
<a id="a61a4e10ae02a7fdcabc35bc652aa04e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a4e10ae02a7fdcabc35bc652aa04e8">&#9670;&nbsp;</a></span>solver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SolverType&amp; <a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read access to the internal solver for the implicit part. </p>

</div>
</div>
<a id="a1a262a6c7ede7d62a501eaf9f0ce0302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a262a6c7ede7d62a501eaf9f0ce0302">&#9670;&nbsp;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class SolverType  = dg::DefaultSolver&lt;ContainerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Explicit , class Implicit &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a>&lt; ContainerType, SolverType &gt;::step </td>
          <td>(</td>
          <td class="paramtype">Explicit &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Implicit &amp;&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdg_1_1_im_ex_multistep.html#ad5be9d9dd7333da6012f5db9bac7937f">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance one timestep. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Explicit</td><td>The explicit part of the right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = f(t, y) translates to f(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. </td></tr>
    <tr><td class="paramname">Implicit</td><td>The implicit part of the right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = f(t, y) translates to f(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. Furthermore, if the <code><a class="el" href="structdg_1_1_default_solver.html" title="Default Solver class for solving.">DefaultSolver</a></code> is used, the routines weights(), inv_weights() and precond() must be callable and return diagonal weights, inverse weights and the preconditioner for the conjugate gradient method. The return type of these member functions must be useable in <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions together with the ContainerType type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>explic part </td></tr>
    <tr><td class="paramname">im</td><td>implicit part ( must be linear in its second argument and symmetric up to weights) </td></tr>
    <tr><td class="paramname">t</td><td>(write-only), contains timestep corresponding to <code>u</code> on output </td></tr>
    <tr><td class="paramname">u</td><td>(write-only), contains next step of time-integration on output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the implementation is such that on output the last call to the explicit part <code>ex</code> is at the new <code></code>(t,u). This might be interesting if the call to <code>ex</code> changes its state. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The first few steps after the call to the init function are performed with a semi-implicit Runge-Kutta method to initialize the multistepper </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="multistep_8h_source.html">multistep.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astructdg_1_1_im_ex_multistep_html_a82439b884ca1d48b7eb71ffaf4263547"><div class="ttname"><a href="structdg_1_1_im_ex_multistep.html#a82439b884ca1d48b7eb71ffaf4263547">dg::ImExMultistep::init</a></div><div class="ttdeci">void init(Explicit &amp;ex, Implicit &amp;im, value_type t0, const ContainerType &amp;u0, value_type dt)</div><div class="ttdoc">Initialize timestepper. Call before using the step function.</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">dg::coo2d::y</a></div><div class="ttdeci">@ y</div><div class="ttdoc">y direction</div></div>
<div class="ttc" id="astructdg_1_1_im_ex_multistep_html_ab9a998d04c186653868ce8b4dbc09b3d"><div class="ttname"><a href="structdg_1_1_im_ex_multistep.html#ab9a998d04c186653868ce8b4dbc09b3d">dg::ImExMultistep::copyable</a></div><div class="ttdeci">const ContainerType &amp; copyable() const</div><div class="ttdoc">Return an object of same size as the object used for construction.</div><div class="ttdef"><b>Definition:</b> multistep.h:133</div></div>
<div class="ttc" id="astructdg_1_1_im_ex_multistep_html"><div class="ttname"><a href="structdg_1_1_im_ex_multistep.html">dg::ImExMultistep</a></div><div class="ttdoc">Semi-implicit multistep time-integration.</div><div class="ttdef"><b>Definition:</b> multistep.h:86</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_im_ex_multistep.html">ImExMultistep</a></li>
    <li class="footer">Generated on Tue Feb 16 2021 01:15:31 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
