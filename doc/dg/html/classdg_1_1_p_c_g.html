<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: dg::PCG&lt; ContainerType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classdg_1_1_p_c_g.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdg_1_1_p_c_g-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::PCG&lt; ContainerType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__numerical0.html">Level 2: Basic numerical algorithms</a> &raquo; <a class="el" href="group__invert.html">Linear and nonlinear solvers</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Preconditioned conjugate gradient method to solve.  
 <a href="classdg_1_1_p_c_g.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abade4ea06ecf7bbfc6330468b9b229be"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#abade4ea06ecf7bbfc6330468b9b229be">container_type</a> = ContainerType</td></tr>
<tr class="separator:abade4ea06ecf7bbfc6330468b9b229be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef89010e9771cf4ccd5b3e9a8bcf17e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#a5ef89010e9771cf4ccd5b3e9a8bcf17e">value_type</a> = <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;</td></tr>
<tr class="separator:a5ef89010e9771cf4ccd5b3e9a8bcf17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3afd38c9a2a85de924f2977cc49c5ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#ac3afd38c9a2a85de924f2977cc49c5ce">PCG</a> ()</td></tr>
<tr class="memdesc:ac3afd38c9a2a85de924f2977cc49c5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate nothing, Call <code>construct</code> method before usage.  <a href="classdg_1_1_p_c_g.html#ac3afd38c9a2a85de924f2977cc49c5ce">More...</a><br /></td></tr>
<tr class="separator:ac3afd38c9a2a85de924f2977cc49c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c6db9dbdcd557bf91bb47a8cb512e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#a54c6db9dbdcd557bf91bb47a8cb512e5">PCG</a> (const ContainerType &amp;<a class="el" href="classdg_1_1_p_c_g.html#a85d06136e39ebb7fc05a43fe3280563e">copyable</a>, unsigned max_iterations)</td></tr>
<tr class="memdesc:a54c6db9dbdcd557bf91bb47a8cb512e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for the pcg method.  <a href="classdg_1_1_p_c_g.html#a54c6db9dbdcd557bf91bb47a8cb512e5">More...</a><br /></td></tr>
<tr class="separator:a54c6db9dbdcd557bf91bb47a8cb512e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89bc5710f1a7cecc887e70e84557744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#aa89bc5710f1a7cecc887e70e84557744">set_max</a> (unsigned new_max)</td></tr>
<tr class="memdesc:aa89bc5710f1a7cecc887e70e84557744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations.  <a href="classdg_1_1_p_c_g.html#aa89bc5710f1a7cecc887e70e84557744">More...</a><br /></td></tr>
<tr class="separator:aa89bc5710f1a7cecc887e70e84557744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04e0790b9a83d9c5e582dedea0daea3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#ad04e0790b9a83d9c5e582dedea0daea3">get_max</a> () const</td></tr>
<tr class="memdesc:ad04e0790b9a83d9c5e582dedea0daea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current maximum number of iterations.  <a href="classdg_1_1_p_c_g.html#ad04e0790b9a83d9c5e582dedea0daea3">More...</a><br /></td></tr>
<tr class="separator:ad04e0790b9a83d9c5e582dedea0daea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d06136e39ebb7fc05a43fe3280563e"><td class="memItemLeft" align="right" valign="top">const ContainerType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#a85d06136e39ebb7fc05a43fe3280563e">copyable</a> () const</td></tr>
<tr class="memdesc:a85d06136e39ebb7fc05a43fe3280563e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an object of same size as the object used for construction.  <a href="classdg_1_1_p_c_g.html#a85d06136e39ebb7fc05a43fe3280563e">More...</a><br /></td></tr>
<tr class="separator:a85d06136e39ebb7fc05a43fe3280563e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ef33138778077af8d4c1713e6ba868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#a63ef33138778077af8d4c1713e6ba868">set_verbose</a> (bool verbose)</td></tr>
<tr class="memdesc:a63ef33138778077af8d4c1713e6ba868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or unset debugging output during iterations.  <a href="classdg_1_1_p_c_g.html#a63ef33138778077af8d4c1713e6ba868">More...</a><br /></td></tr>
<tr class="separator:a63ef33138778077af8d4c1713e6ba868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44344f2e4a30a0c8a03cf50211d38c2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#a44344f2e4a30a0c8a03cf50211d38c2d">set_throw_on_fail</a> (bool throw_on_fail)</td></tr>
<tr class="memdesc:a44344f2e4a30a0c8a03cf50211d38c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or unset a throw on failure-to-converge.  <a href="classdg_1_1_p_c_g.html#a44344f2e4a30a0c8a03cf50211d38c2d">More...</a><br /></td></tr>
<tr class="separator:a44344f2e4a30a0c8a03cf50211d38c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b457056e99d04a6e5ddd1252cd2a3c"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:aa7b457056e99d04a6e5ddd1252cd2a3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#aa7b457056e99d04a6e5ddd1252cd2a3c">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:aa7b457056e99d04a6e5ddd1252cd2a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.  <a href="classdg_1_1_p_c_g.html#aa7b457056e99d04a6e5ddd1252cd2a3c">More...</a><br /></td></tr>
<tr class="separator:aa7b457056e99d04a6e5ddd1252cd2a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cc285c8cc7f04f98b4fcba1ecb2d4d"><td class="memTemplParams" colspan="2">template&lt;class MatrixType0 , class ContainerType0 , class ContainerType1 , class MatrixType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ae4cc285c8cc7f04f98b4fcba1ecb2d4d"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdg_1_1_p_c_g.html#ae4cc285c8cc7f04f98b4fcba1ecb2d4d">solve</a> (MatrixType0 &amp;&amp;A, ContainerType0 &amp;x, const ContainerType1 &amp;b, MatrixType1 &amp;&amp;P, const ContainerType2 &amp;W, <a class="el" href="classdg_1_1_p_c_g.html#a5ef89010e9771cf4ccd5b3e9a8bcf17e">value_type</a> eps=1e-12, <a class="el" href="classdg_1_1_p_c_g.html#a5ef89010e9771cf4ccd5b3e9a8bcf17e">value_type</a> nrmb_correction=1, int test_frequency=1)</td></tr>
<tr class="memdesc:ae4cc285c8cc7f04f98b4fcba1ecb2d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve \( Ax = b\) using a preconditioned conjugate gradient method.  <a href="classdg_1_1_p_c_g.html#ae4cc285c8cc7f04f98b4fcba1ecb2d4d">More...</a><br /></td></tr>
<tr class="separator:ae4cc285c8cc7f04f98b4fcba1ecb2d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ContainerType&gt;<br />
class dg::PCG&lt; ContainerType &gt;</div><p >Preconditioned conjugate gradient method to solve. </p>
<p class="formulaDsp">
\[ Ax=b\]
</p>
<p >where \( A\) is positive definite and self-adjoint in the weighted scalar product (defined by the diagonal weights matrix \(W\)) </p><p class="formulaDsp">
\[ A^\dagger := \frac{1}{W} A^T W = A\]
</p>
<p>. Note that if \( A\) is self-adjoint then both \( (WA)^T = WA \) and \( \left(A \frac{1}{W}\right)^T = A\frac{1}{W}\) are symmetric. The positive definite, self-adjoint preconditioner \( P \approx A^{-1}\) that approximates the inverse of \( A\) and is fast to apply, is used to solve the left preconditioned system </p><p class="formulaDsp">
\[ PAx=Pb\]
</p>
<dl class="section see"><dt>See also</dt><dd>This implements the <a class="el" href="classdg_1_1_p_c_g.html" title="Preconditioned conjugate gradient method to solve.">PCG</a> algorithm (applied <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> \((WA)\) as given in <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">https://en.wikipedia.org/wiki/Conjugate_gradient_method</a> or the book <a href="https://www-users.cs.umn.edu/~saad/IterMethBook_2ndEd.pdf">Iterative Methods for Sparse Linear Systems" 2nd edition by Yousef Saad </a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Conjugate gradients might become unstable for positive semidefinite matrices arising e.g. in the discretization of the periodic laplacian </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>beware the sign: a negative definite matrix does <b>not</b> work in Conjugate gradient</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">// create volume and inverse volume on previously defined grid</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a> w2d = <a class="code hl_function" href="group__highlevel.html#ga7b869566cb76ee5eb9eaaa95abc65fb0">dg::create::weights</a>( grid);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create unnormalized Laplacian</span></div>
<div class="line">    <a class="code hl_class" href="classdg_1_1_elliptic.html">dg::Elliptic&lt;dg::CartesianGrid2d, dg::HMatrix, dg::HVec&gt;</a> A( grid);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// allocate memory in conjugate gradient</span></div>
<div class="line">    <a class="code hl_class" href="classdg_1_1_p_c_g.html">dg::PCG&lt;dg::HVec &gt;</a> pcg( copyable_vector, max_iter);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Evaluate right hand side and solution on the grid</span></div>
<div class="line">    <a class="code hl_typedef" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a> b = <a class="code hl_function" href="group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">dg::evaluate</a> ( laplace_fct, grid);</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a> solution = <a class="code hl_function" href="group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">dg::evaluate</a> ( fct, grid);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// use inverse volume as preconditioner in solution method</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> eps = 1e-6;</div>
<div class="line">    <span class="keywordtype">unsigned</span> num_iter = pcg.solve( A, x, b, 1., w2d, eps);</div>
<div class="ttc" id="aclassdg_1_1_elliptic_html"><div class="ttname"><a href="classdg_1_1_elliptic.html">dg::Elliptic</a></div><div class="ttdoc">A 2d negative elliptic differential operator .</div><div class="ttdef"><b>Definition:</b> elliptic.h:73</div></div>
<div class="ttc" id="aclassdg_1_1_p_c_g_html"><div class="ttname"><a href="classdg_1_1_p_c_g.html">dg::PCG</a></div><div class="ttdoc">Preconditioned conjugate gradient method to solve.</div><div class="ttdef"><b>Definition:</b> pcg.h:48</div></div>
<div class="ttc" id="agroup__evaluation_html_gac802d2b4de66df9ce2282e378461ce28"><div class="ttname"><a href="group__evaluation.html#gac802d2b4de66df9ce2282e378461ce28">dg::evaluate</a></div><div class="ttdeci">thrust::host_vector&lt; real_type &gt; evaluate(UnaryOp f, const RealGrid1d&lt; real_type &gt; &amp;g)</div><div class="ttdoc">Evaluate a 1d function on grid coordinates.</div><div class="ttdef"><b>Definition:</b> evaluation.h:67</div></div>
<div class="ttc" id="agroup__highlevel_html_ga7b869566cb76ee5eb9eaaa95abc65fb0"><div class="ttname"><a href="group__highlevel.html#ga7b869566cb76ee5eb9eaaa95abc65fb0">dg::create::weights</a></div><div class="ttdeci">MPI_Vector&lt; thrust::host_vector&lt; real_type &gt; &gt; weights(const aRealMPITopology2d&lt; real_type &gt; &amp;g)</div><div class="ttdoc">Nodal weight coefficients.</div><div class="ttdef"><b>Definition:</b> mpi_weights.h:22</div></div>
<div class="ttc" id="agroup__typedefs_html_ga4fb8e78e7b043edfedb880523f0cd193"><div class="ttname"><a href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a></div><div class="ttdeci">thrust::host_vector&lt; double &gt; HVec</div><div class="ttdoc">Host Vector.</div><div class="ttdef"><b>Definition:</b> typedefs.h:19</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abade4ea06ecf7bbfc6330468b9b229be" name="abade4ea06ecf7bbfc6330468b9b229be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abade4ea06ecf7bbfc6330468b9b229be">&#9670;&nbsp;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::container_type =  ContainerType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ef89010e9771cf4ccd5b3e9a8bcf17e" name="a5ef89010e9771cf4ccd5b3e9a8bcf17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef89010e9771cf4ccd5b3e9a8bcf17e">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::value_type =  <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt;ContainerType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >value type of the ContainerType class </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3afd38c9a2a85de924f2977cc49c5ce" name="ac3afd38c9a2a85de924f2977cc49c5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3afd38c9a2a85de924f2977cc49c5ce">&#9670;&nbsp;</a></span>PCG() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::PCG </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate nothing, Call <code>construct</code> method before usage. </p>

</div>
</div>
<a id="a54c6db9dbdcd557bf91bb47a8cb512e5" name="a54c6db9dbdcd557bf91bb47a8cb512e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c6db9dbdcd557bf91bb47a8cb512e5">&#9670;&nbsp;</a></span>PCG() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::PCG </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>copyable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>max_iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for the pcg method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copyable</td><td>A ContainerType must be copy-constructible from this </td></tr>
    <tr><td class="paramname">max_iterations</td><td>Maximum number of iterations to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa7b457056e99d04a6e5ddd1252cd2a3c" name="aa7b457056e99d04a6e5ddd1252cd2a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b457056e99d04a6e5ddd1252cd2a3c">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85d06136e39ebb7fc05a43fe3280563e" name="a85d06136e39ebb7fc05a43fe3280563e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d06136e39ebb7fc05a43fe3280563e">&#9670;&nbsp;</a></span>copyable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ContainerType &amp; <a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::copyable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an object of same size as the object used for construction. </p>
<dl class="section return"><dt>Returns</dt><dd>A copyable object; what it contains is undefined, its size is important </dd></dl>

</div>
</div>
<a id="ad04e0790b9a83d9c5e582dedea0daea3" name="ad04e0790b9a83d9c5e582dedea0daea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04e0790b9a83d9c5e582dedea0daea3">&#9670;&nbsp;</a></span>get_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::get_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current maximum number of iterations. </p>
<dl class="section return"><dt>Returns</dt><dd>the current maximum </dd></dl>

</div>
</div>
<a id="aa89bc5710f1a7cecc887e70e84557744" name="aa89bc5710f1a7cecc887e70e84557744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89bc5710f1a7cecc887e70e84557744">&#9670;&nbsp;</a></span>set_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::set_max </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>new_max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_max</td><td>New maximum number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44344f2e4a30a0c8a03cf50211d38c2d" name="a44344f2e4a30a0c8a03cf50211d38c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44344f2e4a30a0c8a03cf50211d38c2d">&#9670;&nbsp;</a></span>set_throw_on_fail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::set_throw_on_fail </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throw_on_fail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set or unset a throw on failure-to-converge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">throw_on_fail</td><td>If true, the solve method will thow a <a class="el" href="structdg_1_1_fail.html" title="Indicate failure to converge.">dg::Fail</a> if it is unable to converge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the default value is true </dd></dl>

</div>
</div>
<a id="a63ef33138778077af8d4c1713e6ba868" name="a63ef33138778077af8d4c1713e6ba868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ef33138778077af8d4c1713e6ba868">&#9670;&nbsp;</a></span>set_verbose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::set_verbose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set or unset debugging output during iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>If true, additional output will be written to <code>std::cout</code> during solution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4cc285c8cc7f04f98b4fcba1ecb2d4d" name="ae4cc285c8cc7f04f98b4fcba1ecb2d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cc285c8cc7f04f98b4fcba1ecb2d4d">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<div class="memtemplate">
template&lt;class MatrixType0 , class ContainerType0 , class ContainerType1 , class MatrixType1 , class ContainerType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classdg_1_1_p_c_g.html">dg::PCG</a>&lt; ContainerType &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">MatrixType0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdg_1_1_p_c_g.html#a5ef89010e9771cf4ccd5b3e9a8bcf17e">value_type</a>&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdg_1_1_p_c_g.html#a5ef89010e9771cf4ccd5b3e9a8bcf17e">value_type</a>&#160;</td>
          <td class="paramname"><em>nrmb_correction</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>test_frequency</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve \( Ax = b\) using a preconditioned conjugate gradient method. </p>
<p >The iteration stops if \( ||Ax-b||_W &lt; \epsilon( ||b||_W + C) \) where \(C\) is the absolute error in units of \( \epsilon\) and \( W \) defines a square norm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A self-adjoint positive definit matrix with respect to the weights <code>W</code> </td></tr>
    <tr><td class="paramname">x</td><td>Contains an initial value on input and the solution on output. </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side vector. </td></tr>
    <tr><td class="paramname">P</td><td>The preconditioner to be used (an approximation to the inverse of <code>A</code> that is fast to compute) </td></tr>
    <tr><td class="paramname">W</td><td>Weights that define the scalar product in which <code>A</code> and <code>P</code> are self-adjoint and in which the error norm is computed. </td></tr>
    <tr><td class="paramname">eps</td><td>The relative error to be respected </td></tr>
    <tr><td class="paramname">nrmb_correction</td><td>the absolute error <code>C</code> in units of <code>eps</code> to be respected </td></tr>
    <tr><td class="paramname">test_frequency</td><td>if set to 1 then the norm of the error is computed in every iteration to test if the loop can be terminated. Sometimes, especially for small sizes the dot product is expensive to compute, then it is beneficial to set this parameter to e.g. 10, which means that the errror condition is only evaluated every 10th iteration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of iterations used to achieve desired precision </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The method will throw <code><a class="el" href="structdg_1_1_fail.html" title="Indicate failure to converge.">dg::Fail</a></code> if the desired accuracy is not reached within <code>max_iterations</code> You can unset this behaviour with the <code>set_throw_on_fail</code> member </dd>
<dd>
Required memops per iteration (<code>P</code> is assumed vector):<ul>
<li>15 reads + 4 writes</li>
<li>plus the number of memops for <code>A</code>;</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and defines a tensor_category derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html">AnyMatrixTag</a></code>. Furthermore, any functor/lambda type with signature <code> void operator()( const ContainerType0&amp;, ContainerType1&amp;) </code>. For example<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code> std::function&lt;void( const ContainerType0&amp;, ContainerType1&amp;)&gt; </code></li>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga3d74638bbcf620f19e3728a07ef1706d">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#gaec4df2a8ab65260aed0efeb6f5d115e4">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
</ul>
In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code> symv( const ContainerType0&amp;, ContainerType1&amp;); </code> ) can be called. If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the matrix is applied to each of the elements unless the type has the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> or is a Functor type.</td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="pcg_8h_source.html">pcg.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="classdg_1_1_p_c_g.html">PCG</a></li>
    <li class="footer">Generated on Fri Jan 28 2022 17:46:22 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
