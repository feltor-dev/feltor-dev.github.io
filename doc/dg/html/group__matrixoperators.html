<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Discontinuous Galerkin Library: Matrix operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Container free algorithms and discontinuous Galerkin numerical methods in &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__matrixoperators.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Matrix operators<div class="ingroups"><a class="el" href="group__numerical1.html">Level 4: Advanced numerical schemes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Gradient \( \chi\cdot\nabla f\), Elliptic \( -\nabla\cdot (\chi \nabla f)\) and Helmholtz \( (\chi + \alpha \Delta) f\).  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Matrix operators:</div>
<div class="dyncontent">
<div class="center"><img src="group__matrixoperators.png" border="0" usemap="#group____matrixoperators" alt=""/></div>
<map name="group____matrixoperators" id="group____matrixoperators">
<area shape="rect" title="Gradient , Elliptic &#160;and Helmholtz ." alt="" coords="264,13,395,38"/>
<area shape="rect" href="group__numerical1.html" title=" " alt="" coords="5,5,216,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_elliptic.html">dg::Elliptic&lt; Geometry, Matrix, Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2d negative elliptic differential operator \( -\nabla \cdot ( \chi \nabla ) \).  <a href="classdg_1_1_elliptic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_elliptic3d.html">dg::Elliptic3d&lt; Geometry, Matrix, Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3d negative elliptic differential operator \( -\nabla \cdot ( \chi \nabla ) \).  <a href="classdg_1_1_elliptic3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_gradient.html">dg::Gradient&lt; Geometry, Matrix, Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator.  <a href="classdg_1_1_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_gradient3d.html">dg::Gradient3d&lt; Geometry, Matrix, Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator.  <a href="classdg_1_1_gradient3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_helmholtz.html">dg::Helmholtz&lt; Geometry, Matrix, Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class that represents a Helmholtz-type operator \( (\chi+\alpha\Delta) \).  <a href="structdg_1_1_helmholtz.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_helmholtz3d.html">dg::Helmholtz3d&lt; Geometry, Matrix, Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class that represents a 3d Helmholtz-type operator \( (\chi+\alpha\Delta) \).  <a href="structdg_1_1_helmholtz3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1_helmholtz2.html">dg::Helmholtz2&lt; Geometry, Matrix, Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED, Matrix class that represents a more general Helmholtz-type operator.  <a href="structdg_1_1_helmholtz2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdg_1_1_refined_elliptic.html">dg::RefinedElliptic&lt; Geometry, IMatrix, Matrix, Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The refined version of <code><a class="el" href="classdg_1_1_elliptic.html" title="A 2d negative elliptic differential operator .">Elliptic</a></code>.  <a href="classdg_1_1_refined_elliptic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae40a319b095c51491395216d59fd8645"><td class="memTemplParams" colspan="2">template&lt;class Geometry , class Matrix , class Container &gt; </td></tr>
<tr class="memitem:gae40a319b095c51491395216d59fd8645"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrixoperators.html#gae40a319b095c51491395216d59fd8645">dg::Elliptic2d</a> = <a class="el" href="classdg_1_1_elliptic.html">Elliptic</a>&lt; Geometry, Matrix, Container &gt;</td></tr>
<tr class="memdesc:gae40a319b095c51491395216d59fd8645"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2d negative elliptic differential operator \( -\nabla \cdot ( \chi \nabla ) \).  <a href="group__matrixoperators.html#gae40a319b095c51491395216d59fd8645">More...</a><br /></td></tr>
<tr class="separator:gae40a319b095c51491395216d59fd8645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bfec765ddaa27750c6ddae6227e875c"><td class="memTemplParams" colspan="2">template&lt;class Geometry , class Matrix , class Container &gt; </td></tr>
<tr class="memitem:ga2bfec765ddaa27750c6ddae6227e875c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrixoperators.html#ga2bfec765ddaa27750c6ddae6227e875c">dg::Gradient2d</a> = <a class="el" href="classdg_1_1_gradient.html">Gradient</a>&lt; Geometry, Matrix, Container &gt;</td></tr>
<tr class="memdesc:ga2bfec765ddaa27750c6ddae6227e875c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator.  <a href="group__matrixoperators.html#ga2bfec765ddaa27750c6ddae6227e875c">More...</a><br /></td></tr>
<tr class="separator:ga2bfec765ddaa27750c6ddae6227e875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa772c365c9f05b66898a005deff2f7d3"><td class="memTemplParams" colspan="2">template&lt;class Geometry , class Matrix , class Container &gt; </td></tr>
<tr class="memitem:gaa772c365c9f05b66898a005deff2f7d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrixoperators.html#gaa772c365c9f05b66898a005deff2f7d3">dg::Variation</a> = <a class="el" href="classdg_1_1_gradient.html">Gradient</a>&lt; Geometry, Matrix, Container &gt;</td></tr>
<tr class="memdesc:gaa772c365c9f05b66898a005deff2f7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator.  <a href="group__matrixoperators.html#gaa772c365c9f05b66898a005deff2f7d3">More...</a><br /></td></tr>
<tr class="separator:gaa772c365c9f05b66898a005deff2f7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aac7f1906c500a682abb8b98a836807"><td class="memTemplParams" colspan="2">template&lt;class Geometry , class Matrix , class Container &gt; </td></tr>
<tr class="memitem:ga3aac7f1906c500a682abb8b98a836807"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrixoperators.html#ga3aac7f1906c500a682abb8b98a836807">dg::Variation2d</a> = <a class="el" href="classdg_1_1_gradient.html">Gradient</a>&lt; Geometry, Matrix, Container &gt;</td></tr>
<tr class="memdesc:ga3aac7f1906c500a682abb8b98a836807"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator.  <a href="group__matrixoperators.html#ga3aac7f1906c500a682abb8b98a836807">More...</a><br /></td></tr>
<tr class="separator:ga3aac7f1906c500a682abb8b98a836807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7cf53900257e6b0ea15dfc26616816"><td class="memTemplParams" colspan="2">template&lt;class Geometry , class Matrix , class Container &gt; </td></tr>
<tr class="memitem:gafd7cf53900257e6b0ea15dfc26616816"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrixoperators.html#gafd7cf53900257e6b0ea15dfc26616816">dg::Variation3d</a> = <a class="el" href="classdg_1_1_gradient3d.html">Gradient3d</a>&lt; Geometry, Matrix, Container &gt;</td></tr>
<tr class="memdesc:gafd7cf53900257e6b0ea15dfc26616816"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator.  <a href="group__matrixoperators.html#gafd7cf53900257e6b0ea15dfc26616816">More...</a><br /></td></tr>
<tr class="separator:gafd7cf53900257e6b0ea15dfc26616816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e96ca43b1ba76d3f820afc72b1d753"><td class="memTemplParams" colspan="2">template&lt;class Geometry , class Matrix , class Container &gt; </td></tr>
<tr class="memitem:ga97e96ca43b1ba76d3f820afc72b1d753"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrixoperators.html#ga97e96ca43b1ba76d3f820afc72b1d753">dg::Helmholtz2d</a> = <a class="el" href="structdg_1_1_helmholtz.html">Helmholtz</a>&lt; Geometry, Matrix, Container &gt;</td></tr>
<tr class="memdesc:ga97e96ca43b1ba76d3f820afc72b1d753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class that represents a Helmholtz-type operator \( (\chi+\alpha\Delta) \).  <a href="group__matrixoperators.html#ga97e96ca43b1ba76d3f820afc72b1d753">More...</a><br /></td></tr>
<tr class="separator:ga97e96ca43b1ba76d3f820afc72b1d753"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Gradient \( \chi\cdot\nabla f\), Elliptic \( -\nabla\cdot (\chi \nabla f)\) and Helmholtz \( (\chi + \alpha \Delta) f\). </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gae40a319b095c51491395216d59fd8645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40a319b095c51491395216d59fd8645">&#9670;&nbsp;</a></span>Elliptic2d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__matrixoperators.html#gae40a319b095c51491395216d59fd8645">dg::Elliptic2d</a> = typedef <a class="el" href="classdg_1_1_elliptic.html">Elliptic</a>&lt;Geometry, Matrix, Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2d negative elliptic differential operator \( -\nabla \cdot ( \chi \nabla ) \). </p>
<p>The term discretized is </p><p class="formulaDsp">
\[ -\nabla \cdot ( \chi \nabla ) \]
</p>
<p> where \( \nabla \) is the two-dimensional nabla and \(\chi\) is a (possibly spatially dependent) tensor. In general coordinates that means </p><p class="formulaDsp">
\[ -\frac{1}{\sqrt{g}}\left( \partial_x\left(\sqrt{g}\left(\chi^{xx}\partial_x + \chi^{xy}\partial_y \right)\right) + \partial_y\left(\sqrt{g} \left(\chi^{yx}\partial_x + \chi^{yy}\partial_y \right)\right) \right)\]
</p>
<p> is discretized. Per default, \( \chi\) is the metric tensor but you can set it to any tensor you like (in order for the operator to be invertible \(\chi\) should be symmetric and positive definite though). Note that the local discontinuous Galerkin discretization adds so-called jump terms </p><p class="formulaDsp">
\[ D^\dagger \chi D + \alpha \chi_{on/off} J \]
</p>
<p> where \(\alpha\) is a scale factor ( = jfactor), \( D \) contains the discretizations of the above derivatives, and \( J\) is a self-adjoint matrix. (The symmetric part of \(J\) is added <b>before</b> the volume element is divided). The adjoint of a matrix is defined with respect to the volume element including dG weights. Usually, the default \( \alpha=1 \) is a good choice. However, in some cases, e.g. when \( \chi \) exhibits very large variations \( \alpha=0.1\) or \( \alpha=0.01\) might be better values. In a time dependent problem the value of \(\alpha\) determines the numerical diffusion, i.e. for too low values numerical oscillations may appear. The \( \chi_{on/off} \) in the jump term serves to weight the jump term with \( \chi \). This can be switched either on or off with off being the default. Also note that a forward discretization has more diffusion than a centered discretization.</p>
<p>The following code snippet demonstrates the use of <code><a class="el" href="classdg_1_1_elliptic.html" title="A 2d negative elliptic differential operator .">Elliptic</a></code> in an inversion problem </p><div class="fragment"><div class="line">    <span class="comment">//create an Elliptic object without volume form (not normed)</span></div>
<div class="line">    <a class="code" href="classdg_1_1_elliptic.html">dg::Elliptic&lt;dg::CartesianGrid2d, dg::DMatrix, dg::DVec&gt;</a> pol_forward( grid, <a class="code" href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066">dg::not_normed</a>, <a class="code" href="group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>, jfactor);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Set the chi function (chi is a dg::DVec of size grid.size())</span></div>
<div class="line">    pol_forward.set_chi( chi);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//construct an invert object</span></div>
<div class="line">    <a class="code" href="structdg_1_1_invert.html">dg::Invert&lt;dg::DVec &gt;</a> invert_fw( x, n*n*Nx*Ny, eps);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//invert the elliptic equation</span></div>
<div class="line">    invert_fw( pol_forward, x, b, w2d, v2d, chi_inv);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//compute the error (solution contains analytic solution</span></div>
<div class="line">    <a class="code" href="group__blas1.html#ga5c7ddbf70dd74867e45c9d4f40b36cf7">dg::blas1::axpby</a>( 1.,x,-1., solution, error);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//compute the L2 norm of the error</span></div>
<div class="line">    <span class="keywordtype">double</span> err = <a class="code" href="group__blas2.html#gaaafba91956e948b0ea53f30889a3c20d">dg::blas2::dot</a>( w2d, error);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//output the relative error</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span>&lt;&lt;sqrt( err/<a class="code" href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">norm</a>) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>A type that is or derives from one of the abstract geometry base classes ( <code>aGeometry2d</code>, <code>aGeometry3d</code>, <code>aMPIGeometry2d</code>, ...). <code>Geometry</code> determines which <code>Matrix</code> and <code>Container</code> types can be used: </td></tr>
    <tr><td class="paramname">Matrix</td><td>A class for which the <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions are callable in connection with the <code>Container</code> class and to which the return type of <code><a class="el" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85" title="Create 2d derivative in x-direction.">create::dx()</a></code> can be converted using <code><a class="el" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597" title="; Generic way to copy and/or convert a Matrix type to a different Matrix type">dg::blas2::transfer</a></code>. The <code>Matrix</code> type can be one of:<ul>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> and one of the MPI geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> and one of the MPI geometries </li>
</ul>
</td></tr>
    <tr><td class="paramname">Container</td><td>A data container class for which the <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functionality is overloaded and to which the return type of <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">blas1::subroutine()</a></code> can be converted using <code><a class="el" href="group__backend.html#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code>. We assume that <code>Container</code> is copyable/assignable and has a swap member function. In connection with <code>Geometry</code> this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> when <code>Geometry</code> is a shared memory geometry</li>
<li><code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> when <code>Geometry</code> is one of the MPI geometries This class has the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> so it can be used in <a class="el" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">blas2::symv</a> functions and thus in a conjugate gradient solver. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The constructors initialize \( \chi=g\) so that a negative laplacian operator results </dd>
<dd>
The inverse of \( \chi\) makes a good general purpose preconditioner </dd>
<dd>
the jump term \( \alpha J\) adds artificial numerical diffusion as discussed above </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Pay attention to the negative sign which is necessary to make the matrix <b>positive</b> <b>definite</b> </dd></dl>

</div>
</div>
<a id="ga2bfec765ddaa27750c6ddae6227e875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bfec765ddaa27750c6ddae6227e875c">&#9670;&nbsp;</a></span>Gradient2d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__matrixoperators.html#ga2bfec765ddaa27750c6ddae6227e875c">dg::Gradient2d</a> = typedef <a class="el" href="classdg_1_1_gradient.html">Gradient</a>&lt;Geometry, Matrix, Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator. </p>
<p>The terms discretized are the gradient </p><p class="formulaDsp">
\[\chi\cdot\nabla\]
</p>
<p> and the variation </p><p class="formulaDsp">
\[ \nabla\phi \cdot \chi \nabla\phi\]
</p>
<p> where \( \nabla \) is the two-dimensional nabla and \(\chi\) is a tensor (usually the metric).</p>
<p>In general coordinates that means </p><p class="formulaDsp">
\[\chi\cdot\nabla = \left(\chi^{xx}\partial_x + \chi^{xy}\partial_y \right) + \left(\chi^{yx}\partial_x + \chi^{yy}\partial_y \right) \]
</p>
<p> is discretized. Per default, \( \chi\) is the metric tensor but you can set it to any tensor you like.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>A type that is or derives from one of the abstract geometry base classes ( <code>aGeometry2d</code>, <code>aGeometry3d</code>, <code>aMPIGeometry2d</code>, ...). <code>Geometry</code> determines which <code>Matrix</code> and <code>Container</code> types can be used: </td></tr>
    <tr><td class="paramname">Matrix</td><td>A class for which the <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions are callable in connection with the <code>Container</code> class and to which the return type of <code><a class="el" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85" title="Create 2d derivative in x-direction.">create::dx()</a></code> can be converted using <code><a class="el" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597" title="; Generic way to copy and/or convert a Matrix type to a different Matrix type">dg::blas2::transfer</a></code>. The <code>Matrix</code> type can be one of:<ul>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> and one of the MPI geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> and one of the MPI geometries </li>
</ul>
</td></tr>
    <tr><td class="paramname">Container</td><td>A data container class for which the <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functionality is overloaded and to which the return type of <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">blas1::subroutine()</a></code> can be converted using <code><a class="el" href="group__backend.html#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code>. We assume that <code>Container</code> is copyable/assignable and has a swap member function. In connection with <code>Geometry</code> this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> when <code>Geometry</code> is a shared memory geometry</li>
<li><code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> when <code>Geometry</code> is one of the MPI geometries </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The constructors initialize \( \chi=g\) so that a traditional gradient results </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This a convenience class that saves you the construction of derivatives, the metric and temporary storage and 3 lines of application code. It is often more efficient to compute the simple derivatives of a vector yourself, because you can re-use them in other places; the same goes for the storage of the metric tensor, it often can be re-used at other places. To compute the above expressions you then simply use the relevant tensor functions <code><a class="el" href="group__tensor.html#ga6177f4d0f3a84f07caab5aa61653f779">dg::tensor::multiply2d</a></code> and <code><a class="el" href="group__tensor.html#ga474649ce3a4de2b2830eedcbfea609f7">dg::tensor::scalar_product2d</a></code> </dd></dl>

</div>
</div>
<a id="ga97e96ca43b1ba76d3f820afc72b1d753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97e96ca43b1ba76d3f820afc72b1d753">&#9670;&nbsp;</a></span>Helmholtz2d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__matrixoperators.html#ga97e96ca43b1ba76d3f820afc72b1d753">dg::Helmholtz2d</a> = typedef <a class="el" href="structdg_1_1_helmholtz.html">Helmholtz</a>&lt;Geometry, Matrix, Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix class that represents a Helmholtz-type operator \( (\chi+\alpha\Delta) \). </p>
<p>Unnormed discretization of </p><p class="formulaDsp">
\[ (\chi+\alpha\Delta) \]
</p>
<p> where \( \chi\) is a function and \(\alpha\) a scalar. </p><dl class="section attention"><dt>Attention</dt><dd>The Laplacian in this formula is positive as opposed to the negative sign in the <code><a class="el" href="classdg_1_1_elliptic.html" title="A 2d negative elliptic differential operator .">Elliptic</a></code> operator</dd></dl>
<p>Can be used by the <a class="el" href="classdg_1_1_c_g.html" title="Preconditioned conjugate gradient method to solve.">CG</a> class. The following example shows how the class can be used to act as a <code><a class="el" href="structdg_1_1_helmholtz2.html" title="DEPRECATED, Matrix class that represents a more general Helmholtz-type operator.">Helmholtz2</a></code> operator: </p><div class="fragment"><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Alternative test with two Helmholtz operators\n&quot;</span>;</div>
<div class="line">    <a class="code" href="structdg_1_1_helmholtz.html">dg::Helmholtz&lt; dg::CartesianGrid2d, dg::DMatrix, dg::DVec &gt;</a> gamma1inv(grid2d, alpha ,<a class="code" href="group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>);</div>
<div class="line">    gamma1inv.set_chi( chi);</div>
<div class="line">    <a class="code" href="structdg_1_1_invert.html">dg::Invert&lt;dg::DVec&gt;</a> invertO(  x, grid2d.size(), eps/100);</div>
<div class="line">    <a class="code" href="structdg_1_1_invert.html">dg::Invert&lt;dg::DVec&gt;</a> invertOO( x, grid2d.size(), eps/100);</div>
<div class="line">    t.tic();</div>
<div class="line">    <span class="keywordtype">unsigned</span> number1 = invertO( gamma1inv, phi, rholap);</div>
<div class="line">    <a class="code" href="group__blas1.html#gad2dcd7cffe760b7bacfdd7647d86e602">dg::blas1::pointwiseDot</a>( phi, chi, phi);</div>
<div class="line">    <span class="keywordtype">unsigned</span> number2 = invertOO( gamma1inv, x, phi);</div>
<div class="line">    t.toc();</div>
<div class="line">    <span class="comment">//Evaluation</span></div>
<div class="line">    <a class="code" href="group__blas1.html#ga5c7ddbf70dd74867e45c9d4f40b36cf7">dg::blas1::axpby</a>( 1., sol, -1., x);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>A type that is or derives from one of the abstract geometry base classes ( <code>aGeometry2d</code>, <code>aGeometry3d</code>, <code>aMPIGeometry2d</code>, ...). <code>Geometry</code> determines which <code>Matrix</code> and <code>Container</code> types can be used: </td></tr>
    <tr><td class="paramname">Matrix</td><td>A class for which the <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions are callable in connection with the <code>Container</code> class and to which the return type of <code><a class="el" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85" title="Create 2d derivative in x-direction.">create::dx()</a></code> can be converted using <code><a class="el" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597" title="; Generic way to copy and/or convert a Matrix type to a different Matrix type">dg::blas2::transfer</a></code>. The <code>Matrix</code> type can be one of:<ul>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> and one of the MPI geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> and one of the MPI geometries </li>
</ul>
</td></tr>
    <tr><td class="paramname">Container</td><td>A data container class for which the <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functionality is overloaded and to which the return type of <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">blas1::subroutine()</a></code> can be converted using <code><a class="el" href="group__backend.html#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code>. We assume that <code>Container</code> is copyable/assignable and has a swap member function. In connection with <code>Geometry</code> this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> when <code>Geometry</code> is a shared memory geometry</li>
<li><code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> when <code>Geometry</code> is one of the MPI geometries </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa772c365c9f05b66898a005deff2f7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa772c365c9f05b66898a005deff2f7d3">&#9670;&nbsp;</a></span>Variation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__matrixoperators.html#gaa772c365c9f05b66898a005deff2f7d3">dg::Variation</a> = typedef <a class="el" href="classdg_1_1_gradient.html">Gradient</a>&lt;Geometry,Matrix,Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator. </p>
<p>The terms discretized are the gradient </p><p class="formulaDsp">
\[\chi\cdot\nabla\]
</p>
<p> and the variation </p><p class="formulaDsp">
\[ \nabla\phi \cdot \chi \nabla\phi\]
</p>
<p> where \( \nabla \) is the two-dimensional nabla and \(\chi\) is a tensor (usually the metric).</p>
<p>In general coordinates that means </p><p class="formulaDsp">
\[\chi\cdot\nabla = \left(\chi^{xx}\partial_x + \chi^{xy}\partial_y \right) + \left(\chi^{yx}\partial_x + \chi^{yy}\partial_y \right) \]
</p>
<p> is discretized. Per default, \( \chi\) is the metric tensor but you can set it to any tensor you like.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>A type that is or derives from one of the abstract geometry base classes ( <code>aGeometry2d</code>, <code>aGeometry3d</code>, <code>aMPIGeometry2d</code>, ...). <code>Geometry</code> determines which <code>Matrix</code> and <code>Container</code> types can be used: </td></tr>
    <tr><td class="paramname">Matrix</td><td>A class for which the <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions are callable in connection with the <code>Container</code> class and to which the return type of <code><a class="el" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85" title="Create 2d derivative in x-direction.">create::dx()</a></code> can be converted using <code><a class="el" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597" title="; Generic way to copy and/or convert a Matrix type to a different Matrix type">dg::blas2::transfer</a></code>. The <code>Matrix</code> type can be one of:<ul>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> and one of the MPI geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> and one of the MPI geometries </li>
</ul>
</td></tr>
    <tr><td class="paramname">Container</td><td>A data container class for which the <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functionality is overloaded and to which the return type of <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">blas1::subroutine()</a></code> can be converted using <code><a class="el" href="group__backend.html#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code>. We assume that <code>Container</code> is copyable/assignable and has a swap member function. In connection with <code>Geometry</code> this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> when <code>Geometry</code> is a shared memory geometry</li>
<li><code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> when <code>Geometry</code> is one of the MPI geometries </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The constructors initialize \( \chi=g\) so that a traditional gradient results </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This a convenience class that saves you the construction of derivatives, the metric and temporary storage and 3 lines of application code. It is often more efficient to compute the simple derivatives of a vector yourself, because you can re-use them in other places; the same goes for the storage of the metric tensor, it often can be re-used at other places. To compute the above expressions you then simply use the relevant tensor functions <code><a class="el" href="group__tensor.html#ga6177f4d0f3a84f07caab5aa61653f779">dg::tensor::multiply2d</a></code> and <code><a class="el" href="group__tensor.html#ga474649ce3a4de2b2830eedcbfea609f7">dg::tensor::scalar_product2d</a></code> </dd></dl>

</div>
</div>
<a id="ga3aac7f1906c500a682abb8b98a836807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aac7f1906c500a682abb8b98a836807">&#9670;&nbsp;</a></span>Variation2d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__matrixoperators.html#ga3aac7f1906c500a682abb8b98a836807">dg::Variation2d</a> = typedef <a class="el" href="classdg_1_1_gradient.html">Gradient</a>&lt;Geometry,Matrix,Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator. </p>
<p>The terms discretized are the gradient </p><p class="formulaDsp">
\[\chi\cdot\nabla\]
</p>
<p> and the variation </p><p class="formulaDsp">
\[ \nabla\phi \cdot \chi \nabla\phi\]
</p>
<p> where \( \nabla \) is the two-dimensional nabla and \(\chi\) is a tensor (usually the metric).</p>
<p>In general coordinates that means </p><p class="formulaDsp">
\[\chi\cdot\nabla = \left(\chi^{xx}\partial_x + \chi^{xy}\partial_y \right) + \left(\chi^{yx}\partial_x + \chi^{yy}\partial_y \right) \]
</p>
<p> is discretized. Per default, \( \chi\) is the metric tensor but you can set it to any tensor you like.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>A type that is or derives from one of the abstract geometry base classes ( <code>aGeometry2d</code>, <code>aGeometry3d</code>, <code>aMPIGeometry2d</code>, ...). <code>Geometry</code> determines which <code>Matrix</code> and <code>Container</code> types can be used: </td></tr>
    <tr><td class="paramname">Matrix</td><td>A class for which the <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions are callable in connection with the <code>Container</code> class and to which the return type of <code><a class="el" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85" title="Create 2d derivative in x-direction.">create::dx()</a></code> can be converted using <code><a class="el" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597" title="; Generic way to copy and/or convert a Matrix type to a different Matrix type">dg::blas2::transfer</a></code>. The <code>Matrix</code> type can be one of:<ul>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> and one of the MPI geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> and one of the MPI geometries </li>
</ul>
</td></tr>
    <tr><td class="paramname">Container</td><td>A data container class for which the <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functionality is overloaded and to which the return type of <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">blas1::subroutine()</a></code> can be converted using <code><a class="el" href="group__backend.html#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code>. We assume that <code>Container</code> is copyable/assignable and has a swap member function. In connection with <code>Geometry</code> this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> when <code>Geometry</code> is a shared memory geometry</li>
<li><code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> when <code>Geometry</code> is one of the MPI geometries </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The constructors initialize \( \chi=g\) so that a traditional gradient results </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This a convenience class that saves you the construction of derivatives, the metric and temporary storage and 3 lines of application code. It is often more efficient to compute the simple derivatives of a vector yourself, because you can re-use them in other places; the same goes for the storage of the metric tensor, it often can be re-used at other places. To compute the above expressions you then simply use the relevant tensor functions <code><a class="el" href="group__tensor.html#ga6177f4d0f3a84f07caab5aa61653f779">dg::tensor::multiply2d</a></code> and <code><a class="el" href="group__tensor.html#ga474649ce3a4de2b2830eedcbfea609f7">dg::tensor::scalar_product2d</a></code> </dd></dl>

</div>
</div>
<a id="gafd7cf53900257e6b0ea15dfc26616816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd7cf53900257e6b0ea15dfc26616816">&#9670;&nbsp;</a></span>Variation3d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class Matrix , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__matrixoperators.html#gafd7cf53900257e6b0ea15dfc26616816">dg::Variation3d</a> = typedef <a class="el" href="classdg_1_1_gradient3d.html">Gradient3d</a>&lt;Geometry,Matrix,Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3d gradient \(\chi\cdot\nabla\) and variation \( \nabla\phi \cdot \chi \nabla\phi\) operator. </p>
<p>The terms discretized are the gradient \(\chi\cdot\nabla\) and the variation </p><p class="formulaDsp">
\[ \nabla\phi \cdot \chi \nabla\phi\]
</p>
<p> where \( \mathbf \chi \) is a tensor (usually the metric). In general coordinates that means </p><p class="formulaDsp">
\[ \chi\cdot\nabla = \left(\chi^{xx}\partial_x + \chi^{xy}\partial_y + \chi^{xz}\partial_z \right) + \left(\chi^{yx}\partial_x + \chi^{yy}\partial_y + \chi^{yz}\partial_z \right) + \left(\chi^{zx}\partial_x + \chi^{zy}\partial_y + \chi^{zz}\partial_z \right) \]
</p>
<p> Per default, \( \chi\) is the metric tensor but you can set it to any tensor you like.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>A type that is or derives from one of the abstract geometry base classes ( <code>aGeometry2d</code>, <code>aGeometry3d</code>, <code>aMPIGeometry2d</code>, ...). <code>Geometry</code> determines which <code>Matrix</code> and <code>Container</code> types can be used: </td></tr>
    <tr><td class="paramname">Matrix</td><td>A class for which the <a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a> functions are callable in connection with the <code>Container</code> class and to which the return type of <code><a class="el" href="group__creation.html#ga51aea0f47c5a77bb1a3bce187839dc85" title="Create 2d derivative in x-direction.">create::dx()</a></code> can be converted using <code><a class="el" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597" title="; Generic way to copy and/or convert a Matrix type to a different Matrix type">dg::blas2::transfer</a></code>. The <code>Matrix</code> type can be one of:<ul>
<li><code><a class="el" href="group__typedefs.html#gac2134505608b45616787fdb2f6eedc87" title="Host Matrix for derivatives.">dg::HMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gafdf2ecb95cbc87a1544136d28d535f16" title="Device Matrix for derivatives.">dg::DMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaff79c734c7916054c7dc24e6bc437161" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> and one of the MPI geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaad32454aa2aca3cbb93448d7b5daf005" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> and one of the MPI geometries </li>
</ul>
</td></tr>
    <tr><td class="paramname">Container</td><td>A data container class for which the <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functionality is overloaded and to which the return type of <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">blas1::subroutine()</a></code> can be converted using <code><a class="el" href="group__backend.html#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code>. We assume that <code>Container</code> is copyable/assignable and has a swap member function. In connection with <code>Geometry</code> this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> when <code>Geometry</code> is a shared memory geometry</li>
<li><code><a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> when <code>Geometry</code> is one of the MPI geometries </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The constructors initialize \( \chi=g\) so that a traditional gradient results </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This a convenience class that saves you the construction of derivatives, the metric and temporary storage and 7 lines of application code. It is often more efficient to compute the simple derivatives of a vector yourself, because you can re-use them in other places; the same goes for the storage of the metric tensor, it often can be re-used at other places. To compute the above expressions you then simply use the relevant tensor functions <code><a class="el" href="group__tensor.html#gab5d5a1bbeeb51ef4d01ac3fc9fe973d2">dg::tensor::multiply3d</a></code> and <code><a class="el" href="group__tensor.html#gac94822bd38b36e094bf11070a9fa2fff">dg::tensor::scalar_product3d</a></code> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__blas2_html_gaaafba91956e948b0ea53f30889a3c20d"><div class="ttname"><a href="group__blas2.html#gaaafba91956e948b0ea53f30889a3c20d">dg::blas2::dot</a></div><div class="ttdeci">get_value_type&lt; MatrixType &gt; dot(const ContainerType1 &amp;x, const MatrixType &amp;m, const ContainerType2 &amp;y)</div><div class="ttdoc">; Binary reproducible general dot product</div><div class="ttdef"><b>Definition:</b> blas2.h:84</div></div>
<div class="ttc" id="agroup__blas1_html_ga5c7ddbf70dd74867e45c9d4f40b36cf7"><div class="ttname"><a href="group__blas1.html#ga5c7ddbf70dd74867e45c9d4f40b36cf7">dg::blas1::axpby</a></div><div class="ttdeci">void axpby(get_value_type&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x, get_value_type&lt; ContainerType &gt; beta, ContainerType &amp;y)</div><div class="ttdef"><b>Definition:</b> blas1.h:195</div></div>
<div class="ttc" id="agroup__creation_html_gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066"><div class="ttname"><a href="group__creation.html#gga9945b71a335bc97f78dc7425911c7287a07217e3dd9be28b4da85d46fef38f066">dg::not_normed</a></div><div class="ttdeci">@ not_normed</div><div class="ttdoc">indicates that normalisation weights (either T or V) are missing from output</div><div class="ttdef"><b>Definition:</b> enums.h:99</div></div>
<div class="ttc" id="astructdg_1_1_invert_html"><div class="ttname"><a href="structdg_1_1_invert.html">dg::Invert</a></div><div class="ttdoc">Wrapper around CG and Extrapolation to solve the Equation.</div><div class="ttdef"><b>Definition:</b> cg.h:489</div></div>
<div class="ttc" id="aclassdg_1_1_elliptic_html"><div class="ttname"><a href="classdg_1_1_elliptic.html">dg::Elliptic</a></div><div class="ttdoc">A 2d negative elliptic differential operator .</div><div class="ttdef"><b>Definition:</b> elliptic.h:62</div></div>
<div class="ttc" id="agroup__creation_html_ga9945b71a335bc97f78dc7425911c7287"><div class="ttname"><a href="group__creation.html#ga9945b71a335bc97f78dc7425911c7287">dg::norm</a></div><div class="ttdeci">norm</div><div class="ttdoc">Switch between normalisations.</div><div class="ttdef"><b>Definition:</b> enums.h:97</div></div>
<div class="ttc" id="astructdg_1_1_helmholtz_html"><div class="ttname"><a href="structdg_1_1_helmholtz.html">dg::Helmholtz</a></div><div class="ttdoc">Matrix class that represents a Helmholtz-type operator .</div><div class="ttdef"><b>Definition:</b> helmholtz.h:28</div></div>
<div class="ttc" id="agroup__creation_html_ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df"><div class="ttname"><a href="group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a></div><div class="ttdeci">@ centered</div><div class="ttdoc">centered derivative (cell to the left and right and current cell)</div><div class="ttdef"><b>Definition:</b> enums.h:106</div></div>
<div class="ttc" id="agroup__blas1_html_gad2dcd7cffe760b7bacfdd7647d86e602"><div class="ttname"><a href="group__blas1.html#gad2dcd7cffe760b7bacfdd7647d86e602">dg::blas1::pointwiseDot</a></div><div class="ttdeci">void pointwiseDot(get_value_type&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, get_value_type&lt; ContainerType &gt; beta, ContainerType &amp;y)</div><div class="ttdef"><b>Definition:</b> blas1.h:297</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 16 2021 01:15:31 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
