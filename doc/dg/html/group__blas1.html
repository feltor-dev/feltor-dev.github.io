<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Discontinuous Galerkin Library: BLAS level 1 routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="tablist"> 
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dG</a></li>
    <li><a href="../../geometries/html/modules.html">geometries</a></li>
    <li><a href="../../file/html/namespacefile.html">file</a></li>
    <li><a href="../../exblas/html/namespaceexblas.html">exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Discontinuous Galerkin numerical methods and container free numerical algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__blas1.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BLAS level 1 routines<div class="ingroups"><a class="el" href="group__backend.html">Level 1: Vectors, Matrices and basic operations</a> &raquo; <a class="el" href="group__blas.html">Basic Linear Algebra Subroutines</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for BLAS level 1 routines:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__blas1.png" border="0" alt="" usemap="#group____blas1"/>
<map name="group____blas1" id="group____blas1">
<area shape="rect" id="node2" href="group__blas.html" title="Basic Linear Algebra\l Subroutines" alt="" coords="5,5,148,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedg_1_1blas1"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1blas1.html">dg::blas1</a></td></tr>
<tr class="memdesc:namespacedg_1_1blas1"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 1 routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad325c39d1994561ee38813a2dde7a46a"><td class="memTemplParams" colspan="2">template&lt;class container , class other_container &gt; </td></tr>
<tr class="memitem:gad325c39d1994561ee38813a2dde7a46a"><td class="memTemplItemLeft" align="right" valign="top">container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gad325c39d1994561ee38813a2dde7a46a">dg::blas1::transfer</a> (const other_container &amp;x)</td></tr>
<tr class="memdesc:gad325c39d1994561ee38813a2dde7a46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">y=x; Generic way to copy/construct and/or convert a container type from a different container type (e.g. from CPU to GPU, or double to float, etc.)  <a href="group__blas1.html#gad325c39d1994561ee38813a2dde7a46a">More...</a><br /></td></tr>
<tr class="separator:gad325c39d1994561ee38813a2dde7a46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794da3a01565570dcdc17bfb06594ce2"><td class="memTemplParams" colspan="2">template&lt;class container , class other_container &gt; </td></tr>
<tr class="memitem:ga794da3a01565570dcdc17bfb06594ce2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga794da3a01565570dcdc17bfb06594ce2">dg::blas1::transfer</a> (const other_container &amp;x, container &amp;y)</td></tr>
<tr class="memdesc:ga794da3a01565570dcdc17bfb06594ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">y=x; Generic way to copy/assign and/or convert a container type to a different container type (e.g. from CPU to GPU, or double to float, etc.)  <a href="group__blas1.html#ga794da3a01565570dcdc17bfb06594ce2">More...</a><br /></td></tr>
<tr class="separator:ga794da3a01565570dcdc17bfb06594ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69cf7352ad8c173980801da73c9c6bc"><td class="memTemplParams" colspan="2">template&lt;class Assignable &gt; </td></tr>
<tr class="memitem:gad69cf7352ad8c173980801da73c9c6bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gad69cf7352ad8c173980801da73c9c6bc">dg::blas1::copy</a> (const Assignable &amp;x, Assignable &amp;y)</td></tr>
<tr class="memdesc:gad69cf7352ad8c173980801da73c9c6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">y=x; Invoke assignment operator  <a href="group__blas1.html#gad69cf7352ad8c173980801da73c9c6bc">More...</a><br /></td></tr>
<tr class="separator:gad69cf7352ad8c173980801da73c9c6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0031efa80aca7de577bdd8063e12e457"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:ga0031efa80aca7de577bdd8063e12e457"><td class="memTemplItemLeft" align="right" valign="top">get_value_type&lt; container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga0031efa80aca7de577bdd8063e12e457">dg::blas1::dot</a> (const container &amp;x, const container &amp;y)</td></tr>
<tr class="memdesc:ga0031efa80aca7de577bdd8063e12e457"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x^T y\); Binary reproducible Euclidean dot product between two containers  <a href="group__blas1.html#ga0031efa80aca7de577bdd8063e12e457">More...</a><br /></td></tr>
<tr class="separator:ga0031efa80aca7de577bdd8063e12e457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35427a456cd09d5ec8e5ed97378933c"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:gaf35427a456cd09d5ec8e5ed97378933c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gaf35427a456cd09d5ec8e5ed97378933c">dg::blas1::axpby</a> (get_value_type&lt; container &gt; alpha, const container &amp;x, get_value_type&lt; container &gt; beta, container &amp;y)</td></tr>
<tr class="memdesc:gaf35427a456cd09d5ec8e5ed97378933c"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x + \beta y\)  <a href="group__blas1.html#gaf35427a456cd09d5ec8e5ed97378933c">More...</a><br /></td></tr>
<tr class="separator:gaf35427a456cd09d5ec8e5ed97378933c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55b0bddbf60013b756caa1a903aa8de"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:gac55b0bddbf60013b756caa1a903aa8de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gac55b0bddbf60013b756caa1a903aa8de">dg::blas1::axpby</a> (get_value_type&lt; container &gt; alpha, const container &amp;x, get_value_type&lt; container &gt; beta, const container &amp;y, container &amp;z)</td></tr>
<tr class="memdesc:gac55b0bddbf60013b756caa1a903aa8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( z = \alpha x + \beta y\)  <a href="group__blas1.html#gac55b0bddbf60013b756caa1a903aa8de">More...</a><br /></td></tr>
<tr class="separator:gac55b0bddbf60013b756caa1a903aa8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7746f633c737e575df834428a4c89731"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:ga7746f633c737e575df834428a4c89731"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga7746f633c737e575df834428a4c89731">dg::blas1::axpbypgz</a> (get_value_type&lt; container &gt; alpha, const container &amp;x, get_value_type&lt; container &gt; beta, const container &amp;y, get_value_type&lt; container &gt; gamma, container &amp;z)</td></tr>
<tr class="memdesc:ga7746f633c737e575df834428a4c89731"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( z = \alpha x + \beta y + \gamma z\)  <a href="group__blas1.html#ga7746f633c737e575df834428a4c89731">More...</a><br /></td></tr>
<tr class="separator:ga7746f633c737e575df834428a4c89731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf23bcda76d2363fa2e08d03fec28714a"><td class="memTemplParams" colspan="2">template&lt;class container , class UnaryOp &gt; </td></tr>
<tr class="memitem:gaf23bcda76d2363fa2e08d03fec28714a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gaf23bcda76d2363fa2e08d03fec28714a">dg::blas1::transform</a> (const container &amp;x, container &amp;y, UnaryOp op)</td></tr>
<tr class="memdesc:gaf23bcda76d2363fa2e08d03fec28714a"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = op(x)\)  <a href="group__blas1.html#gaf23bcda76d2363fa2e08d03fec28714a">More...</a><br /></td></tr>
<tr class="separator:gaf23bcda76d2363fa2e08d03fec28714a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67242fc36cf08182cfaa10d358762362"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:ga67242fc36cf08182cfaa10d358762362"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga67242fc36cf08182cfaa10d358762362">dg::blas1::scal</a> (container &amp;x, get_value_type&lt; container &gt; alpha)</td></tr>
<tr class="memdesc:ga67242fc36cf08182cfaa10d358762362"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x = \alpha x\)  <a href="group__blas1.html#ga67242fc36cf08182cfaa10d358762362">More...</a><br /></td></tr>
<tr class="separator:ga67242fc36cf08182cfaa10d358762362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecd400c97f9d68ebf476f69722e05239"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:gaecd400c97f9d68ebf476f69722e05239"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gaecd400c97f9d68ebf476f69722e05239">dg::blas1::plus</a> (container &amp;x, get_value_type&lt; container &gt; alpha)</td></tr>
<tr class="memdesc:gaecd400c97f9d68ebf476f69722e05239"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x = x + \alpha \)  <a href="group__blas1.html#gaecd400c97f9d68ebf476f69722e05239">More...</a><br /></td></tr>
<tr class="separator:gaecd400c97f9d68ebf476f69722e05239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cbf8263c526bdc4714eb525e35879ff"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:ga9cbf8263c526bdc4714eb525e35879ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga9cbf8263c526bdc4714eb525e35879ff">dg::blas1::pointwiseDot</a> (const container &amp;x1, const container &amp;x2, container &amp;y)</td></tr>
<tr class="memdesc:ga9cbf8263c526bdc4714eb525e35879ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = x_1 x_2 \)  <a href="group__blas1.html#ga9cbf8263c526bdc4714eb525e35879ff">More...</a><br /></td></tr>
<tr class="separator:ga9cbf8263c526bdc4714eb525e35879ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0de8ee9be7931dcb9d26660466a29230"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:ga0de8ee9be7931dcb9d26660466a29230"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga0de8ee9be7931dcb9d26660466a29230">dg::blas1::pointwiseDot</a> (get_value_type&lt; container &gt; alpha, const container &amp;x1, const container &amp;x2, get_value_type&lt; container &gt; beta, container &amp;y)</td></tr>
<tr class="memdesc:ga0de8ee9be7931dcb9d26660466a29230"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x_1 x_2 + \beta y\)  <a href="group__blas1.html#ga0de8ee9be7931dcb9d26660466a29230">More...</a><br /></td></tr>
<tr class="separator:ga0de8ee9be7931dcb9d26660466a29230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32ccf29d94948f83f0f3ee2b90665703"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:ga32ccf29d94948f83f0f3ee2b90665703"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga32ccf29d94948f83f0f3ee2b90665703">dg::blas1::pointwiseDot</a> (get_value_type&lt; container &gt; alpha, const container &amp;x1, const container &amp;x2, const container &amp;x3, get_value_type&lt; container &gt; beta, container &amp;y)</td></tr>
<tr class="memdesc:ga32ccf29d94948f83f0f3ee2b90665703"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x_1 x_2 x_3 + \beta y\)  <a href="group__blas1.html#ga32ccf29d94948f83f0f3ee2b90665703">More...</a><br /></td></tr>
<tr class="separator:ga32ccf29d94948f83f0f3ee2b90665703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2385e9a3b9f16ee75370cd475cc2025"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:gad2385e9a3b9f16ee75370cd475cc2025"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gad2385e9a3b9f16ee75370cd475cc2025">dg::blas1::pointwiseDivide</a> (const container &amp;x1, const container &amp;x2, container &amp;y)</td></tr>
<tr class="memdesc:gad2385e9a3b9f16ee75370cd475cc2025"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = x_1/ x_2\)  <a href="group__blas1.html#gad2385e9a3b9f16ee75370cd475cc2025">More...</a><br /></td></tr>
<tr class="separator:gad2385e9a3b9f16ee75370cd475cc2025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac787da1f14314db8601544127016f98c"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:gac787da1f14314db8601544127016f98c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gac787da1f14314db8601544127016f98c">dg::blas1::pointwiseDivide</a> (get_value_type&lt; container &gt; alpha, const container &amp;x1, const container &amp;x2, get_value_type&lt; container &gt; beta, container &amp;y)</td></tr>
<tr class="memdesc:gac787da1f14314db8601544127016f98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x_1/ x_2 + \beta y \)  <a href="group__blas1.html#gac787da1f14314db8601544127016f98c">More...</a><br /></td></tr>
<tr class="separator:gac787da1f14314db8601544127016f98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca925b9c729d2af1a7ab96cdfa3c99d4"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:gaca925b9c729d2af1a7ab96cdfa3c99d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gaca925b9c729d2af1a7ab96cdfa3c99d4">dg::blas1::pointwiseDot</a> (get_value_type&lt; container &gt; alpha, const container &amp;x1, const container &amp;y1, get_value_type&lt; container &gt; beta, const container &amp;x2, const container &amp;y2, get_value_type&lt; container &gt; gamma, container &amp;z)</td></tr>
<tr class="memdesc:gaca925b9c729d2af1a7ab96cdfa3c99d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( z = \alpha x_1x_2 + \beta x_2y_2 + \gamma z\)  <a href="group__blas1.html#gaca925b9c729d2af1a7ab96cdfa3c99d4">More...</a><br /></td></tr>
<tr class="separator:gaca925b9c729d2af1a7ab96cdfa3c99d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This group contains Vector-Vector operations. Successive calls to blas routines are executed sequentially. A manual synchronization of threads or devices is never needed in an application using these functions. All functions returning a value block until the value is ready. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf35427a456cd09d5ec8e5ed97378933c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::axpby </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x + \beta y\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ y_i = \alpha x_i + \beta y_i \]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>container x may alias y </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">y</td><td>container y contains solution on output</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2), three(100,3);</div><div class="line"><a class="code" href="group__blas1.html#gaf35427a456cd09d5ec8e5ed97378933c">dg::blas1::axpby</a>( 2, two, 3., three); <span class="comment">//three[i] = 13 (2*2+3*3)</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gac55b0bddbf60013b756caa1a903aa8de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::axpby </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( z = \alpha x + \beta y\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ z_i = \alpha x_i + \beta y_i \]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>container x may alias z </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">y</td><td>container y may alias z </td></tr>
    <tr><td class="paramname">z</td><td>container z contains solution on output</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2), three(100,3), result(100);</div><div class="line"><a class="code" href="group__blas1.html#gaf35427a456cd09d5ec8e5ed97378933c">dg::blas1::axpby</a>( 2, two, 3., three, result); <span class="comment">//result[i] = 13 (2*2+3*3)</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7746f633c737e575df834428a4c89731"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::axpbypgz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( z = \alpha x + \beta y + \gamma z\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ z_i = \alpha x_i + \beta y_i + \gamma z_i \]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>container x may alias result </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">y</td><td>container y may alias result </td></tr>
    <tr><td class="paramname">gamma</td><td>Scalar </td></tr>
    <tr><td class="paramname">z</td><td>container contains solution on output</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two(100,2), five(100,5), result(100, 12);</div><div class="line"><a class="code" href="group__blas1.html#ga7746f633c737e575df834428a4c89731">dg::blas1::axpbypgz</a>( 2.5, two, 2., five, -3.,result);</div><div class="line"><span class="comment">//result[i] = -21 (2.5*2+2*5-3*12)</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad69cf7352ad8c173980801da73c9c6bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Assignable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::copy </td>
          <td>(</td>
          <td class="paramtype">const Assignable &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Assignable &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y=x; Invoke assignment operator </p>
<p>Same as y=x </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Assignable</td><td>any assignable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>in </td></tr>
    <tr><td class="paramname">y</td><td>out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0031efa80aca7de577bdd8063e12e457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">get_value_type&lt;container&gt; dg::blas1::dot </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x^T y\); Binary reproducible Euclidean dot product between two containers </p>
<p>This routine computes </p><p class="formulaDsp">
\[ x^T y = \sum_{i=0}^{N-1} x_i y_i \]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined. Our implementation guarantees binary reproducible results. The sum is computed with infinite precision and the result is rounded to the nearest double precision number. This is possible with the help of an adapted version of the <code><a class="elRef" doxygen="/home/matthias/Projekte/feltor/doc/exblas.tag:../../exblas/html/" href="../../exblas/html/namespaceexblas.html">exblas</a></code> library.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left container </td></tr>
    <tr><td class="paramname">y</td><td>Right container may alias x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar product as defined above </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. With mpi the result is broadcasted to all processes</dd></dl>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2), three(100,3);</div><div class="line"><span class="keywordtype">double</span> temp = <a class="code" href="group__blas1.html#ga0031efa80aca7de577bdd8063e12e457">dg::blas1::dot</a>( two, three); <span class="comment">//temp = 30 (5*(2*3))</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaecd400c97f9d68ebf476f69722e05239"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::plus </td>
          <td>(</td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x = x + \alpha \) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ x_i + \alpha \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>container x</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2);</div><div class="line"><a class="code" href="group__blas1.html#gaecd400c97f9d68ebf476f69722e05239">dg::blas1::plus</a>( two,  2. )); <span class="comment">//result[i] = 4.</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad2385e9a3b9f16ee75370cd475cc2025"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDivide </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = x_1/ x_2\) </p>
<p>Divides two vectors element by element: </p><p class="formulaDsp">
\[ y_i = x_{1i}/x_{2i}\]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>container x1 </td></tr>
    <tr><td class="paramname">x2</td><td>container x2 may alias x1 </td></tr>
    <tr><td class="paramname">y</td><td>container y contains result on output ( may alias x1 and/or x2)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2), three( 100,3), result(100);</div><div class="line"><a class="code" href="group__blas1.html#gad2385e9a3b9f16ee75370cd475cc2025">dg::blas1::pointwiseDivide</a>( two,  three, result );</div><div class="line"><span class="comment">//result[i] = -0.666... (2/3)</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gac787da1f14314db8601544127016f98c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x_1/ x_2 + \beta y \) </p>
<p>Divides two vectors element by element: </p><p class="formulaDsp">
\[ y_i = \alpha x_{1i}/x_{2i} + \beta y_i \]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>container x1 </td></tr>
    <tr><td class="paramname">x2</td><td>container x2 may alias x1 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">y</td><td>container y contains result on output ( may alias x1 and/or x2)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2), three( 100,3), result(100,1);</div><div class="line"><a class="code" href="group__blas1.html#gad2385e9a3b9f16ee75370cd475cc2025">dg::blas1::pointwiseDivide</a>( 3, two,  three, 5, result );</div><div class="line"><span class="comment">//result[i] = 7 (3*2/3+5*1)</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga9cbf8263c526bdc4714eb525e35879ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = x_1 x_2 \) </p>
<p>Multiplies two vectors element by element: </p><p class="formulaDsp">
\[ y_i = x_{1i}x_{2i}\]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>container x1 </td></tr>
    <tr><td class="paramname">x2</td><td>container x2 may alias x1 </td></tr>
    <tr><td class="paramname">y</td><td>container y contains result on output ( may alias x1 or x2)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2), three( 100,3), result(100);</div><div class="line"><a class="code" href="group__blas1.html#ga9cbf8263c526bdc4714eb525e35879ff">dg::blas1::pointwiseDot</a>( two,  three, result ); <span class="comment">//result[i] = 6.</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga0de8ee9be7931dcb9d26660466a29230"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x_1 x_2 + \beta y\) </p>
<p>Multiplies two vectors element by element: </p><p class="formulaDsp">
\[ y_i = \alpha x_{1i}x_{2i} + \beta y_i\]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>container x1 </td></tr>
    <tr><td class="paramname">x2</td><td>container x2 may alias x1 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">y</td><td>container y contains result on output ( may alias x1 or x2)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2), three( 100,3), result(100,6);</div><div class="line"><a class="code" href="group__blas1.html#ga9cbf8263c526bdc4714eb525e35879ff">dg::blas1::pointwiseDot</a>(2., two,  three, -4., result );</div><div class="line"><span class="comment">//result[i] = -12. (2*2*3-4*6)</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga32ccf29d94948f83f0f3ee2b90665703"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x_1 x_2 x_3 + \beta y\) </p>
<p>Multiplies three vectors element by element: </p><p class="formulaDsp">
\[ y_i = \alpha x_{1i}x_{2i}x_{3i} + \beta y_i\]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>container x1 </td></tr>
    <tr><td class="paramname">x2</td><td>container x2 may alias x1 </td></tr>
    <tr><td class="paramname">x3</td><td>container x3 may alias x1 and/or x2 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">y</td><td>container y contains result on output ( may alias x1,x2 or x3)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2), three( 100,3), four(100,4), result(100,6);</div><div class="line"><a class="code" href="group__blas1.html#ga9cbf8263c526bdc4714eb525e35879ff">dg::blas1::pointwiseDot</a>(2., two,  three, four, -4., result );</div><div class="line"><span class="comment">//result[i] = 24. (2*2*3*4-4*6)</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaca925b9c729d2af1a7ab96cdfa3c99d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\( z = \alpha x_1x_2 + \beta x_2y_2 + \gamma z\) </p>
<p>Multiplies and adds vectors element by element: </p><p class="formulaDsp">
\[ z_i = \alpha x_{1i}y_{1i} + \beta x_{2i}y_{2i} + \gamma z_i \]
</p>
<p> i iterates over <b>all</b> elements inside the container. If <code>container</code> has the <code><a class="el" href="structdg_1_1_vector_vector_tag.html" title="This tag indicates composition/recursion. ">VectorVectorTag</a></code>, i recursively loops over all entries. If the container sizes do not match, the result is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>container x1 </td></tr>
    <tr><td class="paramname">y1</td><td>container y1 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">x2</td><td>container x2 </td></tr>
    <tr><td class="paramname">y2</td><td>container y2 </td></tr>
    <tr><td class="paramname">gamma</td><td>scalar </td></tr>
    <tr><td class="paramname">z</td><td>container z contains result on output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>all aliases are allowed</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two(100,2), three(100,3), four(100,5), five(100,5), result(100,6);</div><div class="line"><a class="code" href="group__blas1.html#ga9cbf8263c526bdc4714eb525e35879ff">dg::blas1::pointwiseDot</a>(2., two,  three, -4., four, five, 2., result );</div><div class="line"><span class="comment">//result[i] = -56.</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga67242fc36cf08182cfaa10d358762362"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::scal </td>
          <td>(</td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gae80102017c720c7bd5e774b7cb5a4cb0">get_value_type</a>&lt; container &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x = \alpha x\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ \alpha x_i \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>container x</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2);</div><div class="line"><a class="code" href="group__blas1.html#ga67242fc36cf08182cfaa10d358762362">dg::blas1::scal</a>( two,  0.5 )); <span class="comment">//result[i] = 1.</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad325c39d1994561ee38813a2dde7a46a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container , class other_container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">container dg::blas1::transfer </td>
          <td>(</td>
          <td class="paramtype">const other_container &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y=x; Generic way to copy/construct and/or convert a container type from a different container type (e.g. from CPU to GPU, or double to float, etc.) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">other_container</td><td>another container type, must have the same data policy derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> as <code>container</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x converted to the new format </dd></dl>
<dl class="section note"><dt>Note</dt><dd>since this function is quite often used there is a higher level alias <code>dg::transfer</code> </dd>
<dd>
it is possible to transfer a container to a std::array&lt;container, N&gt; (all elements are initialized to container) but not a std::vector&lt;container&gt; (since the desired size of the std::vector cannot be known)</dd></dl>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> device = dg::tansfer&lt;dg::DVec&gt;( <a class="code" href="group__evaluation.html#ga7521f4acb4edaf2d7896d99f97e1ed9d">dg::evaluate</a>(<a class="code" href="group__functions.html#ga5797166cdb9d26408ea629f742534fa7">dg::one</a>, grid));</div><div class="line">std::array&lt;dg::DVec, 3&gt; device_arr = dg::transfer&lt;std::array&lt;dg::DVec, 3&gt;&gt;( <a class="code" href="group__evaluation.html#ga7521f4acb4edaf2d7896d99f97e1ed9d">dg::evaluate</a>( <a class="code" href="group__functions.html#ga5797166cdb9d26408ea629f742534fa7">dg::one</a>, grid));</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga794da3a01565570dcdc17bfb06594ce2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container , class other_container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::transfer </td>
          <td>(</td>
          <td class="paramtype">const other_container &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y=x; Generic way to copy/assign and/or convert a container type to a different container type (e.g. from CPU to GPU, or double to float, etc.) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">other_container</td><td>another container type, must have the same data policy derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> as <code>container</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>source </td></tr>
    <tr><td class="paramname">y</td><td>sink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>y gets resized properly </dd>
<dd>
since this function is quite often used there is a higher level alias <code>dg::transfer</code> </dd>
<dd>
it is possible to transfer a container to a std::array&lt;container, N&gt; (all elements are initialized to container) but not a std::vector&lt;container&gt; (since the desired size of the std::vector cannot be known)</dd></dl>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a">dg::HVec</a> host = <a class="code" href="group__evaluation.html#ga7521f4acb4edaf2d7896d99f97e1ed9d">dg::evaluate</a>( <a class="code" href="group__functions.html#ga5797166cdb9d26408ea629f742534fa7">dg::one</a>, grid);</div><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> device;</div><div class="line"><a class="code" href="group__blas1.html#gad325c39d1994561ee38813a2dde7a46a">dg::transfer</a>( host, device); <span class="comment">//device now equals host</span></div><div class="line">std::array&lt;dg::DVec, 3&gt; device_arr;</div><div class="line"><a class="code" href="group__blas1.html#gad325c39d1994561ee38813a2dde7a46a">dg::transfer</a>( host, device_arr); <span class="comment">//every element of device_arr now equals host</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaf23bcda76d2363fa2e08d03fec28714a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container , class UnaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::transform </td>
          <td>(</td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = op(x)\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ y_i = op(x_i) \]
</p>
<p> This is strictly speaking not a BLAS routine since f can be a nonlinear function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_vector_traits.html" title="The vector traits. ">VectorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept. ">AnyVectorTag</a></code> or <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class. ">AnyPolicyTag</a></code>. For example, this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gab99e8227ed890885a7b9915806865a7a" title="Host Vector. ">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code>, <code><a class="el" href="group__typedefs.html#ga3f854ffa533cafd10b9846258e40029f" title="MPI Host Vector s.a. dg::HVec. ">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga25cae493b710b17992387cce395ad7ae" title="MPI Device Vector s.a. dg::DVec. ">dg::MDVec</a></code> </li>
<li><code>std::vector&lt;dg::DVec&gt;</code>, <code>std::array&lt;dg::MHVec, 3&gt;</code>, <code>std::array&lt;double, 4&gt;</code> ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__vec__list.html">List of Vector Traits specializations</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryOp</td><td>Functor with signature: <code>value_type</code> <code>operator()( value_type)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>container x may alias y </td></tr>
    <tr><td class="paramname">y</td><td>container y contains result, may alias x </td></tr>
    <tr><td class="paramname">op</td><td>unary <a class="el" href="classdg_1_1_operator.html" title="Helper class mainly for the assembly of Matrices. ">Operator</a> to use on every element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the Functor must be callable on the device. In particular, with CUDA the signature must contain the __device__ specifier.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="group__typedefs.html#gac0ff05273efb141d62270f033c68bcb6">dg::DVec</a> two( 100,2), result(100);</div><div class="line"><a class="code" href="group__blas1.html#gaf23bcda76d2363fa2e08d03fec28714a">dg::blas1::transform</a>( two, result, <a class="code" href="structdg_1_1_e_x_p.html">dg::EXP</a>());</div><div class="line"><span class="comment">//result[i] = 7.389056... (e^2)</span></div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 26 2018 16:28:14 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
