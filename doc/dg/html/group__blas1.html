<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: BLAS level 1 routines: Vector-Vector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__blas1.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">BLAS level 1 routines: Vector-Vector<div class="ingroups"><a class="el" href="group__backend.html">Level 1: Vectors, Matrices and basic operations</a> &raquo; <a class="el" href="group__blas.html">Basic container independent subroutines</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>\( f( x_{0i}, x_{1i}, x_{2i}, ...) \) and \( x^T y\)  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for BLAS level 1 routines: Vector-Vector:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__blas1.svg" width="394" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedg_1_1blas1"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1blas1.html">dg::blas1</a></td></tr>
<tr class="memdesc:namespacedg_1_1blas1"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 1 routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf00778ded011a9f6e8b885924d9306ee"><td class="memTemplParams" colspan="2">template&lt;class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gaf00778ded011a9f6e8b885924d9306ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gaf00778ded011a9f6e8b885924d9306ee">dg::blas1::dot</a> (const ContainerType1 &amp;x, const ContainerType2 &amp;y)</td></tr>
<tr class="memdesc:gaf00778ded011a9f6e8b885924d9306ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x^T y\) Binary reproducible Euclidean dot product between two vectors  <a href="group__blas1.html#gaf00778ded011a9f6e8b885924d9306ee">More...</a><br /></td></tr>
<tr class="separator:gaf00778ded011a9f6e8b885924d9306ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61cf5da3d6fd6325cb24522b7ac8a037"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class OutputType , class BinaryOp , class UnaryOp  = IDENTITY&gt; </td></tr>
<tr class="memitem:ga61cf5da3d6fd6325cb24522b7ac8a037"><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga61cf5da3d6fd6325cb24522b7ac8a037">dg::blas1::reduce</a> (const ContainerType &amp;x, OutputType <a class="el" href="group__basics.html#gad1e45796f68232b124d0f5baea6fceca">zero</a>, BinaryOp binary_op, UnaryOp unary_op=UnaryOp())</td></tr>
<tr class="memdesc:ga61cf5da3d6fd6325cb24522b7ac8a037"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( f(x_0) \otimes f(x_1) \otimes \dots \otimes f(x_{N-1}) \) Custom (transform) reduction  <a href="group__blas1.html#ga61cf5da3d6fd6325cb24522b7ac8a037">More...</a><br /></td></tr>
<tr class="separator:ga61cf5da3d6fd6325cb24522b7ac8a037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ed8d5b1a17d0e8882b2d253a0d3fbed"><td class="memTemplParams" colspan="2">template&lt;class ContainerTypeIn , class ContainerTypeOut &gt; </td></tr>
<tr class="memitem:ga0ed8d5b1a17d0e8882b2d253a0d3fbed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga0ed8d5b1a17d0e8882b2d253a0d3fbed">dg::blas1::copy</a> (const ContainerTypeIn &amp;source, ContainerTypeOut &amp;target)</td></tr>
<tr class="memdesc:ga0ed8d5b1a17d0e8882b2d253a0d3fbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y=x \)  <a href="group__blas1.html#ga0ed8d5b1a17d0e8882b2d253a0d3fbed">More...</a><br /></td></tr>
<tr class="separator:ga0ed8d5b1a17d0e8882b2d253a0d3fbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa761a1672f82cf652ecb9382c9ebe525"><td class="memTemplParams" colspan="2">template&lt;class ContainerType &gt; </td></tr>
<tr class="memitem:gaa761a1672f82cf652ecb9382c9ebe525"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gaa761a1672f82cf652ecb9382c9ebe525">dg::blas1::scal</a> (ContainerType &amp;x, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; alpha)</td></tr>
<tr class="memdesc:gaa761a1672f82cf652ecb9382c9ebe525"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x = \alpha x\)  <a href="group__blas1.html#gaa761a1672f82cf652ecb9382c9ebe525">More...</a><br /></td></tr>
<tr class="separator:gaa761a1672f82cf652ecb9382c9ebe525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c9fe0980973ca1170b48ed6a800306"><td class="memTemplParams" colspan="2">template&lt;class ContainerType &gt; </td></tr>
<tr class="memitem:ga48c9fe0980973ca1170b48ed6a800306"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga48c9fe0980973ca1170b48ed6a800306">dg::blas1::plus</a> (ContainerType &amp;x, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; alpha)</td></tr>
<tr class="memdesc:ga48c9fe0980973ca1170b48ed6a800306"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x = x + \alpha \)  <a href="group__blas1.html#ga48c9fe0980973ca1170b48ed6a800306">More...</a><br /></td></tr>
<tr class="separator:ga48c9fe0980973ca1170b48ed6a800306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c7ddbf70dd74867e45c9d4f40b36cf7"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 &gt; </td></tr>
<tr class="memitem:ga5c7ddbf70dd74867e45c9d4f40b36cf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga5c7ddbf70dd74867e45c9d4f40b36cf7">dg::blas1::axpby</a> (<a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; beta, ContainerType &amp;y)</td></tr>
<tr class="memdesc:ga5c7ddbf70dd74867e45c9d4f40b36cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x + \beta y\)  <a href="group__blas1.html#ga5c7ddbf70dd74867e45c9d4f40b36cf7">More...</a><br /></td></tr>
<tr class="separator:ga5c7ddbf70dd74867e45c9d4f40b36cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba146d8c2d13dbeb412ff6130233422"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga5ba146d8c2d13dbeb412ff6130233422"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga5ba146d8c2d13dbeb412ff6130233422">dg::blas1::axpbypgz</a> (<a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; beta, const ContainerType2 &amp;y, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; gamma, ContainerType &amp;z)</td></tr>
<tr class="memdesc:ga5ba146d8c2d13dbeb412ff6130233422"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( z = \alpha x + \beta y + \gamma z\)  <a href="group__blas1.html#ga5ba146d8c2d13dbeb412ff6130233422">More...</a><br /></td></tr>
<tr class="separator:ga5ba146d8c2d13dbeb412ff6130233422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dfb1435b0a4d429d4cd2e8c265cd209"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga0dfb1435b0a4d429d4cd2e8c265cd209"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga0dfb1435b0a4d429d4cd2e8c265cd209">dg::blas1::axpby</a> (<a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; beta, const ContainerType2 &amp;y, ContainerType &amp;z)</td></tr>
<tr class="memdesc:ga0dfb1435b0a4d429d4cd2e8c265cd209"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( z = \alpha x + \beta y\)  <a href="group__blas1.html#ga0dfb1435b0a4d429d4cd2e8c265cd209">More...</a><br /></td></tr>
<tr class="separator:ga0dfb1435b0a4d429d4cd2e8c265cd209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2dcd7cffe760b7bacfdd7647d86e602"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gad2dcd7cffe760b7bacfdd7647d86e602"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gad2dcd7cffe760b7bacfdd7647d86e602">dg::blas1::pointwiseDot</a> (<a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; beta, ContainerType &amp;y)</td></tr>
<tr class="memdesc:gad2dcd7cffe760b7bacfdd7647d86e602"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x_1 x_2 + \beta y\)  <a href="group__blas1.html#gad2dcd7cffe760b7bacfdd7647d86e602">More...</a><br /></td></tr>
<tr class="separator:gad2dcd7cffe760b7bacfdd7647d86e602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga117cb07cd3e8b6a8580bb42a9c00ab40"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga117cb07cd3e8b6a8580bb42a9c00ab40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga117cb07cd3e8b6a8580bb42a9c00ab40">dg::blas1::pointwiseDot</a> (const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, ContainerType &amp;y)</td></tr>
<tr class="memdesc:ga117cb07cd3e8b6a8580bb42a9c00ab40"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = x_1 x_2 \)  <a href="group__blas1.html#ga117cb07cd3e8b6a8580bb42a9c00ab40">More...</a><br /></td></tr>
<tr class="separator:ga117cb07cd3e8b6a8580bb42a9c00ab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8bde5930a50e3cf58af5c19f765ac8e"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class ContainerType3 &gt; </td></tr>
<tr class="memitem:gad8bde5930a50e3cf58af5c19f765ac8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gad8bde5930a50e3cf58af5c19f765ac8e">dg::blas1::pointwiseDot</a> (<a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, const ContainerType3 &amp;x3, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; beta, ContainerType &amp;y)</td></tr>
<tr class="memdesc:gad8bde5930a50e3cf58af5c19f765ac8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x_1 x_2 x_3 + \beta y\)  <a href="group__blas1.html#gad8bde5930a50e3cf58af5c19f765ac8e">More...</a><br /></td></tr>
<tr class="separator:gad8bde5930a50e3cf58af5c19f765ac8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38b907a9fb2f7039d9a6ffb1c46b649"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gab38b907a9fb2f7039d9a6ffb1c46b649"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gab38b907a9fb2f7039d9a6ffb1c46b649">dg::blas1::pointwiseDivide</a> (<a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; beta, ContainerType &amp;y)</td></tr>
<tr class="memdesc:gab38b907a9fb2f7039d9a6ffb1c46b649"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x_1/ x_2 + \beta y \)  <a href="group__blas1.html#gab38b907a9fb2f7039d9a6ffb1c46b649">More...</a><br /></td></tr>
<tr class="separator:gab38b907a9fb2f7039d9a6ffb1c46b649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e30e54e32bab62357425a0240d519ea"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga4e30e54e32bab62357425a0240d519ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga4e30e54e32bab62357425a0240d519ea">dg::blas1::pointwiseDivide</a> (const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, ContainerType &amp;y)</td></tr>
<tr class="memdesc:ga4e30e54e32bab62357425a0240d519ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = x_1/ x_2\)  <a href="group__blas1.html#ga4e30e54e32bab62357425a0240d519ea">More...</a><br /></td></tr>
<tr class="separator:ga4e30e54e32bab62357425a0240d519ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12ce2a470cebd649636725f30d88bf97"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class ContainerType3 , class ContainerType4 &gt; </td></tr>
<tr class="memitem:ga12ce2a470cebd649636725f30d88bf97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga12ce2a470cebd649636725f30d88bf97">dg::blas1::pointwiseDot</a> (<a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x1, const ContainerType2 &amp;y1, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; beta, const ContainerType3 &amp;x2, const ContainerType4 &amp;y2, <a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt; gamma, ContainerType &amp;z)</td></tr>
<tr class="memdesc:ga12ce2a470cebd649636725f30d88bf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( z = \alpha x_1y_1 + \beta x_2y_2 + \gamma z\)  <a href="group__blas1.html#ga12ce2a470cebd649636725f30d88bf97">More...</a><br /></td></tr>
<tr class="separator:ga12ce2a470cebd649636725f30d88bf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga493c6b70c8c889beaec1c3a669e3809b"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class UnaryOp &gt; </td></tr>
<tr class="memitem:ga493c6b70c8c889beaec1c3a669e3809b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga493c6b70c8c889beaec1c3a669e3809b">dg::blas1::transform</a> (const ContainerType1 &amp;x, ContainerType &amp;y, UnaryOp op)</td></tr>
<tr class="memdesc:ga493c6b70c8c889beaec1c3a669e3809b"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = op(x)\)  <a href="group__blas1.html#ga493c6b70c8c889beaec1c3a669e3809b">More...</a><br /></td></tr>
<tr class="separator:ga493c6b70c8c889beaec1c3a669e3809b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7b58d466d813898b68189b44619210"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class BinarySubroutine , class Functor , class ContainerType0 , class ... ContainerTypes&gt; </td></tr>
<tr class="memitem:gaad7b58d466d813898b68189b44619210"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#gaad7b58d466d813898b68189b44619210">dg::blas1::evaluate</a> (ContainerType &amp;y, BinarySubroutine f, Functor g, const ContainerType0 &amp;x0, const ContainerTypes &amp;...xs)</td></tr>
<tr class="memdesc:gaad7b58d466d813898b68189b44619210"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( f(g(x_0,x_1,...), y)\)  <a href="group__blas1.html#gaad7b58d466d813898b68189b44619210">More...</a><br /></td></tr>
<tr class="separator:gaad7b58d466d813898b68189b44619210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7386b5cb0144d5364b8ea8c8ce1482a5"><td class="memTemplParams" colspan="2">template&lt;class Subroutine , class ContainerType , class ... ContainerTypes&gt; </td></tr>
<tr class="memitem:ga7386b5cb0144d5364b8ea8c8ce1482a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5">dg::blas1::subroutine</a> (Subroutine f, ContainerType &amp;&amp;x, ContainerTypes &amp;&amp;... xs)</td></tr>
<tr class="memdesc:ga7386b5cb0144d5364b8ea8c8ce1482a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( f(x_0, x_1, ...)\); Customizable and generic <a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a> function  <a href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5">More...</a><br /></td></tr>
<tr class="separator:ga7386b5cb0144d5364b8ea8c8ce1482a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >\( f( x_{0i}, x_{1i}, x_{2i}, ...) \) and \( x^T y\) </p>
<pre class="fragment">Successive calls to blas routines are executed sequentially.
A manual synchronization of threads or devices is never needed
in an application using these functions. All functions returning
a value block until the value is ready.
</pre> <h2 class="groupheader">Function Documentation</h2>
<a id="ga0dfb1435b0a4d429d4cd2e8c265cd209" name="ga0dfb1435b0a4d429d4cd2e8c265cd209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dfb1435b0a4d429d4cd2e8c265cd209">&#9670;&nbsp;</a></span>axpby() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::axpby </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( z = \alpha x + \beta y\) </p>
<p >This routine computes </p><p class="formulaDsp">
\[ z_i = \alpha x_i + \beta y_i \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), three(100,3), result(100);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#ga5c7ddbf70dd74867e45c9d4f40b36cf7">dg::blas1::axpby</a>( 2, two, 3., three, result); <span class="comment">// result[i] = 13 (2*2+3*3)</span></div>
<div class="ttc" id="agroup__blas1_html_ga5c7ddbf70dd74867e45c9d4f40b36cf7"><div class="ttname"><a href="group__blas1.html#ga5c7ddbf70dd74867e45c9d4f40b36cf7">dg::blas1::axpby</a></div><div class="ttdeci">void axpby(get_value_type&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x, get_value_type&lt; ContainerType &gt; beta, ContainerType &amp;y)</div><div class="ttdef"><b>Definition:</b> blas1.h:229</div></div>
<div class="ttc" id="agroup__typedefs_html_ga5bbe4ba51ef8ff8d506979d0beda25b8"><div class="ttname"><a href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a></div><div class="ttdeci">thrust::device_vector&lt; double &gt; DVec</div><div class="ttdoc">Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...</div><div class="ttdef"><b>Definition:</b> typedefs.h:23</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>ContainerType x may alias z </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">y</td><td>ContainerType y may alias z </td></tr>
    <tr><td class="paramname">z</td><td>(write-only) ContainerType z contains solution on output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga5c7ddbf70dd74867e45c9d4f40b36cf7" name="ga5c7ddbf70dd74867e45c9d4f40b36cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c7ddbf70dd74867e45c9d4f40b36cf7">&#9670;&nbsp;</a></span>axpby() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::axpby </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x + \beta y\) </p>
<p >This routine computes </p><p class="formulaDsp">
\[ y_i = \alpha x_i + \beta y_i \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), three(100,3);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#ga5c7ddbf70dd74867e45c9d4f40b36cf7">dg::blas1::axpby</a>( 2, two, 3., three); <span class="comment">// three[i] = 13 (2*2+3*3)</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>ContainerType x may alias y </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">y</td><td>(read/write) ContainerType y contains solution on output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga5ba146d8c2d13dbeb412ff6130233422" name="ga5ba146d8c2d13dbeb412ff6130233422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ba146d8c2d13dbeb412ff6130233422">&#9670;&nbsp;</a></span>axpbypgz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::axpbypgz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( z = \alpha x + \beta y + \gamma z\) </p>
<p >This routine computes </p><p class="formulaDsp">
\[ z_i = \alpha x_i + \beta y_i + \gamma z_i \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two(100,2), five(100,5), result(100, 12);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#ga5ba146d8c2d13dbeb412ff6130233422">dg::blas1::axpbypgz</a>( 2.5, two, 2., five, -3.,result);</div>
<div class="line"><span class="comment">// result[i] = -21 (2.5*2+2*5-3*12)</span></div>
<div class="ttc" id="agroup__blas1_html_ga5ba146d8c2d13dbeb412ff6130233422"><div class="ttname"><a href="group__blas1.html#ga5ba146d8c2d13dbeb412ff6130233422">dg::blas1::axpbypgz</a></div><div class="ttdeci">void axpbypgz(get_value_type&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x, get_value_type&lt; ContainerType &gt; beta, const ContainerType2 &amp;y, get_value_type&lt; ContainerType &gt; gamma, ContainerType &amp;z)</div><div class="ttdef"><b>Definition:</b> blas1.h:263</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>ContainerType x may alias result </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">y</td><td>ContainerType y may alias result </td></tr>
    <tr><td class="paramname">gamma</td><td>Scalar </td></tr>
    <tr><td class="paramname">z</td><td>(read/write) ContainerType contains solution on output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga0ed8d5b1a17d0e8882b2d253a0d3fbed" name="ga0ed8d5b1a17d0e8882b2d253a0d3fbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ed8d5b1a17d0e8882b2d253a0d3fbed">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerTypeIn , class ContainerTypeOut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::copy </td>
          <td>(</td>
          <td class="paramtype">const ContainerTypeIn &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerTypeOut &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y=x \) </p>
<p >explicit pointwise assignment \( y_i = x_i\)</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>vector to copy </td></tr>
    <tr><td class="paramname">target</td><td>(write-only) destination </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>in contrast to the <code><a class="el" href="group__backend.html#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code> functions the <code>copy</code> function uses the execution policy to determine the implementation and thus works only on types with same execution policy </dd>
<dd>
catches self-assignment</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="gaf00778ded011a9f6e8b885924d9306ee" name="gaf00778ded011a9f6e8b885924d9306ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf00778ded011a9f6e8b885924d9306ee">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType1 &gt; dg::blas1::dot </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x^T y\) Binary reproducible Euclidean dot product between two vectors </p>
<p >This routine computes </p><p class="formulaDsp">
\[ x^T y = \sum_{i=0}^{N-1} x_i y_i \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<p >For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), three(100,3);</div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code hl_function" href="group__blas1.html#gaf00778ded011a9f6e8b885924d9306ee">dg::blas1::dot</a>( two, three); <span class="comment">// result = 600 (100*(2*3))</span></div>
<div class="ttc" id="agroup__blas1_html_gaf00778ded011a9f6e8b885924d9306ee"><div class="ttname"><a href="group__blas1.html#gaf00778ded011a9f6e8b885924d9306ee">dg::blas1::dot</a></div><div class="ttdeci">get_value_type&lt; ContainerType1 &gt; dot(const ContainerType1 &amp;x, const ContainerType2 &amp;y)</div><div class="ttdoc">Binary reproducible Euclidean dot product between two vectors</div><div class="ttdef"><b>Definition:</b> blas1.h:87</div></div>
</div><!-- fragment --> <dl class="section attention"><dt>Attention</dt><dd>if one of the input vectors contains <code>Inf</code> or <code>NaN</code> or the product of the input numbers reaches <code>Inf</code> or <code>Nan</code> then the behaviour is undefined and the function may throw. See <a class="el" href="structdg_1_1_i_s_n_f_i_n_i_t_e.html">dg::ISNFINITE</a> and <a class="el" href="structdg_1_1_i_s_n_s_a_n_e.html">dg::ISNSANE</a> in that case </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Our implementation guarantees <b>binary reproducible</b> results. The sum is computed with <b>infinite precision</b> and the result is rounded to the nearest double precision number. This is possible with the help of an adapted version of the <code><a class="elRef" href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></code> library and works for single and double precision.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left Container </td></tr>
    <tr><td class="paramname">y</td><td>Right Container may alias x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar product as defined above </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. With mpi the result is broadcasted to all processes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="gaad7b58d466d813898b68189b44619210" name="gaad7b58d466d813898b68189b44619210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad7b58d466d813898b68189b44619210">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class BinarySubroutine , class Functor , class ContainerType0 , class ... ContainerTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::evaluate </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinarySubroutine&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType0 &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerTypes &amp;...&#160;</td>
          <td class="paramname"><em>xs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( f(g(x_0,x_1,...), y)\) </p>
<p >This routine elementwise evaluates </p><p class="formulaDsp">
\[ f(g(x_{0i}, x_{1i}, ...), y_i) \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> function( <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> sin(x)*sin(y);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a> pi2(20, <a class="code hl_define" href="functors_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>/2.), pi3( 20, 3*<a class="code hl_define" href="functors_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>/2.), result(20, 0);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#gaad7b58d466d813898b68189b44619210">dg::blas1::evaluate</a>( result, <a class="code hl_struct" href="structdg_1_1equals.html">dg::equals</a>(), function, pi2, pi3);</div>
<div class="line"><span class="comment">// result[i] = sin(M_PI/2.)*sin(3*M_PI/2.) = -1</span></div>
<div class="ttc" id="afunctors_8h_html_ae71449b1cc6e6250b91f539153a7a0d3"><div class="ttname"><a href="functors_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></div><div class="ttdeci">#define M_PI</div><div class="ttdoc">M_PI is non-standard ... so MSVC complains.</div><div class="ttdef"><b>Definition:</b> functors.h:6</div></div>
<div class="ttc" id="agroup__blas1_html_gaad7b58d466d813898b68189b44619210"><div class="ttname"><a href="group__blas1.html#gaad7b58d466d813898b68189b44619210">dg::blas1::evaluate</a></div><div class="ttdeci">void evaluate(ContainerType &amp;y, BinarySubroutine f, Functor g, const ContainerType0 &amp;x0, const ContainerTypes &amp;...xs)</div><div class="ttdef"><b>Definition:</b> blas1.h:554</div></div>
<div class="ttc" id="agroup__typedefs_html_ga4fb8e78e7b043edfedb880523f0cd193"><div class="ttname"><a href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193">dg::HVec</a></div><div class="ttdeci">thrust::host_vector&lt; double &gt; HVec</div><div class="ttdoc">Host Vector.</div><div class="ttdef"><b>Definition:</b> typedefs.h:19</div></div>
<div class="ttc" id="astructdg_1_1equals_html"><div class="ttname"><a href="structdg_1_1equals.html">dg::equals</a></div><div class="ttdef"><b>Definition:</b> subroutines.h:22</div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinarySubroutine</td><td>Functor with signature: <code> void ( value_type_g, value_type_y&amp;) </code> i.e. it reads the first (and second) and writes into the second argument </td></tr>
    <tr><td class="paramname">Functor</td><td>signature: <code> value_type_g operator()( value_type_x0, value_type_x1, ...) </code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Both <code>BinarySubroutine</code> and <code>Functor</code> must be callable on the device in use. In particular, with CUDA they must be functor tpyes (<b>not</b> functions) and their signatures must contain the __device__ specifier. (s.a. <a class="el" href="functions_8h.html#aa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>contains result </td></tr>
    <tr><td class="paramname">f</td><td>The subroutine, for example <code><a class="el" href="structdg_1_1equals.html">dg::equals</a></code> or <code><a class="el" href="structdg_1_1plus__equals.html">dg::plus_equals</a></code>, see <a class="el" href="group__binary__operators.html">blas1::evaluate binary operators</a> for a collection of predefined functors to use here </td></tr>
    <tr><td class="paramname">g</td><td>The functor to evaluate, see <a class="el" href="group__functions.html">A large collection</a> and <a class="el" href="group__variadic__evaluates.html">blas1::evaluate variadic functors</a> for a collection of predefined functors to use here </td></tr>
    <tr><td class="paramname">x0</td><td>first input </td></tr>
    <tr><td class="paramname">xs</td><td>more input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>all aliases allowed</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga48c9fe0980973ca1170b48ed6a800306" name="ga48c9fe0980973ca1170b48ed6a800306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48c9fe0980973ca1170b48ed6a800306">&#9670;&nbsp;</a></span>plus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::plus </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x = x + \alpha \) </p>
<p >This routine computes </p><p class="formulaDsp">
\[ x_i + \alpha \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#ga48c9fe0980973ca1170b48ed6a800306">dg::blas1::plus</a>( two,  2. )); <span class="comment">// result[i] = 4.</span></div>
<div class="ttc" id="agroup__blas1_html_ga48c9fe0980973ca1170b48ed6a800306"><div class="ttname"><a href="group__blas1.html#ga48c9fe0980973ca1170b48ed6a800306">dg::blas1::plus</a></div><div class="ttdeci">void plus(ContainerType &amp;x, get_value_type&lt; ContainerType &gt; alpha)</div><div class="ttdef"><b>Definition:</b> blas1.h:205</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) x</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga4e30e54e32bab62357425a0240d519ea" name="ga4e30e54e32bab62357425a0240d519ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e30e54e32bab62357425a0240d519ea">&#9670;&nbsp;</a></span>pointwiseDivide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDivide </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = x_1/ x_2\) </p>
<p >Divides two vectors element by element: </p><p class="formulaDsp">
\[ y_i = x_{1i}/x_{2i}\]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), three( 100,3), result(100);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#gab38b907a9fb2f7039d9a6ffb1c46b649">dg::blas1::pointwiseDivide</a>( two,  three, result );</div>
<div class="line"><span class="comment">// result[i] = -0.666... (2/3)</span></div>
<div class="ttc" id="agroup__blas1_html_gab38b907a9fb2f7039d9a6ffb1c46b649"><div class="ttname"><a href="group__blas1.html#gab38b907a9fb2f7039d9a6ffb1c46b649">dg::blas1::pointwiseDivide</a></div><div class="ttdeci">void pointwiseDivide(get_value_type&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, get_value_type&lt; ContainerType &gt; beta, ContainerType &amp;y)</div><div class="ttdef"><b>Definition:</b> blas1.h:426</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">y</td><td>(write-only) ContainerType y contains result on output ( may alias x1 and/or x2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="gab38b907a9fb2f7039d9a6ffb1c46b649" name="gab38b907a9fb2f7039d9a6ffb1c46b649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab38b907a9fb2f7039d9a6ffb1c46b649">&#9670;&nbsp;</a></span>pointwiseDivide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x_1/ x_2 + \beta y \) </p>
<p >Divides two vectors element by element: </p><p class="formulaDsp">
\[ y_i = \alpha x_{1i}/x_{2i} + \beta y_i \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), three( 100,3), result(100,1);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#gab38b907a9fb2f7039d9a6ffb1c46b649">dg::blas1::pointwiseDivide</a>( 3, two,  three, 5, result );</div>
<div class="line"><span class="comment">// result[i] = 7 (3*2/3+5*1)</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">y</td><td>(read/write) ContainerType y contains result on output ( may alias x1 and/or x2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga117cb07cd3e8b6a8580bb42a9c00ab40" name="ga117cb07cd3e8b6a8580bb42a9c00ab40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga117cb07cd3e8b6a8580bb42a9c00ab40">&#9670;&nbsp;</a></span>pointwiseDot() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = x_1 x_2 \) </p>
<p >Multiplies two vectors element by element: </p><p class="formulaDsp">
\[ y_i = x_{1i}x_{2i}\]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), three( 100,3), result(100);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#gad2dcd7cffe760b7bacfdd7647d86e602">dg::blas1::pointwiseDot</a>( two,  three, result ); <span class="comment">// result[i] = 6.</span></div>
<div class="ttc" id="agroup__blas1_html_gad2dcd7cffe760b7bacfdd7647d86e602"><div class="ttname"><a href="group__blas1.html#gad2dcd7cffe760b7bacfdd7647d86e602">dg::blas1::pointwiseDot</a></div><div class="ttdeci">void pointwiseDot(get_value_type&lt; ContainerType &gt; alpha, const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, get_value_type&lt; ContainerType &gt; beta, ContainerType &amp;y)</div><div class="ttdef"><b>Definition:</b> blas1.h:334</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">y</td><td>(write-only) ContainerType y contains result on output ( may alias x1 or x2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="gad8bde5930a50e3cf58af5c19f765ac8e" name="gad8bde5930a50e3cf58af5c19f765ac8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8bde5930a50e3cf58af5c19f765ac8e">&#9670;&nbsp;</a></span>pointwiseDot() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class ContainerType3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x_1 x_2 x_3 + \beta y\) </p>
<p >Multiplies three vectors element by element: </p><p class="formulaDsp">
\[ y_i = \alpha x_{1i}x_{2i}x_{3i} + \beta y_i\]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), three( 100,3), four(100,4), result(100,6);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#gad2dcd7cffe760b7bacfdd7647d86e602">dg::blas1::pointwiseDot</a>(2., two,  three, four, -4., result );</div>
<div class="line"><span class="comment">// result[i] = 24. (2*2*3*4-4*6)</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">x3</td><td>ContainerType x3 may alias x1 and/or x2 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">y</td><td>(read/write) ContainerType y contains result on output ( may alias x1,x2 or x3)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="gad2dcd7cffe760b7bacfdd7647d86e602" name="gad2dcd7cffe760b7bacfdd7647d86e602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2dcd7cffe760b7bacfdd7647d86e602">&#9670;&nbsp;</a></span>pointwiseDot() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x_1 x_2 + \beta y\) </p>
<p >Multiplies two vectors element by element: </p><p class="formulaDsp">
\[ y_i = \alpha x_{1i}x_{2i} + \beta y_i\]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), three( 100,3), result(100,6);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#gad2dcd7cffe760b7bacfdd7647d86e602">dg::blas1::pointwiseDot</a>(2., two,  three, -4., result );</div>
<div class="line"><span class="comment">// result[i] = -12. (2*2*3-4*6)</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">y</td><td>(read/write) ContainerType y contains result on output ( may alias x1 or x2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga12ce2a470cebd649636725f30d88bf97" name="ga12ce2a470cebd649636725f30d88bf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12ce2a470cebd649636725f30d88bf97">&#9670;&nbsp;</a></span>pointwiseDot() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class ContainerType3 , class ContainerType4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType3 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType4 &amp;&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\( z = \alpha x_1y_1 + \beta x_2y_2 + \gamma z\) </p>
<p >Multiplies and adds vectors element by element: </p><p class="formulaDsp">
\[ z_i = \alpha x_{1i}y_{1i} + \beta x_{2i}y_{2i} + \gamma z_i \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two(100,2), three(100,3), four(100,5), five(100,5), result(100,6);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#gad2dcd7cffe760b7bacfdd7647d86e602">dg::blas1::pointwiseDot</a>(2., two,  three, -4., four, five, 2., result );</div>
<div class="line"><span class="comment">// result[i] = -56.</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">y1</td><td>ContainerType y1 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 </td></tr>
    <tr><td class="paramname">y2</td><td>ContainerType y2 </td></tr>
    <tr><td class="paramname">gamma</td><td>scalar </td></tr>
    <tr><td class="paramname">z</td><td>(read/write) ContainerType z contains result on output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>all aliases are allowed</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga61cf5da3d6fd6325cb24522b7ac8a037" name="ga61cf5da3d6fd6325cb24522b7ac8a037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61cf5da3d6fd6325cb24522b7ac8a037">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class OutputType , class BinaryOp , class UnaryOp  = IDENTITY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputType dg::blas1::reduce </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType&#160;</td>
          <td class="paramname"><em>zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>binary_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>unary_op</em> = <code>UnaryOp()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( f(x_0) \otimes f(x_1) \otimes \dots \otimes f(x_{N-1}) \) Custom (transform) reduction </p>
<p >This routine computes </p><p class="formulaDsp">
\[ s = f(x_0) \otimes f(x_1) \otimes \dots \otimes f(x_i) \otimes \dots \otimes f(x_{N-1}) \]
</p>
<p> where \( \otimes \) is an arbitrary <b>commutative</b> and <b>associative</b> binary operator, \( f\) is an optional unary operator and</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<dl class="section note"><dt>Note</dt><dd>numerical addition/multiplication is <b>not</b> exactly associative which means that the associated reduction looses precision due to inexact arithmetic. For binary reproducible exactly rounded results use the <a class="el" href="group__blas1.html#gaf00778ded011a9f6e8b885924d9306ee" title="Binary reproducible Euclidean dot product between two vectors">dg::blas1::dot</a> function. However, this function is more general and faster to execute than <a class="el" href="group__blas1.html#gaf00778ded011a9f6e8b885924d9306ee" title="Binary reproducible Euclidean dot product between two vectors">dg::blas1::dot</a>.</dd></dl>
<p>For example </p><div class="fragment"><div class="line"><span class="comment">//Check if a vector contains Inf or NaN</span></div>
<div class="line">thrust::device_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( 100);</div>
<div class="line"><span class="keywordtype">bool</span> hasnan = <a class="code hl_function" href="group__blas1.html#ga61cf5da3d6fd6325cb24522b7ac8a037">dg::blas1::reduce</a>( x, <span class="keyword">false</span>, thrust::logical_or&lt;bool&gt;(), <a class="code hl_struct" href="structdg_1_1_i_s_n_f_i_n_i_t_e.html">dg::ISNFINITE&lt;double&gt;</a>());</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;x contains Inf or NaN &quot;</span>&lt;&lt;std::boolalpha&lt;&lt;hasnan&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="agroup__blas1_html_ga61cf5da3d6fd6325cb24522b7ac8a037"><div class="ttname"><a href="group__blas1.html#ga61cf5da3d6fd6325cb24522b7ac8a037">dg::blas1::reduce</a></div><div class="ttdeci">OutputType reduce(const ContainerType &amp;x, OutputType zero, BinaryOp binary_op, UnaryOp unary_op=UnaryOp())</div><div class="ttdoc">Custom (transform) reduction</div><div class="ttdef"><b>Definition:</b> blas1.h:137</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">dg::coo2d::x</a></div><div class="ttdeci">@ x</div><div class="ttdoc">x direction</div></div>
<div class="ttc" id="astructdg_1_1_i_s_n_f_i_n_i_t_e_html"><div class="ttname"><a href="structdg_1_1_i_s_n_f_i_n_i_t_e.html">dg::ISNFINITE</a></div><div class="ttdef"><b>Definition:</b> functors.h:293</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container to reduce </td></tr>
    <tr><td class="paramname">zero</td><td>The neutral element with respect to binary_op that is <code> x == binary_op( zero, x) </code>. Determines the <code>OutputType</code> so make sure to make the type clear to the compiler (e.g. write <code> (double)0 </code> instead of <code>0</code> if you want <code>double</code> output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>In the current implementation <code>zero</code> is used to initialize partial sums e.g. when reducing MPI Vectors so it is important that <code>zero</code> is actually the neutral element. The reduction will yield wrong results if it is not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary_op</td><td>an associative and commutative binary operator </td></tr>
    <tr><td class="paramname">unary_op</td><td>a unary operator applies to each element of <code>x</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Custom reduction as defined above </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. With mpi the result is broadcasted to all processes </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>Functor with signature: <code> value_type operator()(
   value_type, value_type) </code>, must be associative and commutative. <code>value_tpye</code> must be compatible with <code>OutputType</code> </td></tr>
    <tr><td class="paramname">UnaryOp</td><td>a unary operator. The argument type must be compatible with <code>get_value_type&lt;ContainerType&gt;</code>. The return type must be convertible to <code>OutputType</code> </td></tr>
    <tr><td class="paramname">OutputType</td><td>The type of the result. Infered from <code>zero</code> so make sure <code>zero's</code> type is clear to the compiler.</td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="gaa761a1672f82cf652ecb9382c9ebe525" name="gaa761a1672f82cf652ecb9382c9ebe525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa761a1672f82cf652ecb9382c9ebe525">&#9670;&nbsp;</a></span>scal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::scal </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#ga6cca187a5557469a96917dc4687a22d3">get_value_type</a>&lt; ContainerType &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x = \alpha x\) </p>
<p >This routine computes </p><p class="formulaDsp">
\[ \alpha x_i \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#gaa761a1672f82cf652ecb9382c9ebe525">dg::blas1::scal</a>( two,  0.5 )); <span class="comment">// result[i] = 1.</span></div>
<div class="ttc" id="agroup__blas1_html_gaa761a1672f82cf652ecb9382c9ebe525"><div class="ttname"><a href="group__blas1.html#gaa761a1672f82cf652ecb9382c9ebe525">dg::blas1::scal</a></div><div class="ttdeci">void scal(ContainerType &amp;x, get_value_type&lt; ContainerType &gt; alpha)</div><div class="ttdef"><b>Definition:</b> blas1.h:183</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) x</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga7386b5cb0144d5364b8ea8c8ce1482a5" name="ga7386b5cb0144d5364b8ea8c8ce1482a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7386b5cb0144d5364b8ea8c8ce1482a5">&#9670;&nbsp;</a></span>subroutine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Subroutine , class ContainerType , class ... ContainerTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::subroutine </td>
          <td>(</td>
          <td class="paramtype">Subroutine&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>xs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( f(x_0, x_1, ...)\); Customizable and generic <a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a> function </p>
<p >This routine evaluates an arbitrary user-defined subroutine <code>f</code> with an arbitrary number of arguments \( x_s\) elementwise </p><p class="formulaDsp">
\[ f(x_{0i}, x_{1i}, ...) \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Routine{</div>
<div class="line"><a class="code hl_define" href="functions_8h.html#aa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a></div>
<div class="line"><span class="keywordtype">void</span> operator()( <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span>&amp; z){</div>
<div class="line">   <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a> = 7*<a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>+<a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a> + <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a> ;</div>
<div class="line">}</div>
<div class="line">};</div>
<div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), four(100,4);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5">dg::blas1::subroutine</a>( Routine(), two, 3., four);</div>
<div class="line"><span class="comment">// four[i] now has the value 21 (7*2+3+4)</span></div>
<div class="ttc" id="afunctions_8h_html_aa181978ebbc17b8ea6d6c072e06c2d05"><div class="ttname"><a href="functions_8h.html#aa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a></div><div class="ttdeci">#define DG_DEVICE</div><div class="ttdoc">Expands to __host__ __device__ if compiled with nvcc else is empty.</div><div class="ttdef"><b>Definition:</b> functions.h:9</div></div>
<div class="ttc" id="agroup__blas1_html_ga7386b5cb0144d5364b8ea8c8ce1482a5"><div class="ttname"><a href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5">dg::blas1::subroutine</a></div><div class="ttdeci">void subroutine(Subroutine f, ContainerType &amp;&amp;x, ContainerTypes &amp;&amp;... xs)</div><div class="ttdoc">; Customizable and generic blas1 function</div><div class="ttdef"><b>Definition:</b> blas1.h:616</div></div>
<div class="ttc" id="agroup__creation_html_gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7"><div class="ttname"><a href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">dg::coo3d::z</a></div><div class="ttdeci">@ z</div><div class="ttdoc">z direction</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">dg::coo2d::y</a></div><div class="ttdeci">@ y</div><div class="ttdoc">y direction</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the subroutine, see <a class="el" href="group__variadic__subroutines.html">blas1::subroutine subroutines</a> for a collection of predefind subroutines to use here </td></tr>
    <tr><td class="paramname">x</td><td>the first argument </td></tr>
    <tr><td class="paramname">xs</td><td>other arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can compute <b>any</b> trivial parallel expression for <b>any</b> number of input and output arguments, which is quite remarkable really. In this sense it replaces all other <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functions except the scalar product, which is not trivially parallel. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The user has to decide whether or not it is safe to alias input or output vectors. If in doubt, do not alias output vectors. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Subroutine</td><td>a function or functor with an arbitrary number of arguments and no return type; taking a <code>value_type</code> argument for each input argument in the call and a <code> value_type&amp; </code> argument for each output argument. <code>Subroutine</code> must be callable on the device in use. In particular, with CUDA it must be a functor (<b>not</b> a function) and its signature must contain the __device__ specifier. (s.a. <a class="el" href="functions_8h.html#aa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
<a id="ga493c6b70c8c889beaec1c3a669e3809b" name="ga493c6b70c8c889beaec1c3a669e3809b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga493c6b70c8c889beaec1c3a669e3809b">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class UnaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::transform </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = op(x)\) </p>
<p >This routine computes </p><p class="formulaDsp">
\[ y_i = op(x_i) \]
</p>
<p >where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8">dg::DVec</a> two( 100,2), result(100);</div>
<div class="line"><a class="code hl_function" href="group__blas1.html#ga493c6b70c8c889beaec1c3a669e3809b">dg::blas1::transform</a>( two, result, <a class="code hl_struct" href="structdg_1_1_e_x_p.html">dg::EXP&lt;double&gt;</a>());</div>
<div class="line"><span class="comment">// result[i] = 7.389056... (e^2)</span></div>
<div class="ttc" id="agroup__blas1_html_ga493c6b70c8c889beaec1c3a669e3809b"><div class="ttname"><a href="group__blas1.html#ga493c6b70c8c889beaec1c3a669e3809b">dg::blas1::transform</a></div><div class="ttdeci">void transform(const ContainerType1 &amp;x, ContainerType &amp;y, UnaryOp op)</div><div class="ttdef"><b>Definition:</b> blas1.h:522</div></div>
<div class="ttc" id="astructdg_1_1_e_x_p_html"><div class="ttname"><a href="structdg_1_1_e_x_p.html">dg::EXP</a></div><div class="ttdef"><b>Definition:</b> functors.h:101</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>ContainerType x may alias y </td></tr>
    <tr><td class="paramname">y</td><td>(write-only) ContainerType y contains result, may alias x </td></tr>
    <tr><td class="paramname">op</td><td>unary Operator to use on every element </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryOp</td><td>Functor with signature: <code>value_type</code> <code>operator()( value_type)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>UnaryOp</code> must be callable on the device in use. In particular, with CUDA it must be of functor tpye (<b>not</b> a function) and its signatures must contain the __device__ specifier. (s.a. <a class="el" href="functions_8h.html#aa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>)</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#ga4fb8e78e7b043edfedb880523f0cd193" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#gac127f65b65c035ebe413aee5abffd6f0" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga1e23fb8b50d38d43beb4bf3689c20a55" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga5bbe4ba51ef8ff8d506979d0beda25b8" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__blas.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 28 2022 17:46:20 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
