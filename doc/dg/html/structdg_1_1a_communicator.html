<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Discontinuous Galerkin Library: dg::aCommunicator&lt; LocalContainer &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?.../MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="tablist"> 
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dG</a></li>
    <li><a href="../../geometries/html/modules.html">geometries</a></li>
    <li><a href="../../file/html/namespacefile.html">file</a></li>
    <li><a href="../../exblas/html/namespaceexblas.html">exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">Discontinuous Galerkin numerical methods and container free numerical algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structdg_1_1a_communicator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="structdg_1_1a_communicator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dg::aCommunicator&lt; LocalContainer &gt; Struct Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__backend.html">Level 1: Vectors, Matrices and basic operations</a> &raquo; <a class="el" href="group__mpi__structures.html">MPI backend</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Struct that performs collective scatter and gather operations across processes on distributed vectors using MPI.  
 <a href="structdg_1_1a_communicator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mpi__communicator_8h_source.html">mpi_communicator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acf1b0599056bd3f22b374dcde9b1f213"><td class="memItemLeft" align="right" valign="top">typedef LocalContainer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#acf1b0599056bd3f22b374dcde9b1f213">container_type</a></td></tr>
<tr class="memdesc:acf1b0599056bd3f22b374dcde9b1f213"><td class="mdescLeft">&#160;</td><td class="mdescRight">reveal local container type  <a href="#acf1b0599056bd3f22b374dcde9b1f213">More...</a><br /></td></tr>
<tr class="separator:acf1b0599056bd3f22b374dcde9b1f213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a29bf560157c2d0a81d4ce96b1a0634"><td class="memItemLeft" align="right" valign="top">LocalContainer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a9a29bf560157c2d0a81d4ce96b1a0634">allocate_buffer</a> () const</td></tr>
<tr class="memdesc:a9a29bf560157c2d0a81d4ce96b1a0634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer object of size <code><a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a" title="The size of the local buffer vector w = local map size. ">size()</a></code>  <a href="#a9a29bf560157c2d0a81d4ce96b1a0634">More...</a><br /></td></tr>
<tr class="separator:a9a29bf560157c2d0a81d4ce96b1a0634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47cff828dccf9cca061ea32fe40189e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#ab47cff828dccf9cca061ea32fe40189e">global_gather</a> (const LocalContainer &amp;values, LocalContainer &amp;buffer) const</td></tr>
<tr class="memdesc:ab47cff828dccf9cca061ea32fe40189e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally (across processes) gather data into a buffer.  <a href="#ab47cff828dccf9cca061ea32fe40189e">More...</a><br /></td></tr>
<tr class="separator:ab47cff828dccf9cca061ea32fe40189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791dc0d9309f38350d8cfefbed86bee9"><td class="memItemLeft" align="right" valign="top">LocalContainer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a791dc0d9309f38350d8cfefbed86bee9">global_gather</a> (const LocalContainer &amp;values) const</td></tr>
<tr class="memdesc:a791dc0d9309f38350d8cfefbed86bee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally (across processes) gather data into a buffer (memory allocating version)  <a href="#a791dc0d9309f38350d8cfefbed86bee9">More...</a><br /></td></tr>
<tr class="separator:a791dc0d9309f38350d8cfefbed86bee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6fe775b638b9ad86a7a6e692473434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#add6fe775b638b9ad86a7a6e692473434">global_scatter_reduce</a> (const LocalContainer &amp;toScatter, LocalContainer &amp;values) const</td></tr>
<tr class="memdesc:add6fe775b638b9ad86a7a6e692473434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally (across processes) scatter data accross processes and reduce on multiple indices.  <a href="#add6fe775b638b9ad86a7a6e692473434">More...</a><br /></td></tr>
<tr class="separator:add6fe775b638b9ad86a7a6e692473434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0553786aac2eb96308ec386e22ff6f3a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a">size</a> () const</td></tr>
<tr class="memdesc:a0553786aac2eb96308ec386e22ff6f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the local buffer vector w = local map size.  <a href="#a0553786aac2eb96308ec386e22ff6f3a">More...</a><br /></td></tr>
<tr class="separator:a0553786aac2eb96308ec386e22ff6f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6da46a52184be235645f0194f22cdd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#ab6da46a52184be235645f0194f22cdd2">isCommunicating</a> () const</td></tr>
<tr class="memdesc:ab6da46a52184be235645f0194f22cdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the gather/scatter operation involves actual MPI communication.  <a href="#ab6da46a52184be235645f0194f22cdd2">More...</a><br /></td></tr>
<tr class="separator:ab6da46a52184be235645f0194f22cdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc738661d96a4d926541c14fd28723c6"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#acc738661d96a4d926541c14fd28723c6">communicator</a> () const</td></tr>
<tr class="memdesc:acc738661d96a4d926541c14fd28723c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal MPI communicator used.  <a href="#acc738661d96a4d926541c14fd28723c6">More...</a><br /></td></tr>
<tr class="separator:acc738661d96a4d926541c14fd28723c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f287b55eb703e29f9f17fc128205ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a08f287b55eb703e29f9f17fc128205ef">clone</a> () const =0</td></tr>
<tr class="memdesc:a08f287b55eb703e29f9f17fc128205ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic copy method.  <a href="#a08f287b55eb703e29f9f17fc128205ef">More...</a><br /></td></tr>
<tr class="separator:a08f287b55eb703e29f9f17fc128205ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94374e74e4a9a7857f65de3a5e64ba37"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a94374e74e4a9a7857f65de3a5e64ba37">~aCommunicator</a> ()</td></tr>
<tr class="memdesc:a94374e74e4a9a7857f65de3a5e64ba37"><td class="mdescLeft">&#160;</td><td class="mdescRight">vritual destructor  <a href="#a94374e74e4a9a7857f65de3a5e64ba37">More...</a><br /></td></tr>
<tr class="separator:a94374e74e4a9a7857f65de3a5e64ba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8036365511d408756d78e6aebeb3fe06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a8036365511d408756d78e6aebeb3fe06">aCommunicator</a> ()</td></tr>
<tr class="memdesc:a8036365511d408756d78e6aebeb3fe06"><td class="mdescLeft">&#160;</td><td class="mdescRight">only derived classes can construct  <a href="#a8036365511d408756d78e6aebeb3fe06">More...</a><br /></td></tr>
<tr class="separator:a8036365511d408756d78e6aebeb3fe06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2861411ab00b8988436cf0259edbbc1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#a2861411ab00b8988436cf0259edbbc1b">aCommunicator</a> (const <a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> &amp;src)</td></tr>
<tr class="memdesc:a2861411ab00b8988436cf0259edbbc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">only derived classes can copy  <a href="#a2861411ab00b8988436cf0259edbbc1b">More...</a><br /></td></tr>
<tr class="separator:a2861411ab00b8988436cf0259edbbc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c1f30816b849bd1ee455ab174e1e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_communicator.html#ac3c1f30816b849bd1ee455ab174e1e3a">operator=</a> (const <a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> &amp;src)</td></tr>
<tr class="memdesc:ac3c1f30816b849bd1ee455ab174e1e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">only derived classes can assign  <a href="#ac3c1f30816b849bd1ee455ab174e1e3a">More...</a><br /></td></tr>
<tr class="separator:ac3c1f30816b849bd1ee455ab174e1e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class LocalContainer&gt;<br />
struct dg::aCommunicator&lt; LocalContainer &gt;</h3>

<p>Struct that performs collective scatter and gather operations across processes on distributed vectors using MPI. </p>
<p>In order to understand what this class does you should first really(!) understand what gather and scatter operations are, so grab pen and paper:</p>
<p>First, we note that gather and scatter are most often used in the context of memory buffers. The buffer needs to be filled wih values (gather) or these values need to be written back into the original place (scatter).</p>
<p><b>Gather:</b> imagine a buffer vector w and a map that gives to every element in this vector w an index into a source vector v where the value of this element should be taken from i.e. \( w[i] = v[\text{idx}[i]] \) Note that an index into the source vector v can appear several times or not at all. This is why the source vector v can have any size and even be smaller than w.</p>
<p><b>Scatter:</b> imagine a buffer vector w and a map that gives to every element in the buffer w an index into a target vector v where this element should go to. Note again that an index into v can appear several times or never at all. If the index appears more than once, we perform a reduction operation (we sum up all elements) on these indices initializing the sum with 0. Note that \( v[\text{idx}[i]] = w[i] \) is NOT the correct definition of this, because it does not show the reduction.</p>
<p>It is more accurate to represent the gather and scatter operation by a matrix. The gather matrix is just a (permutation) matrix of 1's and 0's with exactly one "1" in each line. In a "coo" formatted sparse matrix format the values array would consist only of "1"s, row array is just the index and column array is the gather map. We uniquely define the corresponding <b> scatter matrix </b> as the <b> transpose of the gather matrix</b>. The scatter matrix can have zero, one or more "1"s in each line. </p><p class="formulaDsp">
\[ w_1 = G v_1 \\ v_2 = S w_2 = G^\mathrm{T} w_2 \]
</p>
<p> where \( v_1\) and \( v_2\) are data vectors and \( w_1\) and \( w_2\) are buffer vectors.</p>
<p>This class performs these operations for the case that v and w are distributed across processes. We always assume that the source vector v is distributed equally among processes, i.e. each process holds a chunk of v of equal size. On the other hand the local size of w may vary among processes depending on the gather/scatter map.</p>
<dl class="section note"><dt>Note</dt><dd>The scatter matrix S is the actual inverse of G if and only if the gather map is bijective. In this case the buffer and the vector can swap their roles.</dd>
<dd>
Finally note that when v is filled with its indices, i.e. \( v[i] = i \), then the gather operation will reproduce the index map in the buffer w \( w[i] = \text{idx}[i]\) .</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LocalContainer</td><td>a container on a shared memory system (must be default constructible) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acf1b0599056bd3f22b374dcde9b1f213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1b0599056bd3f22b374dcde9b1f213">&#9670;&nbsp;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef LocalContainer <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::<a class="el" href="structdg_1_1a_communicator.html#acf1b0599056bd3f22b374dcde9b1f213">container_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reveal local container type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a94374e74e4a9a7857f65de3a5e64ba37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94374e74e4a9a7857f65de3a5e64ba37">&#9670;&nbsp;</a></span>~aCommunicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::~<a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vritual destructor </p>

</div>
</div>
<a id="a8036365511d408756d78e6aebeb3fe06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8036365511d408756d78e6aebeb3fe06">&#9670;&nbsp;</a></span>aCommunicator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::<a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>only derived classes can construct </p>

</div>
</div>
<a id="a2861411ab00b8988436cf0259edbbc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2861411ab00b8988436cf0259edbbc1b">&#9670;&nbsp;</a></span>aCommunicator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::<a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>only derived classes can copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a29bf560157c2d0a81d4ce96b1a0634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a29bf560157c2d0a81d4ce96b1a0634">&#9670;&nbsp;</a></span>allocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LocalContainer <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::allocate_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a buffer object of size <code><a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a" title="The size of the local buffer vector w = local map size. ">size()</a></code> </p>
<dl class="section return"><dt>Returns</dt><dd>a buffer object on the stack </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if <code><a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a" title="The size of the local buffer vector w = local map size. ">size()</a>==0</code> the default constructor of <code>LocalContainer</code> is called </dd></dl>

</div>
</div>
<a id="a08f287b55eb703e29f9f17fc128205ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f287b55eb703e29f9f17fc128205ef">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a>* <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic copy method. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated object </dd></dl>

<p>Implemented in <a class="el" href="structdg_1_1_general_comm.html#a4936832cf4eae4f09c85e15c4301e050">dg::GeneralComm&lt; Index, Vector &gt;</a>, <a class="el" href="structdg_1_1_surjective_comm.html#a40da180c2b7d5d3a2355f19f1381885a">dg::SurjectiveComm&lt; Index, Vector &gt;</a>, and <a class="el" href="structdg_1_1_bijective_comm.html#ad9a309629c010ef6c629f09d50a8d4d6">dg::BijectiveComm&lt; Index, Vector &gt;</a>.</p>

</div>
</div>
<a id="acc738661d96a4d926541c14fd28723c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc738661d96a4d926541c14fd28723c6">&#9670;&nbsp;</a></span>communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal MPI communicator used. </p>
<p>e.g. used to assert that communicators of matrix and vector are the same </p><dl class="section return"><dt>Returns</dt><dd>MPI Communicator </dd></dl>

</div>
</div>
<a id="ab47cff828dccf9cca061ea32fe40189e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47cff828dccf9cca061ea32fe40189e">&#9670;&nbsp;</a></span>global_gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::global_gather </td>
          <td>(</td>
          <td class="paramtype">const LocalContainer &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalContainer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Globally (across processes) gather data into a buffer. </p>
<p>This is the transpose operation of <a class="el" href="structdg_1_1a_communicator.html#add6fe775b638b9ad86a7a6e692473434" title="Globally (across processes) scatter data accross processes and reduce on multiple indices...">global_scatter_reduce()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>data; other processes collect data from this vector </td></tr>
    <tr><td class="paramname">buffer</td><td>on output holds the gathered data ( must be of size <code><a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a" title="The size of the local buffer vector w = local map size. ">size()</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if <code><a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a" title="The size of the local buffer vector w = local map size. ">size()</a>==0</code> nothing happens </dd></dl>

</div>
</div>
<a id="a791dc0d9309f38350d8cfefbed86bee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791dc0d9309f38350d8cfefbed86bee9">&#9670;&nbsp;</a></span>global_gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LocalContainer <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::global_gather </td>
          <td>(</td>
          <td class="paramtype">const LocalContainer &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Globally (across processes) gather data into a buffer (memory allocating version) </p>
<p>This is the transpose operation of <a class="el" href="structdg_1_1a_communicator.html#add6fe775b638b9ad86a7a6e692473434" title="Globally (across processes) scatter data accross processes and reduce on multiple indices...">global_scatter_reduce()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>data; other processes collect data from this vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object that holds the gathered data </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if <code><a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a" title="The size of the local buffer vector w = local map size. ">size()</a>==0</code> the default constructor of <code>LocalContainer</code> is called </dd></dl>

</div>
</div>
<a id="add6fe775b638b9ad86a7a6e692473434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6fe775b638b9ad86a7a6e692473434">&#9670;&nbsp;</a></span>global_scatter_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::global_scatter_reduce </td>
          <td>(</td>
          <td class="paramtype">const LocalContainer &amp;&#160;</td>
          <td class="paramname"><em>toScatter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalContainer &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Globally (across processes) scatter data accross processes and reduce on multiple indices. </p>
<p>This is the transpose operation of <a class="el" href="structdg_1_1a_communicator.html#ab47cff828dccf9cca061ea32fe40189e" title="Globally (across processes) gather data into a buffer. ">global_gather()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toScatter</td><td>buffer vector; (has to be of size given by <a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a" title="The size of the local buffer vector w = local map size. ">size()</a>) </td></tr>
    <tr><td class="paramname">values</td><td>on output contains values from other processes sent back to the origin </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if <code><a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a" title="The size of the local buffer vector w = local map size. ">size()</a>==0</code> nothing happens </dd></dl>

</div>
</div>
<a id="ab6da46a52184be235645f0194f22cdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6da46a52184be235645f0194f22cdd2">&#9670;&nbsp;</a></span>isCommunicating()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::isCommunicating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the gather/scatter operation involves actual MPI communication. </p>
<p>This test can be used to avoid the gather operation alltogether in e.g. the construction of a MPI distributed matrix. </p><dl class="section return"><dt>Returns</dt><dd>False, if the global gather can be done without MPI communication (i.e. the indices are all local to each calling process). True else. </dd></dl>

</div>
</div>
<a id="ac3c1f30816b849bd1ee455ab174e1e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c1f30816b849bd1ee455ab174e1e3a">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a>&amp; <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a>&lt; LocalContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>only derived classes can assign </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a0553786aac2eb96308ec386e22ff6f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0553786aac2eb96308ec386e22ff6f3a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LocalContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1a_communicator.html">dg::aCommunicator</a>&lt; LocalContainer &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the local buffer vector w = local map size. </p>
<p>Consider that both the source vector v and the buffer w are distributed across processes. In Feltor the vector v is distributed equally among processes and the local size of v is the same for all processes. However the buffer size might be different for each process. </p><dl class="section return"><dt>Returns</dt><dd>buffer size </dd></dl>
<dl class="section note"><dt>Note</dt><dd>may return 0 to indicate that no MPI communication is needed </dd>
<dd>
we assume that, contrary to <code><a class="el" href="structdg_1_1a_communicator.html#a0553786aac2eb96308ec386e22ff6f3a" title="The size of the local buffer vector w = local map size. ">size()</a></code>, the vector size is always the local size of a <code><a class="el" href="structdg_1_1_m_p_i___vector.html" title="mpi Vector class ">dg::MPI_Vector</a></code> </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>backend/<a class="el" href="mpi__communicator_8h_source.html">mpi_communicator.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1a_communicator.html">aCommunicator</a></li>
    <li class="footer">Generated on Fri Jul 27 2018 10:23:38 for Discontinuous Galerkin Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
