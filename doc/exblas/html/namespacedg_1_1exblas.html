<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Extension: ExBLAS: dg::exblas Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/modules.html">dg</a></li>
    <li><a href="../../geometries/html/modules.html">dg::geo</a></li>
    <li><a href="../../file/html/modules.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Extension: ExBLAS
   </div>
   <div id="projectbrief">Adaption of the ExBLAS library (included in &quot;dg/algorithm.h&quot; by default or available as a standalone library as &quot;dg/exblas/exblas.h&quot;)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>dg</b></li><li class="navelem"><a class="el" href="namespacedg_1_1exblas.html">exblas</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dg::exblas Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the namespace for all functions and classes defined and used in the exblas library.  
<a href="namespacedg_1_1exblas.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedg_1_1exblas_1_1cpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas_1_1cpu.html">cpu</a></td></tr>
<tr class="memdesc:namespacedg_1_1exblas_1_1cpu"><td class="mdescLeft">&#160;</td><td class="mdescRight">cpu versions of the primitive functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedg_1_1exblas_1_1gpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas_1_1gpu.html">gpu</a></td></tr>
<tr class="memdesc:namespacedg_1_1exblas_1_1gpu"><td class="mdescLeft">&#160;</td><td class="mdescRight">gpu (CUDA) versions of primitive functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uniondg_1_1exblas_1_1udouble.html">udouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility union to display all bits of a double (using <a href="https://en.wikipedia.org/wiki/Type_punning">type-punning</a>)  <a href="uniondg_1_1exblas_1_1udouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a48b3fa9c609028c5a26e0280b35fbaa6"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 3&gt; </td></tr>
<tr class="memitem:a48b3fa9c609028c5a26e0280b35fbaa6"><td class="memTemplItemLeft" align="right" valign="top">__host__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas.html#a48b3fa9c609028c5a26e0280b35fbaa6">exdot_gpu</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, int64_t *d_superacc, int *status)</td></tr>
<tr class="memdesc:a48b3fa9c609028c5a26e0280b35fbaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU version of exact dot product.  <a href="namespacedg_1_1exblas.html#a48b3fa9c609028c5a26e0280b35fbaa6">More...</a><br /></td></tr>
<tr class="separator:a48b3fa9c609028c5a26e0280b35fbaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d1caab696c6453b99cdf9ab52daec8"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 3&gt; </td></tr>
<tr class="memitem:a95d1caab696c6453b99cdf9ab52daec8"><td class="memTemplItemLeft" align="right" valign="top">__host__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas.html#a95d1caab696c6453b99cdf9ab52daec8">exdot_gpu</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, PointerOrValue3 x3_ptr, int64_t *d_superacc, int *status)</td></tr>
<tr class="memdesc:a95d1caab696c6453b99cdf9ab52daec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU version of exact dot product.  <a href="namespacedg_1_1exblas.html#a95d1caab696c6453b99cdf9ab52daec8">More...</a><br /></td></tr>
<tr class="separator:a95d1caab696c6453b99cdf9ab52daec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b3aef855b6280b5a2fae8e89216e09"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 8&gt; </td></tr>
<tr class="memitem:a77b3aef855b6280b5a2fae8e89216e09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas.html#a77b3aef855b6280b5a2fae8e89216e09">exdot_omp</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, int64_t *h_superacc, int *status)</td></tr>
<tr class="memdesc:a77b3aef855b6280b5a2fae8e89216e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenMP parallel version of exact triple dot product.  <a href="namespacedg_1_1exblas.html#a77b3aef855b6280b5a2fae8e89216e09">More...</a><br /></td></tr>
<tr class="separator:a77b3aef855b6280b5a2fae8e89216e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a5971251a01870e26f2c769fef613d"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 8&gt; </td></tr>
<tr class="memitem:aa6a5971251a01870e26f2c769fef613d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas.html#aa6a5971251a01870e26f2c769fef613d">exdot_omp</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, PointerOrValue3 x3_ptr, int64_t *h_superacc, int *status)</td></tr>
<tr class="memdesc:aa6a5971251a01870e26f2c769fef613d"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenMP parallel version of exact triple dot product.  <a href="namespacedg_1_1exblas.html#aa6a5971251a01870e26f2c769fef613d">More...</a><br /></td></tr>
<tr class="separator:aa6a5971251a01870e26f2c769fef613d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020aba11430835ed502b897fe94eab6d"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 8&gt; </td></tr>
<tr class="memitem:a020aba11430835ed502b897fe94eab6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas.html#a020aba11430835ed502b897fe94eab6d">exdot_cpu</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, int64_t *h_superacc, int *status)</td></tr>
<tr class="memdesc:a020aba11430835ed502b897fe94eab6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial version of exact dot product.  <a href="namespacedg_1_1exblas.html#a020aba11430835ed502b897fe94eab6d">More...</a><br /></td></tr>
<tr class="separator:a020aba11430835ed502b897fe94eab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5511b744a196e5830b9094b371832bbe"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 8&gt; </td></tr>
<tr class="memitem:a5511b744a196e5830b9094b371832bbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas.html#a5511b744a196e5830b9094b371832bbe">exdot_cpu</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, PointerOrValue3 x3_ptr, int64_t *h_superacc, int *status)</td></tr>
<tr class="memdesc:a5511b744a196e5830b9094b371832bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial version of exact dot product.  <a href="namespacedg_1_1exblas.html#a5511b744a196e5830b9094b371832bbe">More...</a><br /></td></tr>
<tr class="separator:a5511b744a196e5830b9094b371832bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e81c6d1be55e0ad3f58c791f711315"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas.html#a69e81c6d1be55e0ad3f58c791f711315">mpi_reduce_communicator</a> (MPI_Comm comm, MPI_Comm *comm_mod, MPI_Comm *comm_mod_reduce)</td></tr>
<tr class="memdesc:a69e81c6d1be55e0ad3f58c791f711315"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be used to partition communicators for the <code><a class="el" href="namespacedg_1_1exblas.html#af724256742492b85f5a729c9699c398e" title="reduce a number of superaccumulators distributed among mpi processes">exblas::reduce_mpi_cpu</a></code> function.  <a href="namespacedg_1_1exblas.html#a69e81c6d1be55e0ad3f58c791f711315">More...</a><br /></td></tr>
<tr class="separator:a69e81c6d1be55e0ad3f58c791f711315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af724256742492b85f5a729c9699c398e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas.html#af724256742492b85f5a729c9699c398e">reduce_mpi_cpu</a> (unsigned num_superacc, int64_t *in, int64_t *out, MPI_Comm comm, MPI_Comm comm_mod, MPI_Comm comm_mod_reduce)</td></tr>
<tr class="memdesc:af724256742492b85f5a729c9699c398e"><td class="mdescLeft">&#160;</td><td class="mdescRight">reduce a number of superaccumulators distributed among mpi processes  <a href="namespacedg_1_1exblas.html#af724256742492b85f5a729c9699c398e">More...</a><br /></td></tr>
<tr class="separator:af724256742492b85f5a729c9699c398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the namespace for all functions and classes defined and used in the exblas library. </p>
<p>In principle you can use this as a standalone library but it is much easier to just use the <code>dg::blas1::dot</code> and <code>dg::blas2::dot</code> functions for general purpose usage </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a020aba11430835ed502b897fe94eab6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020aba11430835ed502b897fe94eab6d">&#9670;&nbsp;</a></span>exdot_cpu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::exdot_cpu </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1&#160;</td>
          <td class="paramname"><em>x1_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2&#160;</td>
          <td class="paramname"><em>x2_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>h_superacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serial version of exact dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a2f7276f907e32c14eb50f7cf1f9c6142">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a0e48bd1ab779211fb7d10b9437c26a30">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array</td></tr>
    <tr><td class="paramname">h_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>host memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5511b744a196e5830b9094b371832bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5511b744a196e5830b9094b371832bbe">&#9670;&nbsp;</a></span>exdot_cpu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::exdot_cpu </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1&#160;</td>
          <td class="paramname"><em>x1_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2&#160;</td>
          <td class="paramname"><em>x2_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue3&#160;</td>
          <td class="paramname"><em>x3_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>h_superacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serial version of exact dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i w_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a2f7276f907e32c14eb50f7cf1f9c6142">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a0e48bd1ab779211fb7d10b9437c26a30">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iw_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array </td></tr>
    <tr><td class="paramname">x3_ptr</td><td>third array</td></tr>
    <tr><td class="paramname">h_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>host memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48b3fa9c609028c5a26e0280b35fbaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b3fa9c609028c5a26e0280b35fbaa6">&#9670;&nbsp;</a></span>exdot_gpu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ void dg::exblas::exdot_gpu </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1&#160;</td>
          <td class="paramname"><em>x1_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2&#160;</td>
          <td class="paramname"><em>x2_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>d_superacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPU version of exact dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a2f7276f907e32c14eb50f7cf1f9c6142">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a0e48bd1ab779211fb7d10b9437c26a30">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array</td></tr>
    <tr><td class="paramname">d_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>device memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95d1caab696c6453b99cdf9ab52daec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d1caab696c6453b99cdf9ab52daec8">&#9670;&nbsp;</a></span>exdot_gpu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ void dg::exblas::exdot_gpu </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1&#160;</td>
          <td class="paramname"><em>x1_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2&#160;</td>
          <td class="paramname"><em>x2_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue3&#160;</td>
          <td class="paramname"><em>x3_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>d_superacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPU version of exact dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i w_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a2f7276f907e32c14eb50f7cf1f9c6142">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a0e48bd1ab779211fb7d10b9437c26a30">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iw_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array </td></tr>
    <tr><td class="paramname">x3_ptr</td><td>third array</td></tr>
    <tr><td class="paramname">d_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>device memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77b3aef855b6280b5a2fae8e89216e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b3aef855b6280b5a2fae8e89216e09">&#9670;&nbsp;</a></span>exdot_omp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::exdot_omp </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1&#160;</td>
          <td class="paramname"><em>x1_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2&#160;</td>
          <td class="paramname"><em>x2_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>h_superacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenMP parallel version of exact triple dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a2f7276f907e32c14eb50f7cf1f9c6142">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a0e48bd1ab779211fb7d10b9437c26a30">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array</td></tr>
    <tr><td class="paramname">h_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>host memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6a5971251a01870e26f2c769fef613d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a5971251a01870e26f2c769fef613d">&#9670;&nbsp;</a></span>exdot_omp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::exdot_omp </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1&#160;</td>
          <td class="paramname"><em>x1_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2&#160;</td>
          <td class="paramname"><em>x2_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue3&#160;</td>
          <td class="paramname"><em>x3_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>h_superacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenMP parallel version of exact triple dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i w_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a2f7276f907e32c14eb50f7cf1f9c6142">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a0e48bd1ab779211fb7d10b9437c26a30">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iw_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array </td></tr>
    <tr><td class="paramname">x3_ptr</td><td>third array</td></tr>
    <tr><td class="paramname">h_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>host memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69e81c6d1be55e0ad3f58c791f711315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e81c6d1be55e0ad3f58c791f711315">&#9670;&nbsp;</a></span>mpi_reduce_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dg::exblas::mpi_reduce_communicator </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm *&#160;</td>
          <td class="paramname"><em>comm_mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm *&#160;</td>
          <td class="paramname"><em>comm_mod_reduce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function can be used to partition communicators for the <code><a class="el" href="namespacedg_1_1exblas.html#af724256742492b85f5a729c9699c398e" title="reduce a number of superaccumulators distributed among mpi processes">exblas::reduce_mpi_cpu</a></code> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>the input communicator (unmodified, may not be <code>MPI_COMM_NULL</code>) </td></tr>
    <tr><td class="paramname">comm_mod</td><td>a subgroup of comm (comm is split) </td></tr>
    <tr><td class="paramname">comm_mod_reduce</td><td>a subgroup of comm, consists of all rank 0 processes in comm_mod </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the creation of new communicators involves communication between all participation processes (comm in this case). </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>In order to avoid excessive creation of new MPI communicators (there is a limit to how many a program can create), the function keeps record of which communicators it has been called with. If you repeatedly call this function with the same <code>comm</code> only the first call will actually create new communicators. </dd></dl>

</div>
</div>
<a id="af724256742492b85f5a729c9699c398e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af724256742492b85f5a729c9699c398e">&#9670;&nbsp;</a></span>reduce_mpi_cpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dg::exblas::reduce_mpi_cpu </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_superacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm_mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm_mod_reduce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reduce a number of superaccumulators distributed among mpi processes </p>
<p>We cannot sum more than 256 accumulators before we need to normalize again, so we need to split the reduction into several steps if more than 256 processes are involved. This function normalizes, reduces, normalizes, reduces and broadcasts the result to all participating processes. As usual the resulting superaccumulator is unnormalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_superacc</td><td>number of Superaccumulators eaach process holds </td></tr>
    <tr><td class="paramname">in</td><td>unnormalized input superaccumulators ( must be of size num_superacc*<code>exblas::BIN_COUNT</code>, allocated on the cpu) (read/write, undefined on out) </td></tr>
    <tr><td class="paramname">out</td><td>each process contains the result on output( must be of size num_superacc*<code>exblas::BIN_COUNT</code>, allocated on the cpu) (write, may not alias in) </td></tr>
    <tr><td class="paramname">comm</td><td>The complete MPI communicator </td></tr>
    <tr><td class="paramname">comm_mod</td><td>This is comm modulo 128 ( or any other number &lt;256) </td></tr>
    <tr><td class="paramname">comm_mod_reduce</td><td>This is the communicator consisting of all rank 0 processes in comm_mod, may be <code>MPI_COMM_NULL</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespacedg_1_1exblas.html#a69e81c6d1be55e0ad3f58c791f711315" title="This function can be used to partition communicators for the exblas::reduce_mpi_cpu function.">exblas::mpi_reduce_communicator</a></code> to generate the required communicators </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
